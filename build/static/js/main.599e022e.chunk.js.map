{"version":3,"sources":["serviceWorker.js","mazeAlgorithms/recursiveDivision.js","pathfindingVisualizer/Node/node.jsx","pathfindingVisualizer/navbar.jsx","pathfindingAlgorithms/dijkstra.js","pathfindingVisualizer/pathfindingVisualizer.jsx","index.js"],"names":["Boolean","window","location","hostname","match","walls","Node","props","state","cellHeight","this","row","col","isStart","isFinish","isWall","isVisited","isShortest","onMouseEnter","onMouseDown","onMouseUp","width","height","numRows","numColumns","extraClass","cellWidth","Math","floor","id","className","style","Component","brand","innerWidth","NavBar","algorithm","maze","pathState","mazeState","speedState","selection","visualizingAlgorithm","setState","clearPath","generatingMaze","clearGrid","clearTemp","visualizeDijkstra","generateRecursiveDivisionMaze","speed","value","updateSpeed","href","type","data-toggle","aria-haspopup","aria-expanded","aria-labelledby","onClick","selectAlgorithm","visualizeAlgorithm","selectMaze","generateMaze","changeSpeed","dijkstra","grid","startNode","finishNode","distance","unvisitedNodes","nodes","node","push","getNodes","visitedNodesInOrder","length","sort","a","b","closestNode","shift","Infinity","updateUnvisitedNeighbours","unvisitedNeighbours","neighbours","filter","neighbour","getUnvisitedNeighbours","unvisitedNeighbour","previousNode","recursiveDivisionMaze","vertical","range","horizontal","getRecursiveWalls","dir","num","generateOddRandomNumber","addWall","slice","indexOf","len","result","i","array","max","randomNum","random","isStartFinish","tempWalls","temp","splice","generateRandomNumber","wall","initialNum","getInitialNum","innerHeight","initialNumRows","initialNumColumns","startFinishNode","randomNums","x","y","startNodeRow","startNodeCol","finishNodeRow","finishNodeCol","getRandomNums","getStartFinishNode","PathfindingVisualizer","mouseIsPressed","mazeSpeed","updateDimensions","path","animateShortestPath","nodesInShortestPathOrder","setTimeout","newGrid","updateNodesForRender","document","getElementById","animateAlgorithm","newNode","animateMaze","getNewGridWithMaze","addEventListener","getInitialGrid","getNewGridWithWalls","getGridWithoutPath","currentNode","unshift","getNodesInShortestPathOrderDijkstra","Fragment","bind","map","rowId","key","nodeId","handleMouseDown","handleMouseEnter","handleMouseUp","class","randomNums1","randomNums2","currentRow","createNode","totalDistance","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.599e022e.chunk.js","sourcesContent":["\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n\n    window.location.hostname === '[::1]' ||\n\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n   \n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n     \n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        \n        checkValidServiceWorker(swUrl, config);\n\n        \n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        \n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n         \n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n             \n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              \n              console.log('Content is cached for offline use.');\n\n          \n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","let walls;\nexport function recursiveDivisionMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n}\n\n//dir === 0 => Horizontal\n//dir === 1 => Vertical\n\nfunction getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode) {\n  if (vertical.length < 2 || horizontal.length < 2) {\n    return;\n  }\n  let dir;\n  let num;\n  if (vertical.length > horizontal.length) {\n    dir = 0;\n    num = generateOddRandomNumber(vertical);\n  }\n  if (vertical.length <= horizontal.length) {\n    dir = 1;\n    num = generateOddRandomNumber(horizontal);\n  }\n\n  if (dir === 0) {\n    addWall(dir, num, vertical, horizontal, startNode, finishNode);\n    getRecursiveWalls(\n      vertical.slice(0, vertical.indexOf(num)),\n      horizontal,\n      grid,\n      startNode,\n      finishNode\n    );\n    getRecursiveWalls(\n      vertical.slice(vertical.indexOf(num) + 1),\n      horizontal,\n      grid,\n      startNode,\n      finishNode\n    );\n  } else {\n    addWall(dir, num, vertical, horizontal, startNode, finishNode);\n    getRecursiveWalls(\n      vertical,\n      horizontal.slice(0, horizontal.indexOf(num)),\n      grid,\n      startNode,\n      finishNode\n    );\n    getRecursiveWalls(\n      vertical,\n      horizontal.slice(horizontal.indexOf(num) + 1),\n      grid,\n      startNode,\n      finishNode\n    );\n  }\n}\n\nfunction generateOddRandomNumber(array) {\n  let max = array.length - 1;\n  let randomNum =\n    Math.floor(Math.random() * (max / 2)) +\n    Math.floor(Math.random() * (max / 2));\n  if (randomNum % 2 === 0) {\n    if (randomNum === max) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n  return array[randomNum];\n}\n\n//dir === 0 => Horizontal\n//dir === 1 => Vertical\n\nfunction addWall(dir, num, vertical, horizontal, startNode, finishNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  if (dir === 0) {\n    if (horizontal.length === 2) return;\n    for (let temp of horizontal) {\n      if (\n        (temp === startNode.row && num === startNode.col) ||\n        (temp === finishNode.row && num === finishNode.col)\n      ) {\n        isStartFinish = true;\n        continue;\n      }\n      tempWalls.push([temp, num]);\n    }\n  } else {\n    if (vertical.length === 2) return;\n    for (let temp of vertical) {\n      if (\n        (num === startNode.row && temp === startNode.col) ||\n        (num === finishNode.row && temp === finishNode.col)\n      ) {\n        isStartFinish = true;\n        continue;\n      }\n      tempWalls.push([num, temp]);\n    }\n  }\n  if (!isStartFinish) {\n    tempWalls.splice(generateRandomNumber(tempWalls.length), 1);\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}\n\nfunction generateRandomNumber(max) {\n  let randomNum =\n    Math.floor(Math.random() * (max / 2)) +\n    Math.floor(Math.random() * (max / 2));\n  if (randomNum % 2 !== 0) {\n    if (randomNum === max) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n  return randomNum;\n}\n","import React, { Component } from \"react\";\nimport \"./node.css\";\n\nclass Node extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n\n  render() {\n    const {\n      row,\n      col,\n      isStart,\n      isFinish,\n      isWall,\n      isVisited,\n      isShortest,\n      onMouseEnter,\n      onMouseDown,\n      onMouseUp,\n      width,\n      height,\n      numRows,\n      numColumns,\n    } = this.props;\n\n    const extraClass = isStart\n      ? \"node node-start\"\n      : isFinish\n      ? \"node node-finish\"\n      : isWall\n      ? \"node-wall\"\n      : isShortest\n      ? \"node node-shortest-path\"\n      : isVisited\n      ? \"node node-visited\"\n      : \"node\";\n\n    let cellWidth = Math.floor((width - 15) / numColumns);\n    let cellHeight;\n    if (width > 1500) {\n      cellHeight = Math.floor((height - 70) / numRows);\n    } else if (width > 1000) {\n      cellHeight = Math.floor((height - 70) / numRows);\n    } else if (width > 500) {\n      cellHeight = Math.floor((height - 60) / numRows);\n    } else if (width > 0) {\n      cellHeight = Math.floor((height - 50) / numRows);\n    }\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`${extraClass}`}\n        style={{ \"--width\": `${cellWidth}px`, \"--height\": `${cellHeight}px` }}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseUp={() => onMouseUp()}\n      ></div>\n    );\n  }\n}\n\nexport default Node;\n","import React, { Component } from \"react\";\nimport \"./navbar.css\";\n\nconst brand = window.innerWidth > 600 ? \"Pathfinding Visualizer\" : \"Pathfinder\";\n\nclass NavBar extends Component {\n  state = {\n    algorithm: \"Visualize Algorithm\",\n    maze: \"Generate Maze\",\n    pathState: false,\n    mazeState: false,\n    speedState: \"Speed\",\n  };\n\n  selectAlgorithm(selection) {\n    if (this.props.visualizingAlgorithm) {\n      return;\n    }\n    if (\n      selection === this.state.algorithm ||\n      this.state.algorithm === \"Visualize Algorithm\" ||\n      this.state.algorithm === \"Select an Algorithm!\"\n    ) {\n      this.setState({ algorithm: selection });\n    } else if (this.state.pathState) {\n      this.clearPath();\n      this.setState({ algorithm: selection });\n    } else {\n      this.setState({ algorithm: selection });\n    }\n  }\n\n  selectMaze(selection) {\n    if (this.props.visualizingAlgorithm || this.props.generatingMaze) {\n      return;\n    }\n    if (\n      selection === this.state.maze ||\n      this.state.maze === \"Generate Maze\" ||\n      this.state.maze === \"Select a Maze!\"\n    ) {\n      this.setState({ maze: selection });\n    } else if (!this.state.mazeState) {\n      this.setState({ maze: selection });\n    } else {\n      this.clearGrid();\n      this.setState({ maze: selection });\n    }\n  }\n\n  visualizeAlgorithm() {\n    if (this.props.visualizingAlgorithm || this.props.generatingMaze) {\n      return;\n    }\n    if (this.state.pathState) {\n      this.clearTemp();\n      return;\n    }\n    if (\n      this.state.algorithm === \"Visualize Algorithm\" ||\n      this.state.algorithm === \"Select an Algorithm!\"\n    ) {\n      this.setState({ algorithm: \"Select an Algorithm!\" });\n    } else {\n      this.setState({ pathState: true });\n      if (this.state.algorithm === \"Visualize Dijkstra\")\n        this.props.visualizeDijkstra();\n    }\n  }\n\n  generateMaze() {\n    if (this.props.visualizingAlgorithm || this.props.generatingMaze) {\n      return;\n    }\n    if (this.state.mazeState || this.state.pathState) {\n      this.clearTemp();\n    }\n    if (\n      this.state.maze === \"Generate Maze\" ||\n      this.state.maze === \"Select a Maze!\"\n    ) {\n      this.setState({ maze: \"Select a Maze!\" });\n    } else {\n      this.setState({ mazeState: true });\n      if (this.state.maze === \"Generate Recursive Maze\")\n        this.props.generateRecursiveDivisionMaze();\n    }\n  }\n\n  clearGrid() {\n    if (this.props.visualizingAlgorithm || this.props.generatingMaze) {\n      return;\n    }\n    this.props.clearGrid();\n    this.setState({\n      algorithm: \"Visualize Algorithm\",\n      maze: \"Generate Maze\",\n      pathState: false,\n      mazeState: false,\n    });\n  }\n\n  clearPath() {\n    if (this.props.visualizingAlgorithm || this.props.generatingMaze) {\n      return;\n    }\n    this.props.clearPath();\n    this.setState({\n      pathState: false,\n      mazeState: false,\n    });\n  }\n\n  clearTemp() {\n    if (this.props.visualizingAlgorithm || this.props.generatingMaze) {\n      return;\n    }\n    this.props.clearGrid();\n    this.setState({\n      pathState: false,\n      mazeState: false,\n    });\n  }\n\n  changeSpeed(speed) {\n    if (this.props.visualizingAlgorithm || this.props.generatingMaze) {\n      return;\n    }\n    let value = [10, 10];\n    if (speed === \"Slow\") value = [50, 30];\n    else if (speed === \"Medium\") value = [25, 20];\n    else if (speed === \"Fast\") value = [10, 10];\n    this.setState({ speedState: speed });\n    this.props.updateSpeed(value[0], value[1]);\n  }\n\n  render() {\n    return (\n      <nav className=\"navbar-fixed-top navbar navbar-expand navbar-dark bg-dark \">\n        <a className=\"navbar-brand h1 mb-0\"\n          href=\"#\" > {brand}</a>\n        <div className=\"navbar-collapse\" id=\"navbarNavDropdown\">\n          <ul className=\"navbar-nav\">\n            <li className=\"nav-item dropdown\">\n              <div className=\"dropdown\">\n                <button\n                  className=\"btn btn-light dropdown-toggle\"\n                  type=\"button\"\n                  id=\"dropdownMenu1\"\n                  data-toggle=\"dropdown\"\n                  aria-haspopup=\"true\"\n                  aria-expanded=\"false\"\n                >\n                  Algorithms\n                </button>\n                <div className=\"dropdown-menu\" aria-labelledby=\"dropdownMenu1\">\n                  <button\n                    className=\"dropdown-item btn-light\"\n                    type=\"button\"\n                    onClick={() => this.selectAlgorithm(\"Visualize Dijkstra\")}\n                  >\n                    Dijkstra's Algorithm\n                  </button>\n                  </div>\n                <div className=\"dropdown-menu\" aria-labelledby=\"dropdownMenu2\">\n                  <button\n                    className=\"dropdown-item btn-light\"\n                    type=\"button\"\n                    onClick={() => this.selectAlgorithm(\"Visualize Dijkstra\")}\n                  >\n                    Dijkstra's Algorithm\n                  </button>\n                </div>\n              </div>{\" \"}\n            </li>\n            <li>\n              <button\n                type=\"button\"\n                className=\"btn btn-success\"\n                onClick={() => this.visualizeAlgorithm()}\n              >\n                {this.state.algorithm}\n              </button>\n            </li>\n            <li className=\"nav-item dropdown\">\n              <div className=\"dropdown\">\n                <button\n                  className=\"btn btn-light dropdown-toggle\"\n                  type=\"button\"\n                  id=\"dropdownMenu1\"\n                  data-toggle=\"dropdown\"\n                  aria-haspopup=\"true\"\n                  aria-expanded=\"false\"\n                >\n                  Mazes\n                </button>\n                <div className=\"dropdown-menu\" aria-labelledby=\"dropdownMenu1\">\n                  \n                  <button\n                    className=\"dropdown-item btn-light\"\n                    type=\"button\"\n                    onClick={() => this.selectMaze(\"Generate Recursive Maze\")}\n                  >\n                    Recursive Division Maze\n                  </button>\n                  \n                </div>\n              </div>{\" \"}\n            </li>\n            <li>\n              <button\n                type=\"button\"\n                className=\"btn btn-success\"\n                onClick={() => this.generateMaze()}\n              >\n                {this.state.maze}\n              </button>\n            </li>\n            <li>\n              <button\n                type=\"button\"\n                className=\"btn btn-danger\"\n                onClick={() => this.clearGrid()}\n              >\n                Clear Gird\n              </button>\n            </li>\n            <li className=\"nav-item dropdown\">\n              <div className=\"dropdown\">\n                <button\n                  className=\"btn btn-info dropdown-toggle\"\n                  type=\"button\"\n                  id=\"dropdownMenu1\"\n                  data-toggle=\"dropdown\"\n                  aria-haspopup=\"true\"\n                  aria-expanded=\"false\"\n                >\n                  {this.state.speedState}\n                </button>\n                <div className=\"dropdown-menu\" aria-labelledby=\"dropdownMenu1\">\n                  <button\n                    className=\"dropdown-item btn-light\"\n                    type=\"button\"\n                    onClick={() => this.changeSpeed(\"Slow\")}\n                  >\n                    Slow\n                  </button>\n                  <button\n                    className=\"dropdown-item btn-light\"\n                    type=\"button\"\n                    onClick={() => this.changeSpeed(\"Medium\")}\n                  >\n                    Medium\n                  </button>\n                  <button\n                    className=\"dropdown-item btn-light\"\n                    type=\"button\"\n                    onClick={() => this.changeSpeed(\"Fast\")}\n                  >\n                    Fast\n                  </button>\n                </div>\n              </div>{\" \"}\n            </li>\n\n            <li>\n              <button\n                type=\"button\"\n                className=\"btn btn-success learn-btn\"><a href=\"#learn\">Learn More</a>\n              </button>\n            </li>\n          </ul>\n        </div>\n      </nav>\n    );\n  }\n}\nexport default NavBar;\n","export function dijkstra(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  startNode.distance = 0;\n  let unvisitedNodes = getNodes(grid);\n  let visitedNodesInOrder = [];\n  while (unvisitedNodes.length !== 0) {\n    unvisitedNodes.sort((a, b) => a.distance - b.distance);\n    let closestNode = unvisitedNodes.shift();\n    if (closestNode.isWall) continue;\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    updateUnvisitedNeighbours(closestNode, grid);\n  }\n}\n\nfunction getNodes(grid) {\n  let nodes = [];\n  for (let row of grid) {\n    for (let node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\nfunction updateUnvisitedNeighbours(node, grid) {\n  let unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\n  for (let unvisitedNeighbour of unvisitedNeighbours) {\n    unvisitedNeighbour.distance = node.distance + 1;\n    unvisitedNeighbour.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n  let neighbours = [];\n  let { row, col } = node;\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  return neighbours\n    .filter((neighbour) => !neighbour.isWall)\n    .filter((neighbour) => !neighbour.isVisited);\n}\n\nexport function getNodesInShortestPathOrderDijkstra(finishNode) {\n  let nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","import React, { Component } from \"react\";\nimport \"./pathfindingVisualizer.css\";\nimport Node from \"./Node/node\";\nimport NavBar from \"./navbar\";\n\n//Pathfinding Algorithms\nimport {\n  dijkstra,\n  getNodesInShortestPathOrderDijkstra,\n} from \"../pathfindingAlgorithms/dijkstra\";\n\n\n//Maze Algorithms\nimport { recursiveDivisionMaze } from \"../mazeAlgorithms/recursiveDivision\";\n\nconst initialNum = getInitialNum(window.innerWidth, window.innerHeight);\nconst initialNumRows = initialNum[0];\nconst initialNumColumns = initialNum[1];\n\nconst startFinishNode = getStartFinishNode(initialNumRows, initialNumColumns);\nconst startNodeRow = startFinishNode[0];\nconst startNodeCol = startFinishNode[1];\nconst finishNodeRow = startFinishNode[2];\nconst finishNodeCol = startFinishNode[3];\n\nclass PathfindingVisualizer extends Component {\n  state = {\n    grid: [],\n    mouseIsPressed: false,\n    visualizingAlgorithm: false,\n    generatingMaze: false,\n    width: window.innerWidth,\n    height: window.innerHeight,\n    numRows: initialNumRows,\n    numColumns: initialNumColumns,\n    speed: 10,\n    mazeSpeed: 10,\n  };\n\n  updateDimensions = () => {\n    this.setState({\n      width: window.innerWidth,\n      height: window.innerHeight,\n    });\n  };\n\n  updateSpeed = (path, maze) => {\n    this.setState({ speed: path, mazeSpeed: maze });\n  };\n\n  componentDidMount() {\n    window.addEventListener(\"resize\", this.updateDimensions);\n    const grid = getInitialGrid(this.state.numRows, this.state.numColumns);\n    this.setState({ grid });\n  }\n\n  handleMouseDown(row, col) {\n    const newGrid = getNewGridWithWalls(this.state.grid, row, col);\n    this.setState({ grid: newGrid, mouseIsPressed: true });\n  }\n\n  handleMouseEnter(row, col) {\n    if (this.state.mouseIsPressed) {\n      const newGrid = getNewGridWithWalls(this.state.grid, row, col);\n      this.setState({ grid: newGrid, mouseIsPressed: true });\n    }\n  }\n\n  handleMouseUp() {\n    this.setState({ mouseIsPressed: false });\n  }\n\n  clearGrid() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n    for (let row = 0; row < this.state.grid.length; row++) {\n      for (let col = 0; col < this.state.grid[0].length; col++) {\n        if (\n          !(\n            (row === startNodeRow && col === startNodeCol) ||\n            (row === finishNodeRow && col === finishNodeCol)\n          )\n        ) {\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\n        }\n      }\n    }\n    const newGrid = getInitialGrid(this.state.numRows, this.state.numColumns);\n    this.setState({\n      grid: newGrid,\n      visualizingAlgorithm: false,\n      generatingMaze: false,\n    });\n  }\n\n  clearPath() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n    for (let row = 0; row < this.state.grid.length; row++) {\n      for (let col = 0; col < this.state.grid[0].length; col++) {\n        if (\n          document.getElementById(`node-${row}-${col}`).className ===\n          \"node node-shortest-path\"\n        ) {\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\n        }\n      }\n    }\n    const newGrid = getGridWithoutPath(this.state.grid);\n    this.setState({\n      grid: newGrid,\n      visualizingAlgorithm: false,\n      generatingMaze: false,\n    });\n  }\n\n  animateShortestPath = (nodesInShortestPathOrder, visitedNodesInOrder) => {\n    if (nodesInShortestPathOrder.length === 1)\n      this.setState({ visualizingAlgorithm: false });\n    for (let i = 1; i < nodesInShortestPathOrder.length; i++) {\n      if (i === nodesInShortestPathOrder.length - 1) {\n        setTimeout(() => {\n          let newGrid = updateNodesForRender(\n            this.state.grid,\n            nodesInShortestPathOrder,\n            visitedNodesInOrder\n          );\n          this.setState({ grid: newGrid, visualizingAlgorithm: false });\n        }, i * (3 * this.state.speed));\n        return;\n      }\n      let node = nodesInShortestPathOrder[i];\n      setTimeout(() => {\n        //shortest path node\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-shortest-path\";\n      }, i * (3 * this.state.speed));\n    }\n  };\n\n  animateAlgorithm = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n    let newGrid = this.state.grid.slice();\n    for (let row of newGrid) {\n      for (let node of row) {\n        let newNode = {\n          ...node,\n          isVisited: false,\n        };\n        newGrid[node.row][node.col] = newNode;\n      }\n    }\n    this.setState({ grid: newGrid });\n    for (let i = 1; i <= visitedNodesInOrder.length; i++) {\n      let node = visitedNodesInOrder[i];\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(\n            nodesInShortestPathOrder,\n            visitedNodesInOrder\n          );\n        }, i * this.state.speed);\n        return;\n      }\n      setTimeout(() => {\n        //visited node\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-visited\";\n      }, i * this.state.speed);\n    }\n  };\n\n  visualizeDijkstra() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n    this.setState({ visualizingAlgorithm: true });\n    setTimeout(() => {\n      const { grid } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n      const nodesInShortestPathOrder = getNodesInShortestPathOrderDijkstra(\n        finishNode\n      );\n      this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, this.state.speed);\n  }\n\n\n  animateMaze = (walls) => {\n    for (let i = 0; i <= walls.length; i++) {\n      if (i === walls.length) {\n        setTimeout(() => {\n          this.clearGrid();\n          let newGrid = getNewGridWithMaze(this.state.grid, walls);\n          this.setState({ grid: newGrid, generatingMaze: false });\n        }, i * this.state.mazeSpeed);\n        return;\n      }\n      let wall = walls[i];\n      let node = this.state.grid[wall[0]][wall[1]];\n      setTimeout(() => {\n        //Walls\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-wall-animated\";\n      }, i * this.state.mazeSpeed);\n    }\n  };\n\n\n\n  generateRecursiveDivisionMaze() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n    this.setState({ generatingMaze: true });\n    setTimeout(() => {\n      const { grid } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const walls = recursiveDivisionMaze(grid, startNode, finishNode);\n      this.animateMaze(walls);\n    }, this.state.mazeSpeed);\n  }\n\n  render() {\n    let { grid } = this.state;\n    return (\n      <React.Fragment>\n        <NavBar\n          visualizingAlgorithm={this.state.visualizingAlgorithm}\n          generatingMaze={this.state.generatingMaze}\n          visualizeDijkstra={this.visualizeDijkstra.bind(this)}\n          generateRecursiveDivisionMaze={this.generateRecursiveDivisionMaze.bind( this)}\n          clearGrid={this.clearGrid.bind(this)}\n          clearPath={this.clearPath.bind(this)}\n          updateSpeed={this.updateSpeed.bind(this)}\n        />\n\n        <div\n          className={\n            this.state.visualizingAlgorithm || this.state.generatingMaze\n              ? \"grid-visualizing\"\n              : \"grid\"\n          }\n        >\n          {grid.map((row, rowId) => {\n            return (\n              <div key={rowId}>\n                {row.map((node, nodeId) => {\n                  const {\n                    row,\n                    col,\n                    isStart,\n                    isFinish,\n                    isVisited,\n                    isShortest,\n                    isWall,\n                  } = node;\n                  return (\n                    <Node\n                      key={nodeId}\n                      row={row}\n                      col={col}\n                      isStart={isStart}\n                      isFinish={isFinish}\n                      isVisited={isVisited}\n                      isShortest={isShortest}\n                      isWall={isWall}\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                      onMouseEnter={(row, col) =>\n                        this.handleMouseEnter(row, col)\n                      }\n                      onMouseUp={() => this.handleMouseUp()}\n                      width={this.state.width}\n                      height={this.state.height}\n                      numRows={this.state.numRows}\n                      numColumns={this.state.numColumns}\n                    ></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n        <div className=\"learn\" id=\"learn\">\n        <h1 class=\"learn_header\">Dijkstra's Algorithm</h1><hr></hr><br></br>\n          <p class=\"learn_intro\"><strong>Dijkstra's Algorithm</strong> basically starts at the node that you choose (the source node) and it analyzes the graph to find the shortest path between that node and all the other nodes in the graph.\nThe algorithm keeps track of the currently known shortest distance from each node to the source node and it updates these values if it finds a shorter path.\nOnce the algorithm has found the shortest path between the source node and another node, that node is marked as \"visited\" and added to the path.\nThe process continues until all the nodes in the graph have been added to the path. This way, we have a path that connects the source node to all other nodes following the shortest path possible to reach each node.</p>\n\n          <h3 class=\"algo\">Algorithm:</h3>\n          <div class=\"algo_content\">\n          1) Create a set sptSet (shortest path tree set) that keeps track of vertices included in the shortest-path tree, i.e., whose minimum distance from the source is calculated and finalized. Initially, this set is empty. <br></br>\n2) Assign a distance value to all vertices in the input graph. Initialize all distance values as INFINITE. Assign distance value as 0 for the source vertex so that it is picked first. <br></br>\n3) While sptSet doesn’t include all vertices <br></br>\n….a) Pick a vertex u which is not there in sptSet and has a minimum distance value. <br></br>\n….b) Include u to sptSet. <br></br>\n….c) Update distance value of all adjacent vertices of u. <br></br>To update the distance values, iterate through all adjacent vertices. For every adjacent vertex v, if the sum of distance value of u (from source) and weight of edge u-v, is less than the distance value of v, then update the distance value of v. <br></br>\n          </div>\n          </div>\n      </React.Fragment>\n    );\n    \n  }\n}\n\nfunction getInitialNum(width, height) {\n  let numColumns;\n  if (width > 1500) {\n    numColumns = Math.floor(width / 25);\n  } else if (width > 1250) {\n    numColumns = Math.floor(width / 22.5);\n  } else if (width > 1000) {\n    numColumns = Math.floor(width / 20);\n  } else if (width > 750) {\n    numColumns = Math.floor(width / 17.5);\n  } else if (width > 500) {\n    numColumns = Math.floor(width / 15);\n  } else if (width > 250) {\n    numColumns = Math.floor(width / 12.5);\n  } else if (width > 0) {\n    numColumns = Math.floor(width / 10);\n  }\n  let cellWidth = Math.floor(width / numColumns);\n  let numRows = Math.floor(height / cellWidth);\n  return [numRows, numColumns];\n}\n\nfunction getRandomNums(num) {\n  let randomNums1 = [];\n  let temp = 2;\n  for (let i = 5; i < num / 2; i += 2) {\n    randomNums1.push(temp);\n    temp += 2;\n  }\n  let randomNums2 = [];\n  temp = -2;\n  for (let i = num / 2; i < num - 5; i += 2) {\n    randomNums2.push(temp);\n    temp -= 2;\n  }\n  return [randomNums1, randomNums2];\n}\n\nfunction getStartFinishNode(numRows, numColumns) {\n  let randomNums;\n  let x;\n  let y;\n  let startNodeRow;\n  let startNodeCol;\n  let finishNodeRow;\n  let finishNodeCol;\n  if (numRows < numColumns) {\n    randomNums = getRandomNums(numRows);\n    x = Math.floor(numRows / 2);\n    y = Math.floor(numColumns / 4);\n    if (x % 2 !== 0) x -= 1;\n    if (y % 2 !== 0) y += 1;\n    startNodeRow =\n      x + randomNums[1][Math.floor(Math.random() * randomNums[1].length)];\n    startNodeCol = y + [-6, -4, -2, 0][Math.floor(Math.random() * 4)];\n    finishNodeRow =\n      x + randomNums[0][Math.floor(Math.random() * randomNums[0].length)];\n    finishNodeCol =\n      numColumns - y + [0, 2, 4, 6][Math.floor(Math.random() * 4)];\n  } else {\n    randomNums = getRandomNums(numColumns);\n    x = Math.floor(numRows / 4);\n    y = Math.floor(numColumns / 2);\n    if (x % 2 !== 0) x -= 1;\n    if (y % 2 !== 0) y += 1;\n    startNodeRow = x + [-6, -4, -2, 0][Math.floor(Math.random() * 4)];\n    startNodeCol =\n      y + randomNums[1][Math.floor(Math.random() * randomNums[1].length)];\n    finishNodeRow = numRows - x + [0, 2, 4, 6][Math.floor(Math.random() * 4)];\n    finishNodeCol =\n      y + randomNums[0][Math.floor(Math.random() * randomNums[0].length)];\n  }\n  return [startNodeRow, startNodeCol, finishNodeRow, finishNodeCol];\n}\n\nconst getInitialGrid = (numRows, numColumns) => {\n  let grid = [];\n  for (let row = 0; row < numRows; row++) {\n    let currentRow = [];\n    for (let col = 0; col < numColumns; col++) {\n      currentRow.push(createNode(row, col));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (row, col) => {\n  return {\n    row,\n    col,\n    isStart: row === startNodeRow && col === startNodeCol,\n    isFinish: row === finishNodeRow && col === finishNodeCol,\n    distance: Infinity,\n    totalDistance: Infinity,\n    isVisited: false,\n    isShortest: false,\n    isWall: false,\n    previousNode: null,\n  };\n};\n\nconst getNewGridWithWalls = (grid, row, col) => {\n  let newGrid = grid.slice();\n  let node = grid[row][col];\n  let newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst getNewGridWithMaze = (grid, walls) => {\n  let newGrid = grid.slice();\n  for (let wall of walls) {\n    let node = grid[wall[0]][wall[1]];\n    let newNode = {\n      ...node,\n      isWall: true,\n    };\n    newGrid[wall[0]][wall[1]] = newNode;\n  }\n  return newGrid;\n};\n\nconst getGridWithoutPath = (grid) => {\n  let newGrid = grid.slice();\n  for (let row of grid) {\n    for (let node of row) {\n      let newNode = {\n        ...node,\n        distance: Infinity,\n        totalDistance: Infinity,\n        isVisited: false,\n        isShortest: false,\n        previousNode: null,\n      };\n      newGrid[node.row][node.col] = newNode;\n    }\n  }\n  return newGrid;\n};\n\nconst updateNodesForRender = (\n  grid,\n  nodesInShortestPathOrder,\n  visitedNodesInOrder\n) => {\n  let newGrid = grid.slice();\n  for (let node of visitedNodesInOrder) {\n    if (\n      (node.row === startNodeRow && node.col === startNodeCol) ||\n      (node.row === finishNodeRow && node.col === finishNodeCol)\n    )\n      continue;\n    let newNode = {\n      ...node,\n      isVisited: true,\n    };\n    newGrid[node.row][node.col] = newNode;\n  }\n  for (let node of nodesInShortestPathOrder) {\n    if (node.row === finishNodeRow && node.col === finishNodeCol) {\n      return newGrid;\n    }\n    let newNode = {\n      ...node,\n      isVisited: false,\n      isShortest: true,\n    };\n    newGrid[node.row][node.col] = newNode;\n  }\n};\n\nconst getVisitedNodesInOrder = (\n  visitedNodesInOrderStart,\n  visitedNodesInOrderFinish\n) => {\n  let visitedNodesInOrder = [];\n  let n = Math.max(\n    visitedNodesInOrderStart.length,\n    visitedNodesInOrderFinish.length\n  );\n  for (let i = 0; i < n; i++) {\n    if (visitedNodesInOrderStart[i] !== undefined) {\n      visitedNodesInOrder.push(visitedNodesInOrderStart[i]);\n    }\n    if (visitedNodesInOrderFinish[i] !== undefined) {\n      visitedNodesInOrder.push(visitedNodesInOrderFinish[i]);\n    }\n  }\n  return visitedNodesInOrder;\n};\n\n\n\nexport default PathfindingVisualizer;\n\n\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport \"bootstrap/dist/css/bootstrap.css\";\nimport \"bootstrap/js/dist/dropdown\";\nimport PathfindingVisualizer from \"./pathfindingVisualizer/pathfindingVisualizer\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <PathfindingVisualizer />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\nserviceWorker.unregister();\n"],"sourceRoot":""}