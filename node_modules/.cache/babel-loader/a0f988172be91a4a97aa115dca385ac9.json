{"ast":null,"code":"let walls;\nexport function recursiveDivisionMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n\n  return result;\n} //dir === 0 => Horizontal\n//dir === 1 => Vertical\n\n\nfunction getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode) {\n  if (vertical.length < 2 || horizontal.length < 2) {\n    return;\n  }\n\n  let dir;\n  let num;\n\n  if (vertical.length > horizontal.length) {\n    dir = 0;\n    num = generateOddRandomNumber(vertical);\n  }\n\n  if (vertical.length <= horizontal.length) {\n    dir = 1;\n    num = generateOddRandomNumber(horizontal);\n  }\n\n  if (dir === 0) {\n    addWall(dir, num, vertical, horizontal, startNode, finishNode);\n    getRecursiveWalls(vertical.slice(0, vertical.indexOf(num)), horizontal, grid, startNode, finishNode);\n    getRecursiveWalls(vertical.slice(vertical.indexOf(num) + 1), horizontal, grid, startNode, finishNode);\n  } else {\n    addWall(dir, num, vertical, horizontal, startNode, finishNode);\n    getRecursiveWalls(vertical, horizontal.slice(0, horizontal.indexOf(num)), grid, startNode, finishNode);\n    getRecursiveWalls(vertical, horizontal.slice(horizontal.indexOf(num) + 1), grid, startNode, finishNode);\n  }\n}\n\nfunction generateOddRandomNumber(array) {\n  let max = array.length - 1;\n  let randomNum = Math.floor(Math.random() * (max / 2)) + Math.floor(Math.random() * (max / 2));\n\n  if (randomNum % 2 === 0) {\n    if (randomNum === max) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n\n  return array[randomNum];\n} //dir === 0 => Horizontal\n//dir === 1 => Vertical\n\n\nfunction addWall(dir, num, vertical, horizontal, startNode, finishNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n\n  if (dir === 0) {\n    if (horizontal.length === 2) return;\n\n    for (let temp of horizontal) {\n      if (temp === startNode.row && num === startNode.col || temp === finishNode.row && num === finishNode.col) {\n        isStartFinish = true;\n        continue;\n      }\n\n      tempWalls.push([temp, num]);\n    }\n  } else {\n    if (vertical.length === 2) return;\n\n    for (let temp of vertical) {\n      if (num === startNode.row && temp === startNode.col || num === finishNode.row && temp === finishNode.col) {\n        isStartFinish = true;\n        continue;\n      }\n\n      tempWalls.push([num, temp]);\n    }\n  }\n\n  if (!isStartFinish) {\n    tempWalls.splice(generateRandomNumber(tempWalls.length), 1);\n  }\n\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}\n\nfunction generateRandomNumber(max) {\n  let randomNum = Math.floor(Math.random() * (max / 2)) + Math.floor(Math.random() * (max / 2));\n\n  if (randomNum % 2 !== 0) {\n    if (randomNum === max) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n\n  return randomNum;\n}","map":{"version":3,"sources":["F:/Deerwalk/semester-5/Micro Project/pathfinding-visualizer/src/mazeAlgorithms/recursiveDivision.js"],"names":["walls","recursiveDivisionMaze","grid","startNode","finishNode","vertical","range","length","horizontal","getRecursiveWalls","len","result","i","push","dir","num","generateOddRandomNumber","addWall","slice","indexOf","array","max","randomNum","Math","floor","random","isStartFinish","tempWalls","temp","row","col","splice","generateRandomNumber","wall"],"mappings":"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","sourcesContent":["let walls;\nexport function recursiveDivisionMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n}\n\n//dir === 0 => Horizontal\n//dir === 1 => Vertical\n\nfunction getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode) {\n  if (vertical.length < 2 || horizontal.length < 2) {\n    return;\n  }\n  let dir;\n  let num;\n  if (vertical.length > horizontal.length) {\n    dir = 0;\n    num = generateOddRandomNumber(vertical);\n  }\n  if (vertical.length <= horizontal.length) {\n    dir = 1;\n    num = generateOddRandomNumber(horizontal);\n  }\n\n  if (dir === 0) {\n    addWall(dir, num, vertical, horizontal, startNode, finishNode);\n    getRecursiveWalls(\n      vertical.slice(0, vertical.indexOf(num)),\n      horizontal,\n      grid,\n      startNode,\n      finishNode\n    );\n    getRecursiveWalls(\n      vertical.slice(vertical.indexOf(num) + 1),\n      horizontal,\n      grid,\n      startNode,\n      finishNode\n    );\n  } else {\n    addWall(dir, num, vertical, horizontal, startNode, finishNode);\n    getRecursiveWalls(\n      vertical,\n      horizontal.slice(0, horizontal.indexOf(num)),\n      grid,\n      startNode,\n      finishNode\n    );\n    getRecursiveWalls(\n      vertical,\n      horizontal.slice(horizontal.indexOf(num) + 1),\n      grid,\n      startNode,\n      finishNode\n    );\n  }\n}\n\nfunction generateOddRandomNumber(array) {\n  let max = array.length - 1;\n  let randomNum =\n    Math.floor(Math.random() * (max / 2)) +\n    Math.floor(Math.random() * (max / 2));\n  if (randomNum % 2 === 0) {\n    if (randomNum === max) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n  return array[randomNum];\n}\n\n//dir === 0 => Horizontal\n//dir === 1 => Vertical\n\nfunction addWall(dir, num, vertical, horizontal, startNode, finishNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  if (dir === 0) {\n    if (horizontal.length === 2) return;\n    for (let temp of horizontal) {\n      if (\n        (temp === startNode.row && num === startNode.col) ||\n        (temp === finishNode.row && num === finishNode.col)\n      ) {\n        isStartFinish = true;\n        continue;\n      }\n      tempWalls.push([temp, num]);\n    }\n  } else {\n    if (vertical.length === 2) return;\n    for (let temp of vertical) {\n      if (\n        (num === startNode.row && temp === startNode.col) ||\n        (num === finishNode.row && temp === finishNode.col)\n      ) {\n        isStartFinish = true;\n        continue;\n      }\n      tempWalls.push([num, temp]);\n    }\n  }\n  if (!isStartFinish) {\n    tempWalls.splice(generateRandomNumber(tempWalls.length), 1);\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}\n\nfunction generateRandomNumber(max) {\n  let randomNum =\n    Math.floor(Math.random() * (max / 2)) +\n    Math.floor(Math.random() * (max / 2));\n  if (randomNum % 2 !== 0) {\n    if (randomNum === max) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n  return randomNum;\n}\n"]},"metadata":{},"sourceType":"module"}