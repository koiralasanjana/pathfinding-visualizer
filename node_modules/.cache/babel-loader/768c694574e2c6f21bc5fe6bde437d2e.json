{"ast":null,"code":"import _createForOfIteratorHelper from\"F:\\\\Deerwalk\\\\semester-5\\\\Micro Project\\\\pathfinding-visualizer\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";var walls;export function recursiveDivisionMaze(grid,startNode,finishNode){if(!startNode||!finishNode||startNode===finishNode){return false;}var vertical=range(grid[0].length);var horizontal=range(grid.length);walls=[];getRecursiveWalls(vertical,horizontal,grid,startNode,finishNode);return walls;}function range(len){var result=[];for(var i=0;i<len;i++){result.push(i);}return result;}//dir === 0 => Horizontal\n//dir === 1 => Vertical\nfunction getRecursiveWalls(vertical,horizontal,grid,startNode,finishNode){if(vertical.length<2||horizontal.length<2){return;}var dir;var num;if(vertical.length>horizontal.length){dir=0;num=generateOddRandomNumber(vertical);}if(vertical.length<=horizontal.length){dir=1;num=generateOddRandomNumber(horizontal);}if(dir===0){addWall(dir,num,vertical,horizontal,startNode,finishNode);getRecursiveWalls(vertical.slice(0,vertical.indexOf(num)),horizontal,grid,startNode,finishNode);getRecursiveWalls(vertical.slice(vertical.indexOf(num)+1),horizontal,grid,startNode,finishNode);}else{addWall(dir,num,vertical,horizontal,startNode,finishNode);getRecursiveWalls(vertical,horizontal.slice(0,horizontal.indexOf(num)),grid,startNode,finishNode);getRecursiveWalls(vertical,horizontal.slice(horizontal.indexOf(num)+1),grid,startNode,finishNode);}}function generateOddRandomNumber(array){var max=array.length-1;var randomNum=Math.floor(Math.random()*(max/2))+Math.floor(Math.random()*(max/2));if(randomNum%2===0){if(randomNum===max){randomNum-=1;}else{randomNum+=1;}}return array[randomNum];}//dir === 0 => Horizontal\n//dir === 1 => Vertical\nfunction addWall(dir,num,vertical,horizontal,startNode,finishNode){var isStartFinish=false;var tempWalls=[];if(dir===0){if(horizontal.length===2)return;var _iterator=_createForOfIteratorHelper(horizontal),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var temp=_step.value;if(temp===startNode.row&&num===startNode.col||temp===finishNode.row&&num===finishNode.col){isStartFinish=true;continue;}tempWalls.push([temp,num]);}}catch(err){_iterator.e(err);}finally{_iterator.f();}}else{if(vertical.length===2)return;var _iterator2=_createForOfIteratorHelper(vertical),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var _temp=_step2.value;if(num===startNode.row&&_temp===startNode.col||num===finishNode.row&&_temp===finishNode.col){isStartFinish=true;continue;}tempWalls.push([num,_temp]);}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}}if(!isStartFinish){tempWalls.splice(generateRandomNumber(tempWalls.length),1);}for(var _i=0,_tempWalls=tempWalls;_i<_tempWalls.length;_i++){var wall=_tempWalls[_i];walls.push(wall);}}function generateRandomNumber(max){var randomNum=Math.floor(Math.random()*(max/2))+Math.floor(Math.random()*(max/2));if(randomNum%2!==0){if(randomNum===max){randomNum-=1;}else{randomNum+=1;}}return randomNum;}","map":{"version":3,"sources":["F:/Deerwalk/semester-5/Micro Project/pathfinding-visualizer/src/mazeAlgorithms/recursiveDivision.js"],"names":["walls","recursiveDivisionMaze","grid","startNode","finishNode","vertical","range","length","horizontal","getRecursiveWalls","len","result","i","push","dir","num","generateOddRandomNumber","addWall","slice","indexOf","array","max","randomNum","Math","floor","random","isStartFinish","tempWalls","temp","row","col","splice","generateRandomNumber","wall"],"mappings":"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","sourcesContent":["let walls;\nexport function recursiveDivisionMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n}\n\n//dir === 0 => Horizontal\n//dir === 1 => Vertical\n\nfunction getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode) {\n  if (vertical.length < 2 || horizontal.length < 2) {\n    return;\n  }\n  let dir;\n  let num;\n  if (vertical.length > horizontal.length) {\n    dir = 0;\n    num = generateOddRandomNumber(vertical);\n  }\n  if (vertical.length <= horizontal.length) {\n    dir = 1;\n    num = generateOddRandomNumber(horizontal);\n  }\n\n  if (dir === 0) {\n    addWall(dir, num, vertical, horizontal, startNode, finishNode);\n    getRecursiveWalls(\n      vertical.slice(0, vertical.indexOf(num)),\n      horizontal,\n      grid,\n      startNode,\n      finishNode\n    );\n    getRecursiveWalls(\n      vertical.slice(vertical.indexOf(num) + 1),\n      horizontal,\n      grid,\n      startNode,\n      finishNode\n    );\n  } else {\n    addWall(dir, num, vertical, horizontal, startNode, finishNode);\n    getRecursiveWalls(\n      vertical,\n      horizontal.slice(0, horizontal.indexOf(num)),\n      grid,\n      startNode,\n      finishNode\n    );\n    getRecursiveWalls(\n      vertical,\n      horizontal.slice(horizontal.indexOf(num) + 1),\n      grid,\n      startNode,\n      finishNode\n    );\n  }\n}\n\nfunction generateOddRandomNumber(array) {\n  let max = array.length - 1;\n  let randomNum =\n    Math.floor(Math.random() * (max / 2)) +\n    Math.floor(Math.random() * (max / 2));\n  if (randomNum % 2 === 0) {\n    if (randomNum === max) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n  return array[randomNum];\n}\n\n//dir === 0 => Horizontal\n//dir === 1 => Vertical\n\nfunction addWall(dir, num, vertical, horizontal, startNode, finishNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  if (dir === 0) {\n    if (horizontal.length === 2) return;\n    for (let temp of horizontal) {\n      if (\n        (temp === startNode.row && num === startNode.col) ||\n        (temp === finishNode.row && num === finishNode.col)\n      ) {\n        isStartFinish = true;\n        continue;\n      }\n      tempWalls.push([temp, num]);\n    }\n  } else {\n    if (vertical.length === 2) return;\n    for (let temp of vertical) {\n      if (\n        (num === startNode.row && temp === startNode.col) ||\n        (num === finishNode.row && temp === finishNode.col)\n      ) {\n        isStartFinish = true;\n        continue;\n      }\n      tempWalls.push([num, temp]);\n    }\n  }\n  if (!isStartFinish) {\n    tempWalls.splice(generateRandomNumber(tempWalls.length), 1);\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}\n\nfunction generateRandomNumber(max) {\n  let randomNum =\n    Math.floor(Math.random() * (max / 2)) +\n    Math.floor(Math.random() * (max / 2));\n  if (randomNum % 2 !== 0) {\n    if (randomNum === max) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n  return randomNum;\n}\n"]},"metadata":{},"sourceType":"module"}