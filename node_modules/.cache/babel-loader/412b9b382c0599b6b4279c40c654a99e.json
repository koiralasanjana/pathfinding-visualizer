{"ast":null,"code":"// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n  setAllDistanceToInfinity(grid);\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n\n  while (unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes); //after sorting closest node can be any of the four/three/two/one options as we are updating all the neighbors(of a node) distance by +1.\n    //\n\n    const closestNode = unvisitedNodes.shift(); //if we encounter a wall we don't do anything\n\n    if (closestNode.isWall) continue; //if distance of closest node is infinity\n    //we must be trapped and should stop\n\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\nfunction setAllDistanceToInfinity(grid) {\n  for (const row of grid) {\n    for (const node of row) {\n      node.distance = Infinity;\n      node.isVisited = false;\n      node.previousNode = null;\n    }\n  }\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n\n  for (let neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const {\n    row,\n    col\n  } = node; //to check closestNode is not in the first row ( we are selecting the top element){so if row is 0 for node we are checking neighbors of, there is nothing on top of it, i.e why row must be greater than 0, similar goes for the rest three sides}\n\n  if (row > 0) neighbors.push(grid[row - 1][col]); //to check if startNode is not in the last row(we are selecting the below element)\n\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]); //to check if startNode is not in far left(first column),(we are selecting left of closestNode)\n\n  if (col > 0) neighbors.push(grid[row][col - 1]); //to check if the element is not in the far right, in the last col(we are selecting the right side neighbor)\n\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]); //  // if (col < grid.length - 1) neighbors.push(grid[row][col + 1]); -- this will compare the\n  //col value with grid.length which is total row value, we want to check with col value\n  //then filter among them whichever is unvisited\n  //so unvisitedNeighbors in getUnvisitedNeighbors function will not always get 4 neighbors\n  //like in second iteration of while loop we will get 3 neighbor nodes whether we select any four\n  // from the first as the closestNode was already visited\n  //filter takes in a function and returns array which passes the constraints of that function\n\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n\n  return nodes;\n} // Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\n\n\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode; //current node will be null it is equal to startNode\n\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return nodesInShortestPathOrder;\n}","map":{"version":3,"sources":["F:/Deerwalk/semester-5/Micro Project/my-project/pathfinding-visualizer-master/src/algorithms/dijkstra.js"],"names":["dijkstra","grid","startNode","finishNode","setAllDistanceToInfinity","visitedNodesInOrder","distance","unvisitedNodes","getAllNodes","length","sortNodesByDistance","closestNode","shift","isWall","Infinity","isVisited","push","updateUnvisitedNeighbors","row","node","previousNode","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","neighbors","col","filter","sort","nodeA","nodeB","nodes","getNodesInShortestPathOrder","nodesInShortestPathOrder","currentNode","unshift"],"mappings":"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","sourcesContent":["// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\n\nexport function dijkstra(grid, startNode, finishNode) {\n  setAllDistanceToInfinity(grid);\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    //after sorting closest node can be any of the four/three/two/one options as we are updating all the neighbors(of a node) distance by +1.\n    //\n    const closestNode = unvisitedNodes.shift();\n    //if we encounter a wall we don't do anything\n    if (closestNode.isWall) continue;\n    //if distance of closest node is infinity\n    //we must be trapped and should stop\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\nfunction setAllDistanceToInfinity(grid) {\n  for (const row of grid) {\n    for (const node of row) {\n      node.distance = Infinity;\n      node.isVisited = false;\n      node.previousNode = null;\n    }\n  }\n}\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (let neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { row, col } = node;\n  //to check closestNode is not in the first row ( we are selecting the top element){so if row is 0 for node we are checking neighbors of, there is nothing on top of it, i.e why row must be greater than 0, similar goes for the rest three sides}\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  //to check if startNode is not in the last row(we are selecting the below element)\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  //to check if startNode is not in far left(first column),(we are selecting left of closestNode)\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  //to check if the element is not in the far right, in the last col(we are selecting the right side neighbor)\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  //  // if (col < grid.length - 1) neighbors.push(grid[row][col + 1]); -- this will compare the\n  //col value with grid.length which is total row value, we want to check with col value\n\n  //then filter among them whichever is unvisited\n  //so unvisitedNeighbors in getUnvisitedNeighbors function will not always get 4 neighbors\n  //like in second iteration of while loop we will get 3 neighbor nodes whether we select any four\n  // from the first as the closestNode was already visited\n  //filter takes in a function and returns array which passes the constraints of that function\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  //current node will be null it is equal to startNode\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n"]},"metadata":{},"sourceType":"module"}