{"ast":null,"code":"var _jsxFileName = \"F:\\\\Deerwalk\\\\semester-5\\\\Micro Project\\\\my-project\\\\pathfinding-visualizer-master\\\\src\\\\App.js\";\nimport React, { Component } from \"react\";\nimport { Route, NavLink, // BrowserRouter as Router,\nHashRouter as Router, Switch } from \"react-router-dom\";\nimport Demo from \"./animations/Demo\";\nimport PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer\";\nimport NavBar from \"./PathfindingVisualizer/NavBar\";\nimport \"./App.css\";\nimport { dijkstra, getNodesInShortestPathOrder } from \"./algorithms/dijkstra\"; // import { astar, getNodesInShortestPathOrderAstar } from \"./algorithms/astar\";\n// import { astar, getNodesInShortestPathOrderAstar } from \"./algorithms/newAstar\";\n\nimport { astar, getNodesInShortestPathOrderAstar } from \"./algorithms/astar1\";\nimport { recursiveDivision } from \"./mazeAlgorithms/recursiveDivision\";\nimport { staircaseMaze } from \"./mazeAlgorithms/staircaseMaze\";\nimport { mazeThree } from \"./mazeAlgorithms/maze3\";\nimport { mazeFour } from \"./mazeAlgorithms/maze4\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nlet centerText = \"Click and drag mouse on the grid to draw obstacles(or select from different mazes), then click on the algorithm to find the shortest path ;) (try adding a bomb also...)\";\nlet NUMBER_OF_ROWS = 22,\n    NUMBER_OF_COLS = 56;\nlet START_NODE_ROW = 10,\n    START_NODE_COL = 10,\n    FINISH_NODE_ROW = 10,\n    FINISH_NODE_COL = 40,\n    BOMB_NODE_ROW = 18,\n    BOMB_NODE_COL = 25;\nlet startNode = {\n  row: START_NODE_ROW,\n  col: START_NODE_COL\n};\nlet finishNode = {\n  row: FINISH_NODE_ROW,\n  col: FINISH_NODE_COL\n};\nlet bombNode = {\n  row: BOMB_NODE_ROW,\n  col: BOMB_NODE_COL,\n  status: false\n};\nlet draggingStart = false,\n    draggingFinish = false,\n    draggingBomb = false;\nexport class App extends Component {\n  constructor() {\n    super(...arguments);\n    this.state = {\n      grid: [],\n      mouseIsPressed: false\n    };\n\n    this.handleMouseDown = (row, col) => {\n      this.clearPath();\n      const node = {\n        row: row,\n        col: col\n      };\n\n      if (node.row === startNode.row && node.col === startNode.col) {\n        const newGrid = this.getNewGridWithStartNodeToggled(this.state.grid, row, col); // we don't want to create walls when we are dragging the start/finish node\n        //mouseIsPressed is set to false so that onMouseEnter doesn't trigger\n\n        this.setState({\n          grid: newGrid,\n          mouseIsPressed: false\n        });\n        draggingStart = true;\n      } else if (node.row === finishNode.row && node.col === finishNode.col) {\n        const newGrid = this.getNewGridWithFinishNodeToggled(this.state.grid, row, col);\n        this.setState({\n          grid: newGrid,\n          mouseIsPressed: false\n        });\n        draggingFinish = true;\n      } else if (node.row === bombNode.row && node.col === bombNode.col && bombNode.status //checking with status so it triggers only when addBomb is clicked else it will create a wall on that node\n      ) {\n        const newGrid = this.getNewGridWithBombNodeToggled(this.state.grid, row, col);\n        this.setState({\n          grid: newGrid,\n          mouseIsPressed: false\n        });\n        draggingBomb = true;\n      } else {\n        const newGrid = this.getNewGridWithWallToggled(this.state.grid, row, col);\n        this.setState({\n          grid: newGrid,\n          mouseIsPressed: true\n        });\n      }\n    };\n\n    this.handleMouseEnter = (row, col) => {\n      if (!this.state.mouseIsPressed) return; //below if statement to prevent dragging and forming wall node over the bomb node(mouseIsPressed set to false not working here)\n      //remove this if condition with only bombNode condition if problem persists\n\n      if (!(row === bombNode.row && col === bombNode.col || row === startNode.row && col === startNode.col || row === finishNode.row && col === finishNode.col)) {\n        const newGrid = this.getNewGridWithWallToggled(this.state.grid, row, col);\n        this.setState({\n          grid: newGrid\n        });\n      }\n    };\n\n    this.handleMouseUp = (row, col) => {\n      if (draggingStart) {\n        const newGrid = this.getNewGridWithStartNodeToggled(this.state.grid, row, col);\n        this.setState({\n          grid: newGrid\n        });\n      } else if (draggingFinish) {\n        const newGrid = this.getNewGridWithFinishNodeToggled(this.state.grid, row, col);\n        this.setState({\n          grid: newGrid\n        });\n      } else if (draggingBomb) {\n        const newGrid = this.getNewGridWithBombNodeToggled(this.state.grid, row, col);\n        this.setState({\n          grid: newGrid\n        });\n      }\n\n      this.setState({\n        mouseIsPressed: false\n      }); //resetting the dragging start/finish when mouse is lifted up\n\n      draggingStart = false;\n      draggingFinish = false;\n      draggingBomb = false;\n    };\n\n    this.getNewGridWithBombNodeToggled = (grid, row, col) => {\n      bombNode.row = row;\n      bombNode.col = col;\n      const newGrid = grid.slice();\n      const node = newGrid[row][col];\n      const newNode = { ...node,\n        isBomb: !node.isBomb,\n        isWall: false\n      };\n      const element = document.getElementById(`node-${bombNode.row}-${bombNode.col}`);\n      element.classList.remove(\"node-bomb\");\n      newGrid[row][col] = newNode; //adding className to new node (was working fine without this also), check it later\n      // const newElement = document.getElementById(\n      //   `node-${bombNode.row}-${bombNode.col}`\n      // );\n      // newElement.className = \"node node-bomb\";\n\n      return newGrid;\n    };\n\n    this.getNewGridWithStartNodeToggled = (grid, row, col) => {\n      const newGrid = grid.slice();\n      const node = newGrid[row][col];\n      startNode.row = row;\n      startNode.col = col;\n      const newNode = { ...node,\n        isStart: !node.isStart,\n        //maybe due to mouse click problem wall is set to true and we are not getting anything\n        //in the visitedNodesInOrder from the dijkstra\n        // *isWall is set to false also bcoz, in case we put walls first and then move the start/finish node on that wall\n        isWall: false // distance: Infinity\n        //distance setting to infinity not working, alternative is clearPath function\n\n      };\n      newGrid[row][col] = newNode;\n      return newGrid;\n    };\n\n    this.getNewGridWithFinishNodeToggled = (grid, row, col) => {\n      const newGrid = grid.slice();\n      finishNode.row = row;\n      finishNode.col = col;\n      const node = newGrid[row][col];\n      const newNode = { ...node,\n        isFinish: !node.isFinish,\n        isWall: false\n      };\n      newGrid[row][col] = newNode;\n      return newGrid;\n    };\n\n    this.getNewGridWithWallToggled = (grid, row, col) => {\n      // if (row !== bombNode.row && col !== bombNode.col) {\n      const newGrid = grid.slice();\n      const node = newGrid[row][col];\n      const newNode = { ...node,\n        isWall: !node.isWall\n      };\n      newGrid[row][col] = newNode;\n      return newGrid;\n    };\n\n    this.getInitialGrid = () => {\n      let grid = [];\n\n      for (let row = 0; row < NUMBER_OF_ROWS; row++) {\n        let currentRow = [];\n\n        for (let col = 0; col < NUMBER_OF_COLS; col++) {\n          currentRow.push(this.createNode(col, row));\n        }\n\n        grid.push(currentRow);\n      }\n\n      return grid;\n    };\n\n    this.createNode = (col, row) => {\n      return {\n        isVisited: false,\n        col,\n        row,\n        isStart: row === START_NODE_ROW && col === START_NODE_COL,\n        isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n        distance: Infinity,\n        isWall: false,\n        previousNode: null,\n        isBomb: false\n      };\n    };\n\n    this.animateDijsktra = (visitedNodesInOrder, nodesInShortestPathOrder, bomb, nodesInShortestPathOrderWithBomb) => {\n      for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n        if (i === visitedNodesInOrder.length) {\n          setTimeout(() => {\n            if (!bomb) {\n              //no bomb\n              this.animateShortestPath(nodesInShortestPathOrder);\n            } else {\n              //bomb is present\n              this.animateShortestPath(nodesInShortestPathOrderWithBomb); // return;\n            }\n          }, 10 * i);\n          return;\n        }\n\n        setTimeout(() => {\n          const node = visitedNodesInOrder[i]; //if statement to avoid coloring of start and finish node\n\n          if (!(node.isStart || node.isFinish || node.isBomb)) {\n            document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-visited\";\n          }\n        }, 10 * i);\n      }\n    };\n\n    this.removeArrowClass = () => {\n      const {\n        grid\n      } = this.state;\n\n      for (const row of grid) {\n        for (const node of row) {\n          const element = document.getElementById(`node-${node.row}-${node.col}`);\n          element.classList.remove(\"node-right-arrow\");\n          element.classList.remove(\"node-left-arrow\");\n          element.classList.remove(\"node-up-arrow\");\n          element.classList.remove(\"node-down-arrow\");\n        }\n      }\n    };\n\n    this.determineImage = (currentNode, previousNode) => {\n      const element = document.getElementById(`node-${currentNode.row}-${currentNode.col}`);\n\n      if (currentNode.col > previousNode.col) {\n        //moving right\n        element.className = \"node node-shortest-path node-right-arrow\";\n      } else if (currentNode.row < previousNode.row) {\n        //moving up\n        element.className = \"node node-shortest-path node-up-arrow\";\n      } else if (currentNode.col < previousNode.col) {\n        // moving left\n        element.className = \"node node-shortest-path node-left-arrow\";\n      } else if (currentNode.row > previousNode.row) {\n        //moving down\n        element.className = \"node node-shortest-path node-down-arrow\";\n      }\n    };\n\n    this.arrowForSecondLastNode = (node, previousNode) => {\n      //two if conditions to escape the bug when no path to bombNode is found\n      if (previousNode === undefined) return;\n      if (node === undefined) return;\n      const element = document.getElementById(`node-${previousNode.row}-${previousNode.col}`);\n\n      if (node.col > previousNode.col) {\n        //finish node is right\n        element.className = \"node node-shortest-path node-right-arrow\";\n      } else if (node.row > previousNode.row) {\n        //finish node is below\n        element.className = \"node node-shortest-path node-down-arrow\";\n      } else if (node.row < previousNode.row) {\n        //finish node is above\n        element.className = \"node node-shortest-path node-up-arrow\";\n      } else if (node.col < previousNode.col) {\n        //finish node is left\n        element.className = \"node node-shortest-path node-left-arrow\";\n      }\n    };\n\n    this.animateShortestPath = nodesInShortestPathOrder => {\n      for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n        setTimeout(() => {\n          const node = nodesInShortestPathOrder[i];\n          const previousNode = nodesInShortestPathOrder[i - 1];\n\n          if (!(node.isStart || node.isFinish || node.isBomb)) {\n            document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-shortest-path\"; //setting the arrow image\n\n            this.determineImage(node, previousNode); //first we are setting the image of the current travelling node and then removing the previous one's image(if set) simultaneously to make it look like a moving arrow\n            //resetting the arrow image of previous node (so that it looks like a travelling arrow)\n\n            if (!(previousNode.isStart || previousNode.isFinish || previousNode.isBomb)) {\n              document.getElementById(`node-${previousNode.row}-${previousNode.col}`).style.backgroundImage = \"none\";\n            }\n          } //this if block is for direction arrow of node just before finish node\n\n\n          if (node.isBomb) {\n            // this.determineImage(node, previousNode);\n            this.arrowForSecondLastNode(node, previousNode);\n          } //this if block is for direction arrow of node just before finish node\n\n\n          if (node.isFinish) {\n            // this.determineImage(node, previousNode);\n            this.arrowForSecondLastNode(node, previousNode);\n          }\n\n          if (i === nodesInShortestPathOrder.length - 1) {\n            this.reEnableButtons();\n            this.enableGrid();\n          }\n        }, 50 * i);\n      }\n    };\n\n    this.animateDijsktraWithBomb = (newVisitedNodesInOrder, newNodesInShortestPathOrder0, newStart, newFinish) => {\n      for (let i = 0; i <= newVisitedNodesInOrder.length; i++) {\n        if (i === newVisitedNodesInOrder.length) {\n          setTimeout(() => {\n            const {\n              grid\n            } = this.state;\n            const visitedNodesInOrder = dijkstra(grid, newStart, newFinish);\n            const nodesInShortestPathOrder1 = getNodesInShortestPathOrder(newFinish);\n            const nodesInShortestPathOrder = [...newNodesInShortestPathOrder0, ...nodesInShortestPathOrder1];\n            this.animateDijsktra(visitedNodesInOrder, nodesInShortestPathOrder1, true, nodesInShortestPathOrder);\n          }, 10 * i);\n          return;\n        }\n\n        setTimeout(() => {\n          const node = newVisitedNodesInOrder[i]; //if statement to avoid coloring of start and finish node\n\n          if (!(node.isStart || node.isFinish || node.isBomb)) {\n            document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-bomb-visited\";\n          }\n        }, 10 * i);\n      }\n    };\n\n    this.visualizeDijkstra = () => {\n      centerText = \"Dijkstra’s algorithm finds a shortest path tree from a single source node, by building a set of nodes that have minimum distance from the source. Dijkstra's algorithm guarantees shortest path.\"; //just to make sure that when visualize dijkstra button is clicked path is cleared so that in case we move the start Node without clearing the board algorithm starts from a new startPoint\n      //*if we don't clearPath dijkstra algorithm will start from the node whose distance is minimum and in the algorithms we have set the distance of startNode as 0(initially), so when we don't call clearPath function(in which we reset all the distance back to Infinity), and move the startNode to a new Point,visualization starts from the previous node only.\n\n      this.clearPath();\n      this.disableButtons();\n      this.disableGrid();\n      const {\n        grid\n      } = this.state;\n      let bombIsPresent = false;\n\n      if (bombNode.status) {\n        bombIsPresent = true;\n      }\n\n      const finish = grid[finishNode.row][finishNode.col];\n\n      if (!bombIsPresent) {\n        const start = grid[startNode.row][startNode.col];\n        const visitedNodesInOrder = dijkstra(grid, start, finish);\n        const nodesInShortestPathOrder = getNodesInShortestPathOrder(finish);\n        this.animateDijsktra(visitedNodesInOrder, nodesInShortestPathOrder, false, null);\n      } else {\n        const bombNode1 = grid[bombNode.row][bombNode.col];\n        const start = grid[startNode.row][startNode.col];\n        const visitedNodesInOrder = dijkstra(grid, start, bombNode1);\n        const nodesInShortestPathOrder = getNodesInShortestPathOrder(bombNode1);\n        this.animateDijsktraWithBomb(visitedNodesInOrder, nodesInShortestPathOrder, bombNode1, finish);\n      }\n    };\n\n    this.clearBoard = () => {\n      this.removeArrowClass();\n      this.removeBomb();\n      const {\n        grid\n      } = this.state;\n      const newGrid = grid.slice();\n\n      for (let i = 0; i < newGrid.length; i++) {\n        for (let j = 0; j < newGrid[i].length; j++) {\n          const element = document.getElementById(`node-${i}-${j}`);\n          element.classList.remove(\"node-visited\");\n          element.classList.remove(\"node-shortest-path\");\n          element.classList.remove(\"node-bomb-visited\"); //clearing class node-wall is optional(working fine otherwise also)\n\n          element.classList.remove(\"node-wall\");\n          newGrid[i][j].isVisited = false;\n          newGrid[i][j].distance = Infinity;\n          newGrid[i][j].isWall = false;\n          newGrid[i][j].previousNode = null;\n        }\n      }\n\n      this.setState({\n        grid: newGrid\n      });\n    };\n\n    this.clearPath = () => {\n      this.removeArrowClass();\n      const {\n        grid\n      } = this.state;\n      const newGrid = grid.slice(); // console.log(newGrid[startNode.row][startNode.col]);\n\n      for (let i = 0; i < newGrid.length; i++) {\n        for (let j = 0; j < newGrid[i].length; j++) {\n          // console.log(newGrid[i][j]);\n          const element = document.getElementById(`node-${i}-${j}`);\n          element.classList.remove(\"node-visited\");\n          element.classList.remove(\"node-shortest-path\");\n          element.classList.remove(\"node-bomb-visited\");\n          newGrid[i][j].isVisited = false;\n          newGrid[i][j].distance = Infinity;\n          newGrid[i][j].previousNode = null;\n        }\n      }\n\n      this.setState({\n        grid: newGrid\n      });\n    };\n\n    this.animateAstar = (visitedNodesInOrder, nodesInShortestPathOrder, bomb, nodesInShortestPathOrderWithBomb) => {\n      for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n        if (i === visitedNodesInOrder.length) {\n          setTimeout(() => {\n            if (!bomb) {\n              //no bomb\n              this.animateShortestPath(nodesInShortestPathOrder);\n            } else {\n              this.animateShortestPath(nodesInShortestPathOrderWithBomb);\n            }\n          }, 10 * i);\n          return;\n        }\n\n        setTimeout(() => {\n          const node = visitedNodesInOrder[i]; //if statement to avoid coloring of start and finish node\n\n          if (!(node.isStart || node.isFinish || node.isBomb)) {\n            document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-visited\";\n          }\n        }, 10 * i);\n      }\n    };\n\n    this.animateAstarWithBomb = (newVisitedNodesInOrder, newNodesInShortestPathOrder0, newStart, newFinish) => {\n      for (let i = 0; i <= newVisitedNodesInOrder.length; i++) {\n        if (i === newVisitedNodesInOrder.length) {\n          setTimeout(() => {\n            const {\n              grid\n            } = this.state;\n            const visitedNodesInOrder = astar(grid, newStart, newFinish);\n            const nodesInShortestPathOrder1 = getNodesInShortestPathOrderAstar(newFinish);\n            const nodesInShortestPathOrder = [...newNodesInShortestPathOrder0, ...nodesInShortestPathOrder1];\n            this.animateAstar(visitedNodesInOrder, nodesInShortestPathOrder1, true, nodesInShortestPathOrder);\n          }, 10 * i);\n          return;\n        }\n\n        setTimeout(() => {\n          const node = newVisitedNodesInOrder[i]; //if statement to avoid coloring of start and finish node\n\n          if (!(node.isStart || node.isFinish || node.isBomb)) {\n            document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-bomb-visited\";\n          }\n        }, 10 * i);\n      }\n    };\n\n    this.visualizeAstar = () => {\n      //disabling all buttons while visualization\n      centerText = \"A* algorithm calculates heuristic distance(distance from the end node) which guides it towards the target node faster. A* algorithm guarantees shortest path..\";\n      this.disableButtons();\n      this.disableGrid();\n      this.clearPath();\n      const {\n        grid\n      } = this.state;\n      let bombIsPresent = false;\n\n      if (bombNode.status) {\n        bombIsPresent = true;\n      }\n\n      const start = grid[startNode.row][startNode.col];\n      const finish = grid[finishNode.row][finishNode.col];\n\n      if (!bombIsPresent) {\n        const visitedNodesInOrder = astar(grid, start, finish);\n        const nodesInShortestPathOrder = getNodesInShortestPathOrderAstar(finish);\n        this.animateAstar(visitedNodesInOrder, nodesInShortestPathOrder, false, null);\n      } else {\n        const bombNode1 = grid[bombNode.row][bombNode.col];\n        const visitedNodesInOrder = astar(grid, start, bombNode1);\n        const nodesInShortestPathOrder = getNodesInShortestPathOrderAstar(bombNode1);\n        this.animateAstarWithBomb(visitedNodesInOrder, nodesInShortestPathOrder, bombNode1, finish);\n      }\n    };\n\n    this.addBomb = () => {\n      this.clearPath();\n      centerText = \"When bomb is active the algorithm will first try to find the shortest path to bomb to deactivate it and then will reach the finish node ..\";\n      const {\n        grid\n      } = this.state;\n\n      for (const row of grid) {\n        for (const node of row) {\n          if (node.row === bombNode.row && node.col === bombNode.col) {\n            node.isWall = false;\n            node.isBomb = true;\n          } else {// node.bombNode = false;\n            // continue;\n          }\n        }\n      }\n\n      bombNode.status = true;\n      document.getElementById(`node-${bombNode.row}-${bombNode.col}`).className = \"node node-bomb\";\n      this.setState({\n        grid\n      });\n      document.getElementById(\"add-bomb-button\").disabled = true;\n    };\n\n    this.removeBomb = () => {\n      this.clearPath();\n      document.getElementById(\"add-bomb-button\").disabled = false;\n      centerText = \"Click and drag mouse on the grid to draw obstacles(or select from different mazes), then click on the algorithm to find the shortest path ;) (try adding a bomb also...)\"; // bomb = false;\n\n      const {\n        grid\n      } = this.state;\n      const element = document.getElementById(`node-${bombNode.row}-${bombNode.col}`);\n      element.classList.remove(\"node-bomb\");\n\n      for (const row of grid) {\n        for (const node of row) {\n          node.isBomb = false;\n        }\n      }\n\n      bombNode.status = false;\n      this.setState({\n        grid\n      });\n    };\n\n    this.genRandomNumber = () => {\n      return Math.floor(Math.random() * (NUMBER_OF_COLS * NUMBER_OF_ROWS));\n    };\n\n    this.resetNodeWalls = () => {\n      const {\n        grid\n      } = this.state;\n      const newGrid = grid.slice();\n\n      for (const row of newGrid) {\n        for (const node of row) {\n          node.isWall = false;\n        }\n      }\n\n      this.setState({\n        grid: newGrid\n      });\n    };\n\n    this.genRandomWalls = () => {\n      this.clearPath();\n      this.resetNodeWalls();\n      const {\n        grid\n      } = this.state;\n      const newGrid = grid.slice();\n      let nodes = [];\n\n      for (const row of grid) {\n        for (const node of row) {\n          if (!(node.row === bombNode.row && node.col === bombNode.col || node.row === startNode.row && node.col === startNode.col || node.row === finishNode.row && node.col === finishNode.col)) {\n            nodes.push(node);\n          }\n        }\n      }\n\n      let numberOfPlainNodes = nodes.length;\n      let x = Math.floor(40 / 100 * numberOfPlainNodes),\n          random = this.genRandomNumber(); //some kind of error with genRandomWall function, to ignore it following two if statements are there, check later if problem persists \"cannot read property nodes[random].isWall of unknown\"\n\n      while (x) {\n        if (nodes[random] === undefined) return;\n        if (nodes[random].isWall === undefined) return;\n        nodes[random].isWall = !nodes[random].isWall;\n        x -= 1;\n        random = this.genRandomNumber();\n      }\n\n      this.setState({\n        grid: newGrid\n      });\n    };\n\n    this.visualizeRecursiveDivision = () => {\n      this.clearBoard();\n      this.disableButtons();\n      this.disableGrid();\n      const {\n        grid\n      } = this.state;\n      const nodes = recursiveDivision(grid, NUMBER_OF_ROWS, NUMBER_OF_COLS);\n\n      for (let k = 0; k < nodes.length; k++) {\n        //our nodes array will always more likely be greater than the actual number of nodes on the grid (as the way we are filling the array (setting the pattern number of time,see while loop in corresponding maze algorithm), and then pruning our nodes array till it reaches undefined i.e to the size of the number of nodes in the grid)\n        if (nodes[k] === undefined) {\n          return;\n        }\n\n        setTimeout(() => {\n          if (!(nodes[k].isStart || nodes[k].isFinish || nodes[k].isBomb)) {\n            nodes[k].isWall = true;\n            const element = document.getElementById(`node-${nodes[k].row}-${nodes[k].col}`);\n            element.className = \"node node-wall\";\n          } //we would'nt have reached nodes[k]===undefined as we are returning from that point so we are checking in advance (also so that disabling persists while walls are being drawn)\n\n\n          if (nodes[k + 1] === undefined) {\n            this.reEnableButtons();\n            this.enableGrid();\n          }\n        }, k * 10);\n      }\n    };\n\n    this.visualizeStaircase = () => {\n      this.clearBoard();\n      this.disableButtons();\n      this.disableGrid();\n      const {\n        grid\n      } = this.state;\n      const nodes = staircaseMaze(grid, NUMBER_OF_ROWS, NUMBER_OF_COLS);\n\n      for (let k = 0; k < nodes.length; k++) {\n        if (nodes[k] === undefined) {\n          return;\n        }\n\n        setTimeout(() => {\n          if (!(nodes[k].isStart || nodes[k].isFinish || nodes[k].isBomb)) {\n            nodes[k].isWall = true;\n            const element = document.getElementById(`node-${nodes[k].row}-${nodes[k].col}`);\n            element.className = \"node node-wall\";\n          }\n\n          if (nodes[k + 1] === undefined) {\n            this.reEnableButtons();\n            this.enableGrid();\n          }\n        }, k * 10);\n      }\n    };\n\n    this.visualizeMazeThree = () => {\n      this.clearBoard();\n      this.disableButtons();\n      this.disableGrid();\n      const {\n        grid\n      } = this.state;\n      const nodes = mazeThree(grid, NUMBER_OF_ROWS, NUMBER_OF_COLS);\n\n      for (let k = 0; k < nodes.length; k++) {\n        if (nodes[k] === undefined) {\n          return;\n        }\n\n        setTimeout(() => {\n          if (!(nodes[k].isStart || nodes[k].isFinish || nodes[k].isBomb)) {\n            nodes[k].isWall = true;\n            const element = document.getElementById(`node-${nodes[k].row}-${nodes[k].col}`);\n            element.className = \"node node-wall\";\n          }\n\n          if (nodes[k + 1] === undefined) {\n            this.reEnableButtons();\n            this.enableGrid();\n          }\n        }, k * 10);\n      }\n    };\n\n    this.visualizeMazeFour = () => {\n      this.clearBoard();\n      this.disableButtons();\n      this.disableGrid();\n      const {\n        grid\n      } = this.state;\n      const nodes = mazeFour(grid, NUMBER_OF_ROWS, NUMBER_OF_COLS);\n\n      for (let k = 0; k < nodes.length; k++) {\n        if (nodes[k] === undefined) {\n          return;\n        }\n\n        setTimeout(() => {\n          if (!(nodes[k].isStart || nodes[k].isFinish || nodes[k].isBomb)) {\n            nodes[k].isWall = true;\n            const element = document.getElementById(`node-${nodes[k].row}-${nodes[k].col}`);\n            element.className = \"node node-wall\";\n          }\n\n          if (nodes[k + 1] === undefined) {\n            this.reEnableButtons();\n            this.enableGrid();\n          }\n        }, k * 10);\n      }\n    };\n\n    this.disableGrid = () => {\n      const {\n        grid\n      } = this.state;\n\n      for (const row of grid) {\n        for (const node of row) {\n          const element = document.getElementById(`node-${node.row}-${node.col}`);\n          element.style.pointerEvents = \"none\";\n        }\n      }\n    };\n\n    this.enableGrid = () => {\n      const {\n        grid\n      } = this.state;\n\n      for (const row of grid) {\n        for (const node of row) {\n          const element = document.getElementById(`node-${node.row}-${node.col}`);\n          element.style.pointerEvents = \"auto\";\n        }\n      }\n    };\n\n    this.disableButtons = () => {\n      const buttons = document.getElementsByClassName(\"btn\");\n\n      for (let k = 0; k < buttons.length; k++) {\n        buttons[k].disabled = true;\n      }\n    };\n\n    this.reEnableButtons = () => {\n      const buttons = document.getElementsByClassName(\"btn\");\n\n      for (let k = 0; k < buttons.length; k++) {\n        buttons[k].disabled = false;\n      } //keeping addBomb button disabled if it is present on the grid\n\n\n      if (bombNode.status) {\n        document.getElementById(\"add-bomb-button\").disabled = true;\n      }\n    };\n  }\n\n  getWindowSize() {\n    const navBarHeight = document.getElementById(\"navBarContent\").clientHeight;\n    const gridHeight = window.innerHeight - (navBarHeight + 100);\n    const gridWidth = document.getElementById(\"gridContent\").clientWidth;\n    NUMBER_OF_ROWS = Math.floor(gridHeight / 25 - 1);\n    NUMBER_OF_COLS = Math.floor(gridWidth / 25);\n    START_NODE_ROW = Math.floor(NUMBER_OF_ROWS / 2);\n    START_NODE_COL = Math.floor(NUMBER_OF_COLS / 6);\n    FINISH_NODE_ROW = Math.floor(NUMBER_OF_ROWS / 2);\n    FINISH_NODE_COL = Math.floor(NUMBER_OF_COLS / 1.15);\n    BOMB_NODE_ROW = Math.floor(NUMBER_OF_ROWS / 4.2);\n    BOMB_NODE_COL = Math.floor(NUMBER_OF_COLS / 2.2);\n    startNode.row = START_NODE_ROW;\n    startNode.col = START_NODE_COL;\n    finishNode.row = FINISH_NODE_ROW;\n    finishNode.col = FINISH_NODE_COL;\n    bombNode.row = BOMB_NODE_ROW;\n    bombNode.col = BOMB_NODE_COL;\n  }\n\n  componentDidMount() {\n    this.getWindowSize();\n    const grid = this.getInitialGrid();\n    this.setState({\n      grid\n    });\n  } //mouse is pressed and not lifted up\n\n\n  render() {\n    const myStyle = {\n      color: \"black\",\n      backgroundColor: \"ghostwhite\",\n      padding: \"0.5px\",\n      fontFamily: \"Arial\",\n      // position: \"absolute\",\n      textContent: \"center\",\n      display: \"inline-block\",\n      marginBottom: \"0px\",\n      fontStyle: \"italic\"\n    };\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"App\",\n        id: \"mainContent\",\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          id: \"navBarContent\",\n          children: /*#__PURE__*/_jsxDEV(NavBar, {\n            visualizeDijkstra: () => this.visualizeDijkstra(),\n            visualizeAstar: () => this.visualizeAstar(),\n            clearBoard: () => this.clearBoard(),\n            clearPath: () => this.clearPath(),\n            addBomb: () => this.addBomb(),\n            removeBomb: () => this.removeBomb(),\n            genRandomWalls: () => this.genRandomWalls(),\n            visualizeRecursiveDivision: () => this.visualizeRecursiveDivision(),\n            visualizeStaircase: () => this.visualizeStaircase(),\n            visualizeMazeThree: () => this.visualizeMazeThree(),\n            visualizeMazeFour: () => this.visualizeMazeFour()\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 848,\n            columnNumber: 13\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 847,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          id: \"textContent\",\n          children: [/*#__PURE__*/_jsxDEV(NavLink, {\n            activeClassName: \"active\",\n            to: \"/demo\",\n            children: /*#__PURE__*/_jsxDEV(\"button\", {\n              className: \"btn btn-light btn-lg\",\n              style: {\n                float: \"left\"\n              },\n              id: \"demo-button\",\n              children: \"Quick Demo\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 866,\n              columnNumber: 15\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 865,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            style: myStyle,\n            children: [/*#__PURE__*/_jsxDEV(\"div\", {\n              id: \"alignHelperDiv\",\n              children: [/*#__PURE__*/_jsxDEV(\"div\", {\n                id: \"wallNodeImage\",\n                children: \" \"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 876,\n                columnNumber: 17\n              }, this), \" Wall Node\"]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 875,\n              columnNumber: 15\n            }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n              id: \"alignHelperDiv\",\n              children: [/*#__PURE__*/_jsxDEV(\"div\", {\n                id: \"emptyNodeImage\",\n                children: \" \"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 879,\n                columnNumber: 17\n              }, this), \" Unvisited Node\"]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 878,\n              columnNumber: 15\n            }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n              id: \"alignHelperDiv\",\n              children: /*#__PURE__*/_jsxDEV(\"div\", {\n                id: \"visitedNodeImage1\",\n                children: \" \"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 882,\n                columnNumber: 17\n              }, this)\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 881,\n              columnNumber: 15\n            }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n              id: \"alignHelperDiv\",\n              children: [/*#__PURE__*/_jsxDEV(\"div\", {\n                id: \"visitedNodeImage2\",\n                children: \" \"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 885,\n                columnNumber: 17\n              }, this), \" Visited Nodes\"]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 884,\n              columnNumber: 15\n            }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n              id: \"alignHelperDiv\",\n              children: [/*#__PURE__*/_jsxDEV(\"div\", {\n                id: \"startNodeImage\",\n                children: \" \"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 888,\n                columnNumber: 17\n              }, this), \" Start Node\"]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 887,\n              columnNumber: 15\n            }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n              id: \"alignHelperDiv\",\n              children: [/*#__PURE__*/_jsxDEV(\"div\", {\n                id: \"finishNodeImage\",\n                children: \" \"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 891,\n                columnNumber: 17\n              }, this), \" Finish Node\"]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 890,\n              columnNumber: 15\n            }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n              id: \"alignHelperDiv\",\n              children: [/*#__PURE__*/_jsxDEV(\"div\", {\n                id: \"bombNodeImage\",\n                children: \" \"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 894,\n                columnNumber: 17\n              }, this), \" Bomb Node\"]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 893,\n              columnNumber: 15\n            }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n              id: \"alignHelperDiv\",\n              children: [/*#__PURE__*/_jsxDEV(\"div\", {\n                id: \"shortestPathImage\",\n                children: \" \"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 897,\n                columnNumber: 17\n              }, this), \"Shortest Path Node\"]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 896,\n              columnNumber: 15\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 874,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"strong\", {\n            style: myStyle,\n            children: centerText\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 900,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 864,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          id: \"gridContent\",\n          children: /*#__PURE__*/_jsxDEV(PathfindingVisualizer, {\n            grid: this.state.grid,\n            mouseIsPressed: this.state.mouseIsPressed,\n            handleMouseUp: (row, col) => this.handleMouseUp(row, col),\n            handleMouseEnter: (row, col) => this.handleMouseEnter(row, col),\n            handleMouseDown: (row, col) => this.handleMouseDown(row, col)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 903,\n            columnNumber: 13\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 902,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 846,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 845,\n      columnNumber: 7\n    }, this);\n  }\n\n}\nexport default App;","map":{"version":3,"sources":["F:/Deerwalk/semester-5/Micro Project/my-project/pathfinding-visualizer-master/src/App.js"],"names":["React","Component","Route","NavLink","HashRouter","Router","Switch","Demo","PathfindingVisualizer","NavBar","dijkstra","getNodesInShortestPathOrder","astar","getNodesInShortestPathOrderAstar","recursiveDivision","staircaseMaze","mazeThree","mazeFour","centerText","NUMBER_OF_ROWS","NUMBER_OF_COLS","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","BOMB_NODE_ROW","BOMB_NODE_COL","startNode","row","col","finishNode","bombNode","status","draggingStart","draggingFinish","draggingBomb","App","state","grid","mouseIsPressed","handleMouseDown","clearPath","node","newGrid","getNewGridWithStartNodeToggled","setState","getNewGridWithFinishNodeToggled","getNewGridWithBombNodeToggled","getNewGridWithWallToggled","handleMouseEnter","handleMouseUp","slice","newNode","isBomb","isWall","element","document","getElementById","classList","remove","isStart","isFinish","getInitialGrid","currentRow","push","createNode","isVisited","distance","Infinity","previousNode","animateDijsktra","visitedNodesInOrder","nodesInShortestPathOrder","bomb","nodesInShortestPathOrderWithBomb","i","length","setTimeout","animateShortestPath","className","removeArrowClass","determineImage","currentNode","arrowForSecondLastNode","undefined","style","backgroundImage","reEnableButtons","enableGrid","animateDijsktraWithBomb","newVisitedNodesInOrder","newNodesInShortestPathOrder0","newStart","newFinish","nodesInShortestPathOrder1","visualizeDijkstra","disableButtons","disableGrid","bombIsPresent","finish","start","bombNode1","clearBoard","removeBomb","j","animateAstar","animateAstarWithBomb","visualizeAstar","addBomb","disabled","genRandomNumber","Math","floor","random","resetNodeWalls","genRandomWalls","nodes","numberOfPlainNodes","x","visualizeRecursiveDivision","k","visualizeStaircase","visualizeMazeThree","visualizeMazeFour","pointerEvents","buttons","getElementsByClassName","getWindowSize","navBarHeight","clientHeight","gridHeight","window","innerHeight","gridWidth","clientWidth","componentDidMount","render","myStyle","color","backgroundColor","padding","fontFamily","textContent","display","marginBottom","fontStyle","float"],"mappings":"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","sourcesContent":["import React, { Component } from \"react\";\nimport {\n  Route,\n  NavLink,\n  // BrowserRouter as Router,\n  HashRouter as Router,\n  Switch\n} from \"react-router-dom\";\nimport Demo from \"./animations/Demo\";\nimport PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer\";\nimport NavBar from \"./PathfindingVisualizer/NavBar\";\nimport \"./App.css\";\nimport { dijkstra, getNodesInShortestPathOrder } from \"./algorithms/dijkstra\";\n// import { astar, getNodesInShortestPathOrderAstar } from \"./algorithms/astar\";\n// import { astar, getNodesInShortestPathOrderAstar } from \"./algorithms/newAstar\";\nimport { astar, getNodesInShortestPathOrderAstar } from \"./algorithms/astar1\";\n\nimport { recursiveDivision } from \"./mazeAlgorithms/recursiveDivision\";\nimport { staircaseMaze } from \"./mazeAlgorithms/staircaseMaze\";\nimport { mazeThree } from \"./mazeAlgorithms/maze3\";\nimport { mazeFour } from \"./mazeAlgorithms/maze4\";\nlet centerText =\n  \"Click and drag mouse on the grid to draw obstacles(or select from different mazes), then click on the algorithm to find the shortest path ;) (try adding a bomb also...)\";\nlet NUMBER_OF_ROWS = 22,\n  NUMBER_OF_COLS = 56;\nlet START_NODE_ROW = 10,\n  START_NODE_COL = 10,\n  FINISH_NODE_ROW = 10,\n  FINISH_NODE_COL = 40,\n  BOMB_NODE_ROW = 18,\n  BOMB_NODE_COL = 25;\nlet startNode = {\n  row: START_NODE_ROW,\n  col: START_NODE_COL\n};\nlet finishNode = {\n  row: FINISH_NODE_ROW,\n  col: FINISH_NODE_COL\n};\nlet bombNode = {\n  row: BOMB_NODE_ROW,\n  col: BOMB_NODE_COL,\n  status: false\n};\nlet draggingStart = false,\n  draggingFinish = false,\n  draggingBomb = false;\nexport class App extends Component {\n  state = {\n    grid: [],\n    mouseIsPressed: false\n  };\n  getWindowSize() {\n    const navBarHeight = document.getElementById(\"navBarContent\").clientHeight;\n    const gridHeight = window.innerHeight - (navBarHeight + 100);\n    const gridWidth = document.getElementById(\"gridContent\").clientWidth;\n    NUMBER_OF_ROWS = Math.floor(gridHeight / 25 - 1);\n    NUMBER_OF_COLS = Math.floor(gridWidth / 25);\n    START_NODE_ROW = Math.floor(NUMBER_OF_ROWS / 2);\n    START_NODE_COL = Math.floor(NUMBER_OF_COLS / 6);\n    FINISH_NODE_ROW = Math.floor(NUMBER_OF_ROWS / 2);\n    FINISH_NODE_COL = Math.floor(NUMBER_OF_COLS / 1.15);\n    BOMB_NODE_ROW = Math.floor(NUMBER_OF_ROWS / 4.2);\n    BOMB_NODE_COL = Math.floor(NUMBER_OF_COLS / 2.2);\n    startNode.row = START_NODE_ROW;\n    startNode.col = START_NODE_COL;\n    finishNode.row = FINISH_NODE_ROW;\n    finishNode.col = FINISH_NODE_COL;\n    bombNode.row = BOMB_NODE_ROW;\n    bombNode.col = BOMB_NODE_COL;\n  }\n  componentDidMount() {\n    this.getWindowSize();\n    const grid = this.getInitialGrid();\n    this.setState({ grid });\n  }\n  //mouse is pressed and not lifted up\n  handleMouseDown = (row, col) => {\n    this.clearPath();\n    const node = {\n      row: row,\n      col: col\n    };\n    if (node.row === startNode.row && node.col === startNode.col) {\n      const newGrid = this.getNewGridWithStartNodeToggled(\n        this.state.grid,\n        row,\n        col\n      );\n      // we don't want to create walls when we are dragging the start/finish node\n      //mouseIsPressed is set to false so that onMouseEnter doesn't trigger\n      this.setState({ grid: newGrid, mouseIsPressed: false });\n      draggingStart = true;\n    } else if (node.row === finishNode.row && node.col === finishNode.col) {\n      const newGrid = this.getNewGridWithFinishNodeToggled(\n        this.state.grid,\n        row,\n        col\n      );\n      this.setState({ grid: newGrid, mouseIsPressed: false });\n      draggingFinish = true;\n    } else if (\n      node.row === bombNode.row &&\n      node.col === bombNode.col &&\n      bombNode.status //checking with status so it triggers only when addBomb is clicked else it will create a wall on that node\n    ) {\n      const newGrid = this.getNewGridWithBombNodeToggled(\n        this.state.grid,\n        row,\n        col\n      );\n      this.setState({ grid: newGrid, mouseIsPressed: false });\n      draggingBomb = true;\n    } else {\n      const newGrid = this.getNewGridWithWallToggled(this.state.grid, row, col);\n      this.setState({ grid: newGrid, mouseIsPressed: true });\n    }\n  };\n  //hovering over an element\n  //we want walls to be created when mouse is pressed and then dragged\n  //**mouseEnter will won't work when we clicked start/finish node, as we are setting\n  //mouseIsPressed as false in onMouseDown function(on the start/finish node)\n\n  handleMouseEnter = (row, col) => {\n    if (!this.state.mouseIsPressed) return;\n    //below if statement to prevent dragging and forming wall node over the bomb node(mouseIsPressed set to false not working here)\n    //remove this if condition with only bombNode condition if problem persists\n    if (\n      !(\n        (row === bombNode.row && col === bombNode.col) ||\n        (row === startNode.row && col === startNode.col) ||\n        (row === finishNode.row && col === finishNode.col)\n      )\n    ) {\n      const newGrid = this.getNewGridWithWallToggled(this.state.grid, row, col);\n      this.setState({ grid: newGrid });\n    }\n  };\n  //when pressed mouse button is released\n  handleMouseUp = (row, col) => {\n    if (draggingStart) {\n      const newGrid = this.getNewGridWithStartNodeToggled(\n        this.state.grid,\n        row,\n        col\n      );\n      this.setState({ grid: newGrid });\n    } else if (draggingFinish) {\n      const newGrid = this.getNewGridWithFinishNodeToggled(\n        this.state.grid,\n        row,\n        col\n      );\n      this.setState({ grid: newGrid });\n    } else if (draggingBomb) {\n      const newGrid = this.getNewGridWithBombNodeToggled(\n        this.state.grid,\n        row,\n        col\n      );\n      this.setState({ grid: newGrid });\n    }\n    this.setState({ mouseIsPressed: false });\n    //resetting the dragging start/finish when mouse is lifted up\n    draggingStart = false;\n    draggingFinish = false;\n    draggingBomb = false;\n  };\n  getNewGridWithBombNodeToggled = (grid, row, col) => {\n    bombNode.row = row;\n    bombNode.col = col;\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    const newNode = {\n      ...node,\n      isBomb: !node.isBomb,\n      isWall: false\n    };\n    const element = document.getElementById(\n      `node-${bombNode.row}-${bombNode.col}`\n    );\n\n    element.classList.remove(\"node-bomb\");\n    newGrid[row][col] = newNode;\n    //adding className to new node (was working fine without this also), check it later\n    // const newElement = document.getElementById(\n    //   `node-${bombNode.row}-${bombNode.col}`\n    // );\n    // newElement.className = \"node node-bomb\";\n    return newGrid;\n  };\n  getNewGridWithStartNodeToggled = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    startNode.row = row;\n    startNode.col = col;\n    const newNode = {\n      ...node,\n      isStart: !node.isStart,\n      //maybe due to mouse click problem wall is set to true and we are not getting anything\n      //in the visitedNodesInOrder from the dijkstra\n      // *isWall is set to false also bcoz, in case we put walls first and then move the start/finish node on that wall\n\n      isWall: false\n      // distance: Infinity\n      //distance setting to infinity not working, alternative is clearPath function\n    };\n    newGrid[row][col] = newNode;\n    return newGrid;\n  };\n  getNewGridWithFinishNodeToggled = (grid, row, col) => {\n    const newGrid = grid.slice();\n    finishNode.row = row;\n    finishNode.col = col;\n    const node = newGrid[row][col];\n    const newNode = {\n      ...node,\n      isFinish: !node.isFinish,\n      isWall: false\n    };\n    newGrid[row][col] = newNode;\n    return newGrid;\n  };\n  //changing the wall state\n  getNewGridWithWallToggled = (grid, row, col) => {\n    // if (row !== bombNode.row && col !== bombNode.col) {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n\n    const newNode = {\n      ...node,\n      isWall: !node.isWall\n    };\n    newGrid[row][col] = newNode;\n    return newGrid;\n  };\n  getInitialGrid = () => {\n    let grid = [];\n    for (let row = 0; row < NUMBER_OF_ROWS; row++) {\n      let currentRow = [];\n      for (let col = 0; col < NUMBER_OF_COLS; col++) {\n        currentRow.push(this.createNode(col, row));\n      }\n      grid.push(currentRow);\n    }\n    return grid;\n  };\n  createNode = (col, row) => {\n    return {\n      isVisited: false,\n      col,\n      row,\n      isStart: row === START_NODE_ROW && col === START_NODE_COL,\n      isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n      distance: Infinity,\n      isWall: false,\n      previousNode: null,\n      isBomb: false\n    };\n  };\n\n  animateDijsktra = (\n    visitedNodesInOrder,\n    nodesInShortestPathOrder,\n    bomb,\n    nodesInShortestPathOrderWithBomb\n  ) => {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          if (!bomb) {\n            //no bomb\n            this.animateShortestPath(nodesInShortestPathOrder);\n          } else {\n            //bomb is present\n            this.animateShortestPath(nodesInShortestPathOrderWithBomb);\n            // return;\n          }\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        //if statement to avoid coloring of start and finish node\n        if (!(node.isStart || node.isFinish || node.isBomb)) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-visited\";\n        }\n      }, 10 * i);\n    }\n  };\n  //remove the arrow classname and calling this function in clearPath and clearBoard functions so that arrow are removed after visualization\n  removeArrowClass = () => {\n    const { grid } = this.state;\n    for (const row of grid) {\n      for (const node of row) {\n        const element = document.getElementById(`node-${node.row}-${node.col}`);\n        element.classList.remove(\"node-right-arrow\");\n        element.classList.remove(\"node-left-arrow\");\n        element.classList.remove(\"node-up-arrow\");\n        element.classList.remove(\"node-down-arrow\");\n      }\n    }\n  };\n  determineImage = (currentNode, previousNode) => {\n    const element = document.getElementById(\n      `node-${currentNode.row}-${currentNode.col}`\n    );\n    if (currentNode.col > previousNode.col) {\n      //moving right\n      element.className = \"node node-shortest-path node-right-arrow\";\n    } else if (currentNode.row < previousNode.row) {\n      //moving up\n      element.className = \"node node-shortest-path node-up-arrow\";\n    } else if (currentNode.col < previousNode.col) {\n      // moving left\n      element.className = \"node node-shortest-path node-left-arrow\";\n    } else if (currentNode.row > previousNode.row) {\n      //moving down\n      element.className = \"node node-shortest-path node-down-arrow\";\n    }\n  };\n  //this function adds the correct positioned arrow before the finish node as determineImage wasn't getting it correctly\n  arrowForSecondLastNode = (node, previousNode) => {\n    //two if conditions to escape the bug when no path to bombNode is found\n    if (previousNode === undefined) return;\n    if (node === undefined) return;\n    const element = document.getElementById(\n      `node-${previousNode.row}-${previousNode.col}`\n    );\n    if (node.col > previousNode.col) {\n      //finish node is right\n      element.className = \"node node-shortest-path node-right-arrow\";\n    } else if (node.row > previousNode.row) {\n      //finish node is below\n      element.className = \"node node-shortest-path node-down-arrow\";\n    } else if (node.row < previousNode.row) {\n      //finish node is above\n      element.className = \"node node-shortest-path node-up-arrow\";\n    } else if (node.col < previousNode.col) {\n      //finish node is left\n      element.className = \"node node-shortest-path node-left-arrow\";\n    }\n  };\n  animateShortestPath = nodesInShortestPathOrder => {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        const previousNode = nodesInShortestPathOrder[i - 1];\n        if (!(node.isStart || node.isFinish || node.isBomb)) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-shortest-path\";\n          //setting the arrow image\n          this.determineImage(node, previousNode);\n          //first we are setting the image of the current travelling node and then removing the previous one's image(if set) simultaneously to make it look like a moving arrow\n          //resetting the arrow image of previous node (so that it looks like a travelling arrow)\n          if (\n            !(\n              previousNode.isStart ||\n              previousNode.isFinish ||\n              previousNode.isBomb\n            )\n          ) {\n            document.getElementById(\n              `node-${previousNode.row}-${previousNode.col}`\n            ).style.backgroundImage = \"none\";\n          }\n        }\n        //this if block is for direction arrow of node just before finish node\n        if (node.isBomb) {\n          // this.determineImage(node, previousNode);\n          this.arrowForSecondLastNode(node, previousNode);\n        }\n        //this if block is for direction arrow of node just before finish node\n        if (node.isFinish) {\n          // this.determineImage(node, previousNode);\n          this.arrowForSecondLastNode(node, previousNode);\n        }\n        if (i === nodesInShortestPathOrder.length - 1) {\n          this.reEnableButtons();\n          this.enableGrid();\n        }\n      }, 50 * i);\n    }\n  };\n\n  animateDijsktraWithBomb = (\n    newVisitedNodesInOrder,\n    newNodesInShortestPathOrder0,\n    newStart,\n    newFinish\n  ) => {\n    for (let i = 0; i <= newVisitedNodesInOrder.length; i++) {\n      if (i === newVisitedNodesInOrder.length) {\n        setTimeout(() => {\n          const { grid } = this.state;\n          const visitedNodesInOrder = dijkstra(grid, newStart, newFinish);\n          const nodesInShortestPathOrder1 = getNodesInShortestPathOrder(\n            newFinish\n          );\n          const nodesInShortestPathOrder = [\n            ...newNodesInShortestPathOrder0,\n            ...nodesInShortestPathOrder1\n          ];\n          this.animateDijsktra(\n            visitedNodesInOrder,\n            nodesInShortestPathOrder1,\n            true,\n            nodesInShortestPathOrder\n          );\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = newVisitedNodesInOrder[i];\n        //if statement to avoid coloring of start and finish node\n        if (!(node.isStart || node.isFinish || node.isBomb)) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-bomb-visited\";\n        }\n      }, 10 * i);\n    }\n  };\n\n  visualizeDijkstra = () => {\n    centerText =\n      \"Dijkstra’s algorithm finds a shortest path tree from a single source node, by building a set of nodes that have minimum distance from the source. Dijkstra's algorithm guarantees shortest path.\";\n    //just to make sure that when visualize dijkstra button is clicked path is cleared so that in case we move the start Node without clearing the board algorithm starts from a new startPoint\n    //*if we don't clearPath dijkstra algorithm will start from the node whose distance is minimum and in the algorithms we have set the distance of startNode as 0(initially), so when we don't call clearPath function(in which we reset all the distance back to Infinity), and move the startNode to a new Point,visualization starts from the previous node only.\n    this.clearPath();\n    this.disableButtons();\n    this.disableGrid();\n    const { grid } = this.state;\n    let bombIsPresent = false;\n    if (bombNode.status) {\n      bombIsPresent = true;\n    }\n    const finish = grid[finishNode.row][finishNode.col];\n    if (!bombIsPresent) {\n      const start = grid[startNode.row][startNode.col];\n      const visitedNodesInOrder = dijkstra(grid, start, finish);\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finish);\n      this.animateDijsktra(\n        visitedNodesInOrder,\n        nodesInShortestPathOrder,\n        false,\n        null\n      );\n    } else {\n      const bombNode1 = grid[bombNode.row][bombNode.col];\n      const start = grid[startNode.row][startNode.col];\n      const visitedNodesInOrder = dijkstra(grid, start, bombNode1);\n\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(bombNode1);\n      this.animateDijsktraWithBomb(\n        visitedNodesInOrder,\n        nodesInShortestPathOrder,\n        bombNode1,\n        finish\n      );\n    }\n  };\n  clearBoard = () => {\n    this.removeArrowClass();\n    this.removeBomb();\n    const { grid } = this.state;\n    const newGrid = grid.slice();\n    for (let i = 0; i < newGrid.length; i++) {\n      for (let j = 0; j < newGrid[i].length; j++) {\n        const element = document.getElementById(`node-${i}-${j}`);\n        element.classList.remove(\"node-visited\");\n        element.classList.remove(\"node-shortest-path\");\n        element.classList.remove(\"node-bomb-visited\");\n        //clearing class node-wall is optional(working fine otherwise also)\n        element.classList.remove(\"node-wall\");\n        newGrid[i][j].isVisited = false;\n        newGrid[i][j].distance = Infinity;\n        newGrid[i][j].isWall = false;\n        newGrid[i][j].previousNode = null;\n      }\n    }\n    this.setState({ grid: newGrid });\n  };\n  clearPath = () => {\n    this.removeArrowClass();\n    const { grid } = this.state;\n    const newGrid = grid.slice();\n    // console.log(newGrid[startNode.row][startNode.col]);\n    for (let i = 0; i < newGrid.length; i++) {\n      for (let j = 0; j < newGrid[i].length; j++) {\n        // console.log(newGrid[i][j]);\n        const element = document.getElementById(`node-${i}-${j}`);\n        element.classList.remove(\"node-visited\");\n        element.classList.remove(\"node-shortest-path\");\n        element.classList.remove(\"node-bomb-visited\");\n        newGrid[i][j].isVisited = false;\n        newGrid[i][j].distance = Infinity;\n        newGrid[i][j].previousNode = null;\n      }\n    }\n    this.setState({ grid: newGrid });\n  };\n  animateAstar = (\n    visitedNodesInOrder,\n    nodesInShortestPathOrder,\n    bomb,\n    nodesInShortestPathOrderWithBomb\n  ) => {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          if (!bomb) {\n            //no bomb\n            this.animateShortestPath(nodesInShortestPathOrder);\n          } else {\n            this.animateShortestPath(nodesInShortestPathOrderWithBomb);\n          }\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        //if statement to avoid coloring of start and finish node\n        if (!(node.isStart || node.isFinish || node.isBomb)) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-visited\";\n        }\n      }, 10 * i);\n    }\n  };\n  animateAstarWithBomb = (\n    newVisitedNodesInOrder,\n    newNodesInShortestPathOrder0,\n    newStart,\n    newFinish\n  ) => {\n    for (let i = 0; i <= newVisitedNodesInOrder.length; i++) {\n      if (i === newVisitedNodesInOrder.length) {\n        setTimeout(() => {\n          const { grid } = this.state;\n          const visitedNodesInOrder = astar(grid, newStart, newFinish);\n          const nodesInShortestPathOrder1 = getNodesInShortestPathOrderAstar(\n            newFinish\n          );\n          const nodesInShortestPathOrder = [\n            ...newNodesInShortestPathOrder0,\n            ...nodesInShortestPathOrder1\n          ];\n          this.animateAstar(\n            visitedNodesInOrder,\n            nodesInShortestPathOrder1,\n            true,\n            nodesInShortestPathOrder\n          );\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = newVisitedNodesInOrder[i];\n        //if statement to avoid coloring of start and finish node\n        if (!(node.isStart || node.isFinish || node.isBomb)) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-bomb-visited\";\n        }\n      }, 10 * i);\n    }\n  };\n  visualizeAstar = () => {\n    //disabling all buttons while visualization\n    centerText =\n      \"A* algorithm calculates heuristic distance(distance from the end node) which guides it towards the target node faster. A* algorithm guarantees shortest path..\";\n    this.disableButtons();\n    this.disableGrid();\n    this.clearPath();\n    const { grid } = this.state;\n    let bombIsPresent = false;\n    if (bombNode.status) {\n      bombIsPresent = true;\n    }\n    const start = grid[startNode.row][startNode.col];\n    const finish = grid[finishNode.row][finishNode.col];\n    if (!bombIsPresent) {\n      const visitedNodesInOrder = astar(grid, start, finish);\n      const nodesInShortestPathOrder = getNodesInShortestPathOrderAstar(finish);\n      this.animateAstar(\n        visitedNodesInOrder,\n        nodesInShortestPathOrder,\n        false,\n        null\n      );\n    } else {\n      const bombNode1 = grid[bombNode.row][bombNode.col];\n      const visitedNodesInOrder = astar(grid, start, bombNode1);\n      const nodesInShortestPathOrder = getNodesInShortestPathOrderAstar(\n        bombNode1\n      );\n      this.animateAstarWithBomb(\n        visitedNodesInOrder,\n        nodesInShortestPathOrder,\n        bombNode1,\n        finish\n      );\n    }\n  };\n  addBomb = () => {\n    this.clearPath();\n    centerText =\n      \"When bomb is active the algorithm will first try to find the shortest path to bomb to deactivate it and then will reach the finish node ..\";\n    const { grid } = this.state;\n    for (const row of grid) {\n      for (const node of row) {\n        if (node.row === bombNode.row && node.col === bombNode.col) {\n          node.isWall = false;\n          node.isBomb = true;\n        } else {\n          // node.bombNode = false;\n          // continue;\n        }\n      }\n    }\n    bombNode.status = true;\n    document.getElementById(`node-${bombNode.row}-${bombNode.col}`).className =\n      \"node node-bomb\";\n    this.setState({ grid });\n    document.getElementById(\"add-bomb-button\").disabled = true;\n  };\n  removeBomb = () => {\n    this.clearPath();\n    document.getElementById(\"add-bomb-button\").disabled = false;\n\n    centerText =\n      \"Click and drag mouse on the grid to draw obstacles(or select from different mazes), then click on the algorithm to find the shortest path ;) (try adding a bomb also...)\";\n    // bomb = false;\n    const { grid } = this.state;\n    const element = document.getElementById(\n      `node-${bombNode.row}-${bombNode.col}`\n    );\n    element.classList.remove(\"node-bomb\");\n    for (const row of grid) {\n      for (const node of row) {\n        node.isBomb = false;\n      }\n    }\n    bombNode.status = false;\n    this.setState({ grid });\n  };\n  genRandomNumber = () => {\n    return Math.floor(Math.random() * (NUMBER_OF_COLS * NUMBER_OF_ROWS));\n  };\n  resetNodeWalls = () => {\n    const { grid } = this.state;\n    const newGrid = grid.slice();\n    for (const row of newGrid) {\n      for (const node of row) {\n        node.isWall = false;\n      }\n    }\n    this.setState({ grid: newGrid });\n  };\n  genRandomWalls = () => {\n    this.clearPath();\n    this.resetNodeWalls();\n    const { grid } = this.state;\n    const newGrid = grid.slice();\n    let nodes = [];\n    for (const row of grid) {\n      for (const node of row) {\n        if (\n          !(\n            (node.row === bombNode.row && node.col === bombNode.col) ||\n            (node.row === startNode.row && node.col === startNode.col) ||\n            (node.row === finishNode.row && node.col === finishNode.col)\n          )\n        ) {\n          nodes.push(node);\n        }\n      }\n    }\n    let numberOfPlainNodes = nodes.length;\n    let x = Math.floor((40 / 100) * numberOfPlainNodes),\n      random = this.genRandomNumber();\n    //some kind of error with genRandomWall function, to ignore it following two if statements are there, check later if problem persists \"cannot read property nodes[random].isWall of unknown\"\n    while (x) {\n      if (nodes[random] === undefined) return;\n      if (nodes[random].isWall === undefined) return;\n      nodes[random].isWall = !nodes[random].isWall;\n      x -= 1;\n\n      random = this.genRandomNumber();\n    }\n    this.setState({ grid: newGrid });\n  };\n  visualizeRecursiveDivision = () => {\n    this.clearBoard();\n    this.disableButtons();\n    this.disableGrid();\n    const { grid } = this.state;\n    const nodes = recursiveDivision(grid, NUMBER_OF_ROWS, NUMBER_OF_COLS);\n    for (let k = 0; k < nodes.length; k++) {\n      //our nodes array will always more likely be greater than the actual number of nodes on the grid (as the way we are filling the array (setting the pattern number of time,see while loop in corresponding maze algorithm), and then pruning our nodes array till it reaches undefined i.e to the size of the number of nodes in the grid)\n      if (nodes[k] === undefined) {\n        return;\n      }\n\n      setTimeout(() => {\n        if (!(nodes[k].isStart || nodes[k].isFinish || nodes[k].isBomb)) {\n          nodes[k].isWall = true;\n          const element = document.getElementById(\n            `node-${nodes[k].row}-${nodes[k].col}`\n          );\n          element.className = \"node node-wall\";\n        }\n        //we would'nt have reached nodes[k]===undefined as we are returning from that point so we are checking in advance (also so that disabling persists while walls are being drawn)\n        if (nodes[k + 1] === undefined) {\n          this.reEnableButtons();\n          this.enableGrid();\n        }\n      }, k * 10);\n    }\n  };\n  visualizeStaircase = () => {\n    this.clearBoard();\n    this.disableButtons();\n    this.disableGrid();\n    const { grid } = this.state;\n    const nodes = staircaseMaze(grid, NUMBER_OF_ROWS, NUMBER_OF_COLS);\n    for (let k = 0; k < nodes.length; k++) {\n      if (nodes[k] === undefined) {\n        return;\n      }\n      setTimeout(() => {\n        if (!(nodes[k].isStart || nodes[k].isFinish || nodes[k].isBomb)) {\n          nodes[k].isWall = true;\n          const element = document.getElementById(\n            `node-${nodes[k].row}-${nodes[k].col}`\n          );\n          element.className = \"node node-wall\";\n        }\n        if (nodes[k + 1] === undefined) {\n          this.reEnableButtons();\n          this.enableGrid();\n        }\n      }, k * 10);\n    }\n  };\n  visualizeMazeThree = () => {\n    this.clearBoard();\n    this.disableButtons();\n    this.disableGrid();\n    const { grid } = this.state;\n    const nodes = mazeThree(grid, NUMBER_OF_ROWS, NUMBER_OF_COLS);\n    for (let k = 0; k < nodes.length; k++) {\n      if (nodes[k] === undefined) {\n        return;\n      }\n      setTimeout(() => {\n        if (!(nodes[k].isStart || nodes[k].isFinish || nodes[k].isBomb)) {\n          nodes[k].isWall = true;\n          const element = document.getElementById(\n            `node-${nodes[k].row}-${nodes[k].col}`\n          );\n          element.className = \"node node-wall\";\n        }\n        if (nodes[k + 1] === undefined) {\n          this.reEnableButtons();\n          this.enableGrid();\n        }\n      }, k * 10);\n    }\n  };\n  visualizeMazeFour = () => {\n    this.clearBoard();\n    this.disableButtons();\n    this.disableGrid();\n    const { grid } = this.state;\n    const nodes = mazeFour(grid, NUMBER_OF_ROWS, NUMBER_OF_COLS);\n    for (let k = 0; k < nodes.length; k++) {\n      if (nodes[k] === undefined) {\n        return;\n      }\n      setTimeout(() => {\n        if (!(nodes[k].isStart || nodes[k].isFinish || nodes[k].isBomb)) {\n          nodes[k].isWall = true;\n          const element = document.getElementById(\n            `node-${nodes[k].row}-${nodes[k].col}`\n          );\n          element.className = \"node node-wall\";\n        }\n        if (nodes[k + 1] === undefined) {\n          this.reEnableButtons();\n          this.enableGrid();\n        }\n      }, k * 10);\n    }\n  };\n  disableGrid = () => {\n    const { grid } = this.state;\n    for (const row of grid) {\n      for (const node of row) {\n        const element = document.getElementById(`node-${node.row}-${node.col}`);\n        element.style.pointerEvents = \"none\";\n      }\n    }\n  };\n  enableGrid = () => {\n    const { grid } = this.state;\n    for (const row of grid) {\n      for (const node of row) {\n        const element = document.getElementById(`node-${node.row}-${node.col}`);\n        element.style.pointerEvents = \"auto\";\n      }\n    }\n  };\n  disableButtons = () => {\n    const buttons = document.getElementsByClassName(\"btn\");\n    for (let k = 0; k < buttons.length; k++) {\n      buttons[k].disabled = true;\n    }\n  };\n  reEnableButtons = () => {\n    const buttons = document.getElementsByClassName(\"btn\");\n\n    for (let k = 0; k < buttons.length; k++) {\n      buttons[k].disabled = false;\n    }\n    //keeping addBomb button disabled if it is present on the grid\n    if (bombNode.status) {\n      document.getElementById(\"add-bomb-button\").disabled = true;\n    }\n  };\n  render() {\n    const myStyle = {\n      color: \"black\",\n      backgroundColor: \"ghostwhite\",\n      padding: \"0.5px\",\n      fontFamily: \"Arial\",\n      // position: \"absolute\",\n      textContent: \"center\",\n      display: \"inline-block\",\n      marginBottom: \"0px\",\n      fontStyle: \"italic\"\n    };\n\n    return (\n      <div>\n        <div className=\"App\" id=\"mainContent\">\n          <div id=\"navBarContent\">\n            <NavBar\n              visualizeDijkstra={() => this.visualizeDijkstra()}\n              visualizeAstar={() => this.visualizeAstar()}\n              clearBoard={() => this.clearBoard()}\n              clearPath={() => this.clearPath()}\n              addBomb={() => this.addBomb()}\n              removeBomb={() => this.removeBomb()}\n              genRandomWalls={() => this.genRandomWalls()}\n              visualizeRecursiveDivision={() =>\n                this.visualizeRecursiveDivision()\n              }\n              visualizeStaircase={() => this.visualizeStaircase()}\n              visualizeMazeThree={() => this.visualizeMazeThree()}\n              visualizeMazeFour={() => this.visualizeMazeFour()}\n            />\n          </div>\n          <div id=\"textContent\">\n            <NavLink activeClassName=\"active\" to=\"/demo\">\n              <button\n                className=\"btn btn-light btn-lg\"\n                style={{ float: \"left\" }}\n                id=\"demo-button\"\n              >\n                Quick Demo\n              </button>\n            </NavLink>\n            <div style={myStyle}>\n              <div id=\"alignHelperDiv\">\n                <div id=\"wallNodeImage\"> </div> Wall Node\n              </div>\n              <div id=\"alignHelperDiv\">\n                <div id=\"emptyNodeImage\"> </div> Unvisited Node\n              </div>\n              <div id=\"alignHelperDiv\">\n                <div id=\"visitedNodeImage1\"> </div>\n              </div>\n              <div id=\"alignHelperDiv\">\n                <div id=\"visitedNodeImage2\"> </div> Visited Nodes\n              </div>\n              <div id=\"alignHelperDiv\">\n                <div id=\"startNodeImage\"> </div> Start Node\n              </div>\n              <div id=\"alignHelperDiv\">\n                <div id=\"finishNodeImage\"> </div> Finish Node\n              </div>\n              <div id=\"alignHelperDiv\">\n                <div id=\"bombNodeImage\"> </div> Bomb Node\n              </div>\n              <div id=\"alignHelperDiv\">\n                <div id=\"shortestPathImage\"> </div>Shortest Path Node\n              </div>\n            </div>\n            <strong style={myStyle}>{centerText}</strong>\n          </div>\n          <div id=\"gridContent\">\n            <PathfindingVisualizer\n              grid={this.state.grid}\n              mouseIsPressed={this.state.mouseIsPressed}\n              handleMouseUp={(row, col) => this.handleMouseUp(row, col)}\n              handleMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\n              handleMouseDown={(row, col) => this.handleMouseDown(row, col)}\n            />\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n"]},"metadata":{},"sourceType":"module"}