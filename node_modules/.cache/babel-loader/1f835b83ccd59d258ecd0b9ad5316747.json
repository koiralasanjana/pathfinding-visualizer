{"ast":null,"code":"export function dijkstra(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n\n  startNode.distance = 0;\n  let unvisitedNodes = getNodes(grid);\n  let visitedNodesInOrder = [];\n\n  while (unvisitedNodes.length !== 0) {\n    unvisitedNodes.sort((a, b) => a.distance - b.distance);\n    let closestNode = unvisitedNodes.shift();\n    if (closestNode.isWall) continue;\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    updateUnvisitedNeighbours(closestNode, grid);\n  }\n}\n\nfunction getNodes(grid) {\n  let nodes = [];\n\n  for (let row of grid) {\n    for (let node of row) {\n      nodes.push(node);\n    }\n  }\n\n  return nodes;\n}\n\nfunction updateUnvisitedNeighbours(node, grid) {\n  let unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\n\n  for (let unvisitedNeighbour of unvisitedNeighbours) {\n    unvisitedNeighbour.distance = node.distance + 1;\n    unvisitedNeighbour.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n  let neighbours = [];\n  let {\n    row,\n    col\n  } = node;\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  return neighbours.filter(neighbour => !neighbour.isWall).filter(neighbour => !neighbour.isVisited);\n}\n\nexport function getNodesInShortestPathOrderDijkstra(finishNode) {\n  let nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return nodesInShortestPathOrder;\n}","map":{"version":3,"sources":["F:/Deerwalk/semester-5/Micro Project/pathfinding-visualizer-master/src/pathfindingAlgorithms/dijkstra.js"],"names":["dijkstra","grid","startNode","finishNode","distance","unvisitedNodes","getNodes","visitedNodesInOrder","length","sort","a","b","closestNode","shift","isWall","Infinity","isVisited","push","updateUnvisitedNeighbours","nodes","row","node","unvisitedNeighbours","getUnvisitedNeighbours","unvisitedNeighbour","previousNode","neighbours","col","filter","neighbour","getNodesInShortestPathOrderDijkstra","nodesInShortestPathOrder","currentNode","unshift"],"mappings":"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","sourcesContent":["export function dijkstra(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  startNode.distance = 0;\n  let unvisitedNodes = getNodes(grid);\n  let visitedNodesInOrder = [];\n  while (unvisitedNodes.length !== 0) {\n    unvisitedNodes.sort((a, b) => a.distance - b.distance);\n    let closestNode = unvisitedNodes.shift();\n    if (closestNode.isWall) continue;\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    updateUnvisitedNeighbours(closestNode, grid);\n  }\n}\n\nfunction getNodes(grid) {\n  let nodes = [];\n  for (let row of grid) {\n    for (let node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\nfunction updateUnvisitedNeighbours(node, grid) {\n  let unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\n  for (let unvisitedNeighbour of unvisitedNeighbours) {\n    unvisitedNeighbour.distance = node.distance + 1;\n    unvisitedNeighbour.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n  let neighbours = [];\n  let { row, col } = node;\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  return neighbours\n    .filter((neighbour) => !neighbour.isWall)\n    .filter((neighbour) => !neighbour.isVisited);\n}\n\nexport function getNodesInShortestPathOrderDijkstra(finishNode) {\n  let nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n"]},"metadata":{},"sourceType":"module"}