{"ast":null,"code":"export function depthFirstSearch(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n\n  let unvisitedNodes = [];\n  let visitedNodesInOrder = [];\n  unvisitedNodes.push(startNode);\n\n  while (unvisitedNodes.length !== 0) {\n    let closestNode = unvisitedNodes.shift();\n    if (closestNode.isWall) continue;\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    visitedNodesInOrder.push(closestNode);\n    closestNode.isVisited = true;\n    let unvisitedNeighbours = getUnvisitedNeighbours(closestNode, grid);\n\n    for (let unvisitedNeighbour of unvisitedNeighbours) {\n      unvisitedNeighbour.previousNode = closestNode;\n      unvisitedNodes.unshift(unvisitedNeighbour);\n    }\n  }\n\n  return visitedNodesInOrder;\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n  let neighbours = [];\n  let {\n    row,\n    col\n  } = node;\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  return neighbours.filter(neighbour => !neighbour.isVisited);\n}\n\nexport function getNodesInShortestPathOrderDFS(finishNode) {\n  let nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return nodesInShortestPathOrder;\n}","map":{"version":3,"sources":["F:/Deerwalk/semester-5/Micro Project/pathfinding-visualizer-master/src/pathfindingAlgorithms/depthFirstSearch.js"],"names":["depthFirstSearch","grid","startNode","finishNode","unvisitedNodes","visitedNodesInOrder","push","length","closestNode","shift","isWall","isVisited","unvisitedNeighbours","getUnvisitedNeighbours","unvisitedNeighbour","previousNode","unshift","node","neighbours","row","col","filter","neighbour","getNodesInShortestPathOrderDFS","nodesInShortestPathOrder","currentNode"],"mappings":"AAAA,OAAO,SAASA,gBAAT,CAA0BC,IAA1B,EAAgCC,SAAhC,EAA2CC,UAA3C,EAAuD;AAC5D,MAAI,CAACD,SAAD,IAAc,CAACC,UAAf,IAA6BD,SAAS,KAAKC,UAA/C,EAA2D;AACzD,WAAO,KAAP;AACD;;AACD,MAAIC,cAAc,GAAG,EAArB;AACA,MAAIC,mBAAmB,GAAG,EAA1B;AACAD,EAAAA,cAAc,CAACE,IAAf,CAAoBJ,SAApB;;AACA,SAAOE,cAAc,CAACG,MAAf,KAA0B,CAAjC,EAAoC;AAClC,QAAIC,WAAW,GAAGJ,cAAc,CAACK,KAAf,EAAlB;AACA,QAAID,WAAW,CAACE,MAAhB,EAAwB;AACxB,QAAIF,WAAW,KAAKL,UAApB,EAAgC,OAAOE,mBAAP;AAChCA,IAAAA,mBAAmB,CAACC,IAApB,CAAyBE,WAAzB;AACAA,IAAAA,WAAW,CAACG,SAAZ,GAAwB,IAAxB;AACA,QAAIC,mBAAmB,GAAGC,sBAAsB,CAACL,WAAD,EAAcP,IAAd,CAAhD;;AACA,SAAK,IAAIa,kBAAT,IAA+BF,mBAA/B,EAAoD;AAClDE,MAAAA,kBAAkB,CAACC,YAAnB,GAAkCP,WAAlC;AACAJ,MAAAA,cAAc,CAACY,OAAf,CAAuBF,kBAAvB;AACD;AACF;;AACD,SAAOT,mBAAP;AACD;;AAED,SAASQ,sBAAT,CAAgCI,IAAhC,EAAsChB,IAAtC,EAA4C;AAC1C,MAAIiB,UAAU,GAAG,EAAjB;AACA,MAAI;AAAEC,IAAAA,GAAF;AAAOC,IAAAA;AAAP,MAAeH,IAAnB;AACA,MAAIG,GAAG,KAAK,CAAZ,EAAeF,UAAU,CAACZ,IAAX,CAAgBL,IAAI,CAACkB,GAAD,CAAJ,CAAUC,GAAG,GAAG,CAAhB,CAAhB;AACf,MAAID,GAAG,KAAK,CAAZ,EAAeD,UAAU,CAACZ,IAAX,CAAgBL,IAAI,CAACkB,GAAG,GAAG,CAAP,CAAJ,CAAcC,GAAd,CAAhB;AACf,MAAIA,GAAG,KAAKnB,IAAI,CAAC,CAAD,CAAJ,CAAQM,MAAR,GAAiB,CAA7B,EAAgCW,UAAU,CAACZ,IAAX,CAAgBL,IAAI,CAACkB,GAAD,CAAJ,CAAUC,GAAG,GAAG,CAAhB,CAAhB;AAChC,MAAID,GAAG,KAAKlB,IAAI,CAACM,MAAL,GAAc,CAA1B,EAA6BW,UAAU,CAACZ,IAAX,CAAgBL,IAAI,CAACkB,GAAG,GAAG,CAAP,CAAJ,CAAcC,GAAd,CAAhB;AAC7B,SAAOF,UAAU,CAACG,MAAX,CAAmBC,SAAD,IAAe,CAACA,SAAS,CAACX,SAA5C,CAAP;AACD;;AAED,OAAO,SAASY,8BAAT,CAAwCpB,UAAxC,EAAoD;AACzD,MAAIqB,wBAAwB,GAAG,EAA/B;AACA,MAAIC,WAAW,GAAGtB,UAAlB;;AACA,SAAOsB,WAAW,KAAK,IAAvB,EAA6B;AAC3BD,IAAAA,wBAAwB,CAACR,OAAzB,CAAiCS,WAAjC;AACAA,IAAAA,WAAW,GAAGA,WAAW,CAACV,YAA1B;AACD;;AACD,SAAOS,wBAAP;AACD","sourcesContent":["export function depthFirstSearch(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let unvisitedNodes = [];\n  let visitedNodesInOrder = [];\n  unvisitedNodes.push(startNode);\n  while (unvisitedNodes.length !== 0) {\n    let closestNode = unvisitedNodes.shift();\n    if (closestNode.isWall) continue;\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    visitedNodesInOrder.push(closestNode);\n    closestNode.isVisited = true;\n    let unvisitedNeighbours = getUnvisitedNeighbours(closestNode, grid);\n    for (let unvisitedNeighbour of unvisitedNeighbours) {\n      unvisitedNeighbour.previousNode = closestNode;\n      unvisitedNodes.unshift(unvisitedNeighbour);\n    }\n  }\n  return visitedNodesInOrder;\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n  let neighbours = [];\n  let { row, col } = node;\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  return neighbours.filter((neighbour) => !neighbour.isVisited);\n}\n\nexport function getNodesInShortestPathOrderDFS(finishNode) {\n  let nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n"]},"metadata":{},"sourceType":"module"}