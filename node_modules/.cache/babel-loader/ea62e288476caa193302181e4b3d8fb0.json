{"ast":null,"code":"export function randomWalk(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n\n  let visitedNodesInOrder = [];\n  let closestNode = startNode;\n  let maxNodes = grid.length * grid[0].length;\n  let maxNodesVisitedTracker = 0;\n  let loopTracker = 0;\n\n  while (true) {\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    let randomNeighbour = getRandomNeighbour(closestNode, grid, finishNode);\n    let nodesVisited = numNodesVisited(grid);\n\n    if (nodesVisited === maxNodes - 2) {\n      return visitedNodesInOrder;\n    }\n\n    if (nodesVisited > maxNodesVisitedTracker) {\n      maxNodesVisitedTracker = nodesVisited;\n      loopTracker = 0;\n    } else if (nodesVisited = maxNodesVisitedTracker) {\n      loopTracker += 1;\n\n      if (loopTracker > 1000) {\n        return visitedNodesInOrder;\n      }\n    }\n\n    randomNeighbour.previousNode = closestNode;\n    closestNode = randomNeighbour;\n  }\n}\n\nfunction getRandomNeighbour(node, grid, finishNode) {\n  let neighbours = [];\n  let {\n    row,\n    col\n  } = node;\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  let neighboursFilteredStartAndWall = neighbours.filter(neighbour => !neighbour.isStart && !neighbour.isWall);\n  let neighboursFilteredVisited = neighboursFilteredStartAndWall.filter(neighbour => !neighbour.isVisited);\n\n  if (neighboursFilteredVisited.length > 0) {\n    return neighboursFilteredVisited[Math.floor(Math.random() * neighboursFilteredVisited.length)];\n  }\n\n  return neighboursFilteredStartAndWall[Math.floor(Math.random() * neighboursFilteredStartAndWall.length)];\n}\n\nfunction numNodesVisited(grid) {\n  let count = 0;\n\n  for (let row of grid) {\n    for (let node of row) {\n      if (node.isVisited || node.isWall) count += 1;\n    }\n  }\n\n  return count;\n}","map":{"version":3,"sources":["F:/Deerwalk/semester-5/Micro Project/pathfinding-visualizer-master/src/pathfindingAlgorithms/randomWalk.js"],"names":["randomWalk","grid","startNode","finishNode","visitedNodesInOrder","closestNode","maxNodes","length","maxNodesVisitedTracker","loopTracker","isVisited","push","randomNeighbour","getRandomNeighbour","nodesVisited","numNodesVisited","previousNode","node","neighbours","row","col","neighboursFilteredStartAndWall","filter","neighbour","isStart","isWall","neighboursFilteredVisited","Math","floor","random","count"],"mappings":"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","sourcesContent":["export function randomWalk(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let visitedNodesInOrder = [];\n  let closestNode = startNode;\n  let maxNodes = grid.length * grid[0].length;\n  let maxNodesVisitedTracker = 0;\n  let loopTracker = 0;\n  while (true) {\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    let randomNeighbour = getRandomNeighbour(closestNode, grid, finishNode);\n    let nodesVisited = numNodesVisited(grid);\n    if (nodesVisited === maxNodes - 2) {\n      return visitedNodesInOrder;\n    }\n    if (nodesVisited > maxNodesVisitedTracker) {\n      maxNodesVisitedTracker = nodesVisited;\n      loopTracker = 0;\n    } else if ((nodesVisited = maxNodesVisitedTracker)) {\n      loopTracker += 1;\n      if (loopTracker > 1000) {\n        return visitedNodesInOrder;\n      }\n    }\n    randomNeighbour.previousNode = closestNode;\n    closestNode = randomNeighbour;\n  }\n}\n\nfunction getRandomNeighbour(node, grid, finishNode) {\n  let neighbours = [];\n  let { row, col } = node;\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  let neighboursFilteredStartAndWall = neighbours.filter(\n    (neighbour) => !neighbour.isStart && !neighbour.isWall\n  );\n  let neighboursFilteredVisited = neighboursFilteredStartAndWall.filter(\n    (neighbour) => !neighbour.isVisited\n  );\n  if (neighboursFilteredVisited.length > 0) {\n    return neighboursFilteredVisited[\n      Math.floor(Math.random() * neighboursFilteredVisited.length)\n    ];\n  }\n  return neighboursFilteredStartAndWall[\n    Math.floor(Math.random() * neighboursFilteredStartAndWall.length)\n  ];\n}\n\nfunction numNodesVisited(grid) {\n  let count = 0;\n  for (let row of grid) {\n    for (let node of row) {\n      if (node.isVisited || node.isWall) count += 1;\n    }\n  }\n  return count;\n}\n"]},"metadata":{},"sourceType":"module"}