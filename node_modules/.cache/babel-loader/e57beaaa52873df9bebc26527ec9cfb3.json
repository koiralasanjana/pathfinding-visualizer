{"ast":null,"code":"//for all algortihms we are repeating a pattern number of times('w' times using while loop), and nodes array is being returned which has length greater than number of nodes in the grid which we are pruning(returning at that point when nodes[i]===undefined) while visualizing it.\nexport function recursiveDivision(grid, NUMBER_OF_ROWS, NUMBER_OF_COLS) {\n  let nodes = [];\n  let x = 1;\n  const row = NUMBER_OF_ROWS;\n  let w = 10; // up,right,down,right lines & then repeat w times\n\n  while (w) {\n    //up\n    for (let i = row - 2; i >= 1; i--) {\n      if (i === Math.floor((row - 2) / 1.6)) continue;\n      if (i === Math.floor((row - 2) / 2.5)) continue;\n      nodes.push(grid[i][x]);\n    }\n\n    x += 1; //right\n\n    for (let i = 0; i <= 4; i++) {\n      nodes.push(grid[1][x]);\n      x += 1;\n    } //down\n\n\n    for (let i = 1; i < row - 1; i++) {\n      if (i === Math.floor((row - 2) / 1.2)) continue;\n      if (i === Math.floor((row - 2) / 3)) continue;\n      nodes.push(grid[i][x]);\n    } //right\n\n\n    for (let i = 0; i <= 4; i++) {\n      nodes.push(grid[row - 2][x]);\n      x += 1;\n    }\n\n    w -= 1;\n  }\n\n  return nodes;\n}","map":{"version":3,"sources":["F:/Deerwalk/semester-5/Micro Project/my-project/pathfinding-visualizer-master/src/mazeAlgorithms/recursiveDivision.js"],"names":["recursiveDivision","grid","NUMBER_OF_ROWS","NUMBER_OF_COLS","nodes","x","row","w","i","Math","floor","push"],"mappings":"AAAA;AACA,OAAO,SAASA,iBAAT,CAA2BC,IAA3B,EAAiCC,cAAjC,EAAiDC,cAAjD,EAAiE;AACtE,MAAIC,KAAK,GAAG,EAAZ;AACA,MAAIC,CAAC,GAAG,CAAR;AACA,QAAMC,GAAG,GAAGJ,cAAZ;AACA,MAAIK,CAAC,GAAG,EAAR,CAJsE,CAKtE;;AACA,SAAOA,CAAP,EAAU;AACR;AACA,SAAK,IAAIC,CAAC,GAAGF,GAAG,GAAG,CAAnB,EAAsBE,CAAC,IAAI,CAA3B,EAA8BA,CAAC,EAA/B,EAAmC;AACjC,UAAIA,CAAC,KAAKC,IAAI,CAACC,KAAL,CAAW,CAACJ,GAAG,GAAG,CAAP,IAAY,GAAvB,CAAV,EAAuC;AACvC,UAAIE,CAAC,KAAKC,IAAI,CAACC,KAAL,CAAW,CAACJ,GAAG,GAAG,CAAP,IAAY,GAAvB,CAAV,EAAuC;AAEvCF,MAAAA,KAAK,CAACO,IAAN,CAAWV,IAAI,CAACO,CAAD,CAAJ,CAAQH,CAAR,CAAX;AACD;;AACDA,IAAAA,CAAC,IAAI,CAAL,CARQ,CASR;;AACA,SAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAI,CAArB,EAAwBA,CAAC,EAAzB,EAA6B;AAC3BJ,MAAAA,KAAK,CAACO,IAAN,CAAWV,IAAI,CAAC,CAAD,CAAJ,CAAQI,CAAR,CAAX;AACAA,MAAAA,CAAC,IAAI,CAAL;AACD,KAbO,CAcR;;;AACA,SAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,GAAG,GAAG,CAA1B,EAA6BE,CAAC,EAA9B,EAAkC;AAChC,UAAIA,CAAC,KAAKC,IAAI,CAACC,KAAL,CAAW,CAACJ,GAAG,GAAG,CAAP,IAAY,GAAvB,CAAV,EAAuC;AACvC,UAAIE,CAAC,KAAKC,IAAI,CAACC,KAAL,CAAW,CAACJ,GAAG,GAAG,CAAP,IAAY,CAAvB,CAAV,EAAqC;AACrCF,MAAAA,KAAK,CAACO,IAAN,CAAWV,IAAI,CAACO,CAAD,CAAJ,CAAQH,CAAR,CAAX;AACD,KAnBO,CAoBR;;;AACA,SAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAI,CAArB,EAAwBA,CAAC,EAAzB,EAA6B;AAC3BJ,MAAAA,KAAK,CAACO,IAAN,CAAWV,IAAI,CAACK,GAAG,GAAG,CAAP,CAAJ,CAAcD,CAAd,CAAX;AACAA,MAAAA,CAAC,IAAI,CAAL;AACD;;AACDE,IAAAA,CAAC,IAAI,CAAL;AACD;;AACD,SAAOH,KAAP;AACD","sourcesContent":["//for all algortihms we are repeating a pattern number of times('w' times using while loop), and nodes array is being returned which has length greater than number of nodes in the grid which we are pruning(returning at that point when nodes[i]===undefined) while visualizing it.\nexport function recursiveDivision(grid, NUMBER_OF_ROWS, NUMBER_OF_COLS) {\n  let nodes = [];\n  let x = 1;\n  const row = NUMBER_OF_ROWS;\n  let w = 10;\n  // up,right,down,right lines & then repeat w times\n  while (w) {\n    //up\n    for (let i = row - 2; i >= 1; i--) {\n      if (i === Math.floor((row - 2) / 1.6)) continue;\n      if (i === Math.floor((row - 2) / 2.5)) continue;\n\n      nodes.push(grid[i][x]);\n    }\n    x += 1;\n    //right\n    for (let i = 0; i <= 4; i++) {\n      nodes.push(grid[1][x]);\n      x += 1;\n    }\n    //down\n    for (let i = 1; i < row - 1; i++) {\n      if (i === Math.floor((row - 2) / 1.2)) continue;\n      if (i === Math.floor((row - 2) / 3)) continue;\n      nodes.push(grid[i][x]);\n    }\n    //right\n    for (let i = 0; i <= 4; i++) {\n      nodes.push(grid[row - 2][x]);\n      x += 1;\n    }\n    w -= 1;\n  }\n  return nodes;\n}\n"]},"metadata":{},"sourceType":"module"}