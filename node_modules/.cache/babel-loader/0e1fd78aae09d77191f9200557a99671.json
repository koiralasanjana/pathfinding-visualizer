{"ast":null,"code":"import _objectSpread from\"F:\\\\Deerwalk\\\\semester-5\\\\Micro Project\\\\pathfinding-visualizer\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";import _createForOfIteratorHelper from\"F:\\\\Deerwalk\\\\semester-5\\\\Micro Project\\\\pathfinding-visualizer\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";import _classCallCheck from\"F:\\\\Deerwalk\\\\semester-5\\\\Micro Project\\\\pathfinding-visualizer\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";import _createClass from\"F:\\\\Deerwalk\\\\semester-5\\\\Micro Project\\\\pathfinding-visualizer\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";import _inherits from\"F:\\\\Deerwalk\\\\semester-5\\\\Micro Project\\\\pathfinding-visualizer\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";import _createSuper from\"F:\\\\Deerwalk\\\\semester-5\\\\Micro Project\\\\pathfinding-visualizer\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";import React,{Component}from\"react\";import\"./pathfindingVisualizer.css\";import Node from\"./Node/node\";import NavBar from\"./navbar\";//Pathfinding Algorithms\nimport{dijkstra,getNodesInShortestPathOrderDijkstra}from\"../pathfindingAlgorithms/dijkstra\";//Maze Algorithms\nimport{recursiveDivisionMaze}from\"../mazeAlgorithms/recursiveDivision\";var initialNum=getInitialNum(window.innerWidth,window.innerHeight);var initialNumRows=initialNum[0];var initialNumColumns=initialNum[1];var startFinishNode=getStartFinishNode(initialNumRows,initialNumColumns);var startNodeRow=startFinishNode[0];var startNodeCol=startFinishNode[1];var finishNodeRow=startFinishNode[2];var finishNodeCol=startFinishNode[3];var PathfindingVisualizer=/*#__PURE__*/function(_Component){_inherits(PathfindingVisualizer,_Component);var _super=_createSuper(PathfindingVisualizer);function PathfindingVisualizer(){var _this;_classCallCheck(this,PathfindingVisualizer);for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_super.call.apply(_super,[this].concat(args));_this.state={grid:[],mouseIsPressed:false,visualizingAlgorithm:false,generatingMaze:false,width:window.innerWidth,height:window.innerHeight,numRows:initialNumRows,numColumns:initialNumColumns,speed:10,mazeSpeed:10};_this.updateDimensions=function(){_this.setState({width:window.innerWidth,height:window.innerHeight});};_this.updateSpeed=function(path,maze){_this.setState({speed:path,mazeSpeed:maze});};_this.animateShortestPath=function(nodesInShortestPathOrder,visitedNodesInOrder){if(nodesInShortestPathOrder.length===1)_this.setState({visualizingAlgorithm:false});var _loop=function _loop(i){if(i===nodesInShortestPathOrder.length-1){setTimeout(function(){var newGrid=updateNodesForRender(_this.state.grid,nodesInShortestPathOrder,visitedNodesInOrder);_this.setState({grid:newGrid,visualizingAlgorithm:false});},i*(3*_this.state.speed));return{v:void 0};}var node=nodesInShortestPathOrder[i];setTimeout(function(){//shortest path node\ndocument.getElementById(\"node-\".concat(node.row,\"-\").concat(node.col)).className=\"node node-shortest-path\";},i*(3*_this.state.speed));};for(var i=1;i<nodesInShortestPathOrder.length;i++){var _ret=_loop(i);if(typeof _ret===\"object\")return _ret.v;}};_this.animateAlgorithm=function(visitedNodesInOrder,nodesInShortestPathOrder){var newGrid=_this.state.grid.slice();var _iterator=_createForOfIteratorHelper(newGrid),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var row=_step.value;var _iterator2=_createForOfIteratorHelper(row),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var node=_step2.value;var newNode=_objectSpread(_objectSpread({},node),{},{isVisited:false});newGrid[node.row][node.col]=newNode;}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}}}catch(err){_iterator.e(err);}finally{_iterator.f();}_this.setState({grid:newGrid});var _loop2=function _loop2(i){var node=visitedNodesInOrder[i];if(i===visitedNodesInOrder.length){setTimeout(function(){_this.animateShortestPath(nodesInShortestPathOrder,visitedNodesInOrder);},i*_this.state.speed);return{v:void 0};}setTimeout(function(){//visited node\ndocument.getElementById(\"node-\".concat(node.row,\"-\").concat(node.col)).className=\"node node-visited\";},i*_this.state.speed);};for(var i=1;i<=visitedNodesInOrder.length;i++){var _ret2=_loop2(i);if(typeof _ret2===\"object\")return _ret2.v;}};_this.animateMaze=function(walls){var _loop3=function _loop3(i){if(i===walls.length){setTimeout(function(){_this.clearGrid();var newGrid=getNewGridWithMaze(_this.state.grid,walls);_this.setState({grid:newGrid,generatingMaze:false});},i*_this.state.mazeSpeed);return{v:void 0};}var wall=walls[i];var node=_this.state.grid[wall[0]][wall[1]];setTimeout(function(){//Walls\ndocument.getElementById(\"node-\".concat(node.row,\"-\").concat(node.col)).className=\"node node-wall-animated\";},i*_this.state.mazeSpeed);};for(var i=0;i<=walls.length;i++){var _ret3=_loop3(i);if(typeof _ret3===\"object\")return _ret3.v;}};return _this;}_createClass(PathfindingVisualizer,[{key:\"componentDidMount\",value:function componentDidMount(){window.addEventListener(\"resize\",this.updateDimensions);var grid=getInitialGrid(this.state.numRows,this.state.numColumns);this.setState({grid:grid});}},{key:\"handleMouseDown\",value:function handleMouseDown(row,col){var newGrid=getNewGridWithWalls(this.state.grid,row,col);this.setState({grid:newGrid,mouseIsPressed:true});}},{key:\"handleMouseEnter\",value:function handleMouseEnter(row,col){if(this.state.mouseIsPressed){var newGrid=getNewGridWithWalls(this.state.grid,row,col);this.setState({grid:newGrid,mouseIsPressed:true});}}},{key:\"handleMouseUp\",value:function handleMouseUp(){this.setState({mouseIsPressed:false});}},{key:\"clearGrid\",value:function clearGrid(){if(this.state.visualizingAlgorithm||this.state.generatingMaze){return;}for(var row=0;row<this.state.grid.length;row++){for(var col=0;col<this.state.grid[0].length;col++){if(!(row===startNodeRow&&col===startNodeCol||row===finishNodeRow&&col===finishNodeCol)){document.getElementById(\"node-\".concat(row,\"-\").concat(col)).className=\"node\";}}}var newGrid=getInitialGrid(this.state.numRows,this.state.numColumns);this.setState({grid:newGrid,visualizingAlgorithm:false,generatingMaze:false});}},{key:\"clearPath\",value:function clearPath(){if(this.state.visualizingAlgorithm||this.state.generatingMaze){return;}for(var row=0;row<this.state.grid.length;row++){for(var col=0;col<this.state.grid[0].length;col++){if(document.getElementById(\"node-\".concat(row,\"-\").concat(col)).className===\"node node-shortest-path\"){document.getElementById(\"node-\".concat(row,\"-\").concat(col)).className=\"node\";}}}var newGrid=getGridWithoutPath(this.state.grid);this.setState({grid:newGrid,visualizingAlgorithm:false,generatingMaze:false});}},{key:\"visualizeDijkstra\",value:function visualizeDijkstra(){var _this2=this;if(this.state.visualizingAlgorithm||this.state.generatingMaze){return;}this.setState({visualizingAlgorithm:true});setTimeout(function(){var grid=_this2.state.grid;var startNode=grid[startNodeRow][startNodeCol];var finishNode=grid[finishNodeRow][finishNodeCol];var visitedNodesInOrder=dijkstra(grid,startNode,finishNode);var nodesInShortestPathOrder=getNodesInShortestPathOrderDijkstra(finishNode);_this2.animateAlgorithm(visitedNodesInOrder,nodesInShortestPathOrder);},this.state.speed);}},{key:\"generateRecursiveDivisionMaze\",value:function generateRecursiveDivisionMaze(){var _this3=this;if(this.state.visualizingAlgorithm||this.state.generatingMaze){return;}this.setState({generatingMaze:true});setTimeout(function(){var grid=_this3.state.grid;var startNode=grid[startNodeRow][startNodeCol];var finishNode=grid[finishNodeRow][finishNodeCol];var walls=recursiveDivisionMaze(grid,startNode,finishNode);_this3.animateMaze(walls);},this.state.mazeSpeed);}},{key:\"render\",value:function render(){var _this4=this;var grid=this.state.grid;return/*#__PURE__*/React.createElement(React.Fragment,null,/*#__PURE__*/React.createElement(NavBar,{visualizingAlgorithm:this.state.visualizingAlgorithm,generatingMaze:this.state.generatingMaze,visualizeDijkstra:this.visualizeDijkstra.bind(this),generateRecursiveDivisionMaze:this.generateRecursiveDivisionMaze.bind(this),clearGrid:this.clearGrid.bind(this),clearPath:this.clearPath.bind(this),updateSpeed:this.updateSpeed.bind(this)}),/*#__PURE__*/React.createElement(\"div\",{className:this.state.visualizingAlgorithm||this.state.generatingMaze?\"grid-visualizing\":\"grid\"},grid.map(function(row,rowId){return/*#__PURE__*/React.createElement(\"div\",{key:rowId},row.map(function(node,nodeId){var row=node.row,col=node.col,isStart=node.isStart,isFinish=node.isFinish,isVisited=node.isVisited,isShortest=node.isShortest,isWall=node.isWall;return/*#__PURE__*/React.createElement(Node,{key:nodeId,row:row,col:col,isStart:isStart,isFinish:isFinish,isVisited:isVisited,isShortest:isShortest,isWall:isWall,onMouseDown:function onMouseDown(row,col){return _this4.handleMouseDown(row,col);},onMouseEnter:function onMouseEnter(row,col){return _this4.handleMouseEnter(row,col);},onMouseUp:function onMouseUp(){return _this4.handleMouseUp();},width:_this4.state.width,height:_this4.state.height,numRows:_this4.state.numRows,numColumns:_this4.state.numColumns});}));})),/*#__PURE__*/React.createElement(\"div\",{className:\"learn\",id:\"learn\"},/*#__PURE__*/React.createElement(\"h1\",{class:\"learn_header\"},\"Dijkstra's Algorithm\"),/*#__PURE__*/React.createElement(\"hr\",null),/*#__PURE__*/React.createElement(\"br\",null),/*#__PURE__*/React.createElement(\"p\",{class:\"learn_intro\"},/*#__PURE__*/React.createElement(\"strong\",null,\"Dijkstra's Algorithm\"),\" basically starts at the node that you choose (the source node) and it analyzes the graph to find the shortest path between that node and all the other nodes in the graph. The algorithm keeps track of the currently known shortest distance from each node to the source node and it updates these values if it finds a shorter path. Once the algorithm has found the shortest path between the source node and another node, that node is marked as \\\"visited\\\" and added to the path. The process continues until all the nodes in the graph have been added to the path. This way, we have a path that connects the source node to all other nodes following the shortest path possible to reach each node.\"),/*#__PURE__*/React.createElement(\"h3\",{class:\"algo\"},\"Algorithm:\"),/*#__PURE__*/React.createElement(\"div\",{class:\"algo_content\"},\"1) Create a set sptSet (shortest path tree set) that keeps track of vertices included in the shortest-path tree, i.e., whose minimum distance from the source is calculated and finalized. Initially, this set is empty. \",/*#__PURE__*/React.createElement(\"br\",null),\"2) Assign a distance value to all vertices in the input graph. Initialize all distance values as INFINITE. Assign distance value as 0 for the source vertex so that it is picked first. \",/*#__PURE__*/React.createElement(\"br\",null),\"3) While sptSet doesn\\u2019t include all vertices \",/*#__PURE__*/React.createElement(\"br\",null),\"\\u2026.a) Pick a vertex u which is not there in sptSet and has a minimum distance value. \",/*#__PURE__*/React.createElement(\"br\",null),\"\\u2026.b) Include u to sptSet. \",/*#__PURE__*/React.createElement(\"br\",null),\"\\u2026.c) Update distance value of all adjacent vertices of u. \",/*#__PURE__*/React.createElement(\"br\",null),\"To update the distance values, iterate through all adjacent vertices. For every adjacent vertex v, if the sum of distance value of u (from source) and weight of edge u-v, is less than the distance value of v, then update the distance value of v. \",/*#__PURE__*/React.createElement(\"br\",null))));}}]);return PathfindingVisualizer;}(Component);function getInitialNum(width,height){var numColumns;if(width>1500){numColumns=Math.floor(width/25);}else if(width>1250){numColumns=Math.floor(width/22.5);}else if(width>1000){numColumns=Math.floor(width/20);}else if(width>750){numColumns=Math.floor(width/17.5);}else if(width>500){numColumns=Math.floor(width/15);}else if(width>250){numColumns=Math.floor(width/12.5);}else if(width>0){numColumns=Math.floor(width/10);}var cellWidth=Math.floor(width/numColumns);var numRows=Math.floor(height/cellWidth);return[numRows,numColumns];}function getRandomNums(num){var randomNums1=[];var temp=2;for(var i=5;i<num/2;i+=2){randomNums1.push(temp);temp+=2;}var randomNums2=[];temp=-2;for(var _i=num/2;_i<num-5;_i+=2){randomNums2.push(temp);temp-=2;}return[randomNums1,randomNums2];}function getStartFinishNode(numRows,numColumns){var randomNums;var x;var y;var startNodeRow;var startNodeCol;var finishNodeRow;var finishNodeCol;if(numRows<numColumns){randomNums=getRandomNums(numRows);x=Math.floor(numRows/2);y=Math.floor(numColumns/4);if(x%2!==0)x-=1;if(y%2!==0)y+=1;startNodeRow=x+randomNums[1][Math.floor(Math.random()*randomNums[1].length)];startNodeCol=y+[-6,-4,-2,0][Math.floor(Math.random()*4)];finishNodeRow=x+randomNums[0][Math.floor(Math.random()*randomNums[0].length)];finishNodeCol=numColumns-y+[0,2,4,6][Math.floor(Math.random()*4)];}else{randomNums=getRandomNums(numColumns);x=Math.floor(numRows/4);y=Math.floor(numColumns/2);if(x%2!==0)x-=1;if(y%2!==0)y+=1;startNodeRow=x+[-6,-4,-2,0][Math.floor(Math.random()*4)];startNodeCol=y+randomNums[1][Math.floor(Math.random()*randomNums[1].length)];finishNodeRow=numRows-x+[0,2,4,6][Math.floor(Math.random()*4)];finishNodeCol=y+randomNums[0][Math.floor(Math.random()*randomNums[0].length)];}return[startNodeRow,startNodeCol,finishNodeRow,finishNodeCol];}var getInitialGrid=function getInitialGrid(numRows,numColumns){var grid=[];for(var row=0;row<numRows;row++){var currentRow=[];for(var col=0;col<numColumns;col++){currentRow.push(createNode(row,col));}grid.push(currentRow);}return grid;};var createNode=function createNode(row,col){return{row:row,col:col,isStart:row===startNodeRow&&col===startNodeCol,isFinish:row===finishNodeRow&&col===finishNodeCol,distance:Infinity,totalDistance:Infinity,isVisited:false,isShortest:false,isWall:false,previousNode:null};};var getNewGridWithWalls=function getNewGridWithWalls(grid,row,col){var newGrid=grid.slice();var node=grid[row][col];var newNode=_objectSpread(_objectSpread({},node),{},{isWall:!node.isWall});newGrid[row][col]=newNode;return newGrid;};var getNewGridWithMaze=function getNewGridWithMaze(grid,walls){var newGrid=grid.slice();var _iterator3=_createForOfIteratorHelper(walls),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var wall=_step3.value;var node=grid[wall[0]][wall[1]];var newNode=_objectSpread(_objectSpread({},node),{},{isWall:true});newGrid[wall[0]][wall[1]]=newNode;}}catch(err){_iterator3.e(err);}finally{_iterator3.f();}return newGrid;};var getGridWithoutPath=function getGridWithoutPath(grid){var newGrid=grid.slice();var _iterator4=_createForOfIteratorHelper(grid),_step4;try{for(_iterator4.s();!(_step4=_iterator4.n()).done;){var row=_step4.value;var _iterator5=_createForOfIteratorHelper(row),_step5;try{for(_iterator5.s();!(_step5=_iterator5.n()).done;){var node=_step5.value;var newNode=_objectSpread(_objectSpread({},node),{},{distance:Infinity,totalDistance:Infinity,isVisited:false,isShortest:false,previousNode:null});newGrid[node.row][node.col]=newNode;}}catch(err){_iterator5.e(err);}finally{_iterator5.f();}}}catch(err){_iterator4.e(err);}finally{_iterator4.f();}return newGrid;};var updateNodesForRender=function updateNodesForRender(grid,nodesInShortestPathOrder,visitedNodesInOrder){var newGrid=grid.slice();var _iterator6=_createForOfIteratorHelper(visitedNodesInOrder),_step6;try{for(_iterator6.s();!(_step6=_iterator6.n()).done;){var node=_step6.value;if(node.row===startNodeRow&&node.col===startNodeCol||node.row===finishNodeRow&&node.col===finishNodeCol)continue;var newNode=_objectSpread(_objectSpread({},node),{},{isVisited:true});newGrid[node.row][node.col]=newNode;}}catch(err){_iterator6.e(err);}finally{_iterator6.f();}var _iterator7=_createForOfIteratorHelper(nodesInShortestPathOrder),_step7;try{for(_iterator7.s();!(_step7=_iterator7.n()).done;){var _node=_step7.value;if(_node.row===finishNodeRow&&_node.col===finishNodeCol){return newGrid;}var _newNode=_objectSpread(_objectSpread({},_node),{},{isVisited:false,isShortest:true});newGrid[_node.row][_node.col]=_newNode;}}catch(err){_iterator7.e(err);}finally{_iterator7.f();}};var getVisitedNodesInOrder=function getVisitedNodesInOrder(visitedNodesInOrderStart,visitedNodesInOrderFinish){var visitedNodesInOrder=[];var n=Math.max(visitedNodesInOrderStart.length,visitedNodesInOrderFinish.length);for(var i=0;i<n;i++){if(visitedNodesInOrderStart[i]!==undefined){visitedNodesInOrder.push(visitedNodesInOrderStart[i]);}if(visitedNodesInOrderFinish[i]!==undefined){visitedNodesInOrder.push(visitedNodesInOrderFinish[i]);}}return visitedNodesInOrder;};export default PathfindingVisualizer;","map":{"version":3,"sources":["F:/Deerwalk/semester-5/Micro Project/pathfinding-visualizer/src/pathfindingVisualizer/pathfindingVisualizer.jsx"],"names":["React","Component","Node","NavBar","dijkstra","getNodesInShortestPathOrderDijkstra","recursiveDivisionMaze","initialNum","getInitialNum","window","innerWidth","innerHeight","initialNumRows","initialNumColumns","startFinishNode","getStartFinishNode","startNodeRow","startNodeCol","finishNodeRow","finishNodeCol","PathfindingVisualizer","state","grid","mouseIsPressed","visualizingAlgorithm","generatingMaze","width","height","numRows","numColumns","speed","mazeSpeed","updateDimensions","setState","updateSpeed","path","maze","animateShortestPath","nodesInShortestPathOrder","visitedNodesInOrder","length","i","setTimeout","newGrid","updateNodesForRender","node","document","getElementById","row","col","className","animateAlgorithm","slice","newNode","isVisited","animateMaze","walls","clearGrid","getNewGridWithMaze","wall","addEventListener","getInitialGrid","getNewGridWithWalls","getGridWithoutPath","startNode","finishNode","visualizeDijkstra","bind","generateRecursiveDivisionMaze","clearPath","map","rowId","nodeId","isStart","isFinish","isShortest","isWall","handleMouseDown","handleMouseEnter","handleMouseUp","Math","floor","cellWidth","getRandomNums","num","randomNums1","temp","push","randomNums2","randomNums","x","y","random","currentRow","createNode","distance","Infinity","totalDistance","previousNode","getVisitedNodesInOrder","visitedNodesInOrderStart","visitedNodesInOrderFinish","n","max","undefined"],"mappings":"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","sourcesContent":["import React, { Component } from \"react\";\nimport \"./pathfindingVisualizer.css\";\nimport Node from \"./Node/node\";\nimport NavBar from \"./navbar\";\n\n//Pathfinding Algorithms\nimport {\n  dijkstra,\n  getNodesInShortestPathOrderDijkstra,\n} from \"../pathfindingAlgorithms/dijkstra\";\n\n\n//Maze Algorithms\nimport { recursiveDivisionMaze } from \"../mazeAlgorithms/recursiveDivision\";\n\nconst initialNum = getInitialNum(window.innerWidth, window.innerHeight);\nconst initialNumRows = initialNum[0];\nconst initialNumColumns = initialNum[1];\n\nconst startFinishNode = getStartFinishNode(initialNumRows, initialNumColumns);\nconst startNodeRow = startFinishNode[0];\nconst startNodeCol = startFinishNode[1];\nconst finishNodeRow = startFinishNode[2];\nconst finishNodeCol = startFinishNode[3];\n\nclass PathfindingVisualizer extends Component {\n  state = {\n    grid: [],\n    mouseIsPressed: false,\n    visualizingAlgorithm: false,\n    generatingMaze: false,\n    width: window.innerWidth,\n    height: window.innerHeight,\n    numRows: initialNumRows,\n    numColumns: initialNumColumns,\n    speed: 10,\n    mazeSpeed: 10,\n  };\n\n  updateDimensions = () => {\n    this.setState({\n      width: window.innerWidth,\n      height: window.innerHeight,\n    });\n  };\n\n  updateSpeed = (path, maze) => {\n    this.setState({ speed: path, mazeSpeed: maze });\n  };\n\n  componentDidMount() {\n    window.addEventListener(\"resize\", this.updateDimensions);\n    const grid = getInitialGrid(this.state.numRows, this.state.numColumns);\n    this.setState({ grid });\n  }\n\n  handleMouseDown(row, col) {\n    const newGrid = getNewGridWithWalls(this.state.grid, row, col);\n    this.setState({ grid: newGrid, mouseIsPressed: true });\n  }\n\n  handleMouseEnter(row, col) {\n    if (this.state.mouseIsPressed) {\n      const newGrid = getNewGridWithWalls(this.state.grid, row, col);\n      this.setState({ grid: newGrid, mouseIsPressed: true });\n    }\n  }\n\n  handleMouseUp() {\n    this.setState({ mouseIsPressed: false });\n  }\n\n  clearGrid() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n    for (let row = 0; row < this.state.grid.length; row++) {\n      for (let col = 0; col < this.state.grid[0].length; col++) {\n        if (\n          !(\n            (row === startNodeRow && col === startNodeCol) ||\n            (row === finishNodeRow && col === finishNodeCol)\n          )\n        ) {\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\n        }\n      }\n    }\n    const newGrid = getInitialGrid(this.state.numRows, this.state.numColumns);\n    this.setState({\n      grid: newGrid,\n      visualizingAlgorithm: false,\n      generatingMaze: false,\n    });\n  }\n\n  clearPath() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n    for (let row = 0; row < this.state.grid.length; row++) {\n      for (let col = 0; col < this.state.grid[0].length; col++) {\n        if (\n          document.getElementById(`node-${row}-${col}`).className ===\n          \"node node-shortest-path\"\n        ) {\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\n        }\n      }\n    }\n    const newGrid = getGridWithoutPath(this.state.grid);\n    this.setState({\n      grid: newGrid,\n      visualizingAlgorithm: false,\n      generatingMaze: false,\n    });\n  }\n\n  animateShortestPath = (nodesInShortestPathOrder, visitedNodesInOrder) => {\n    if (nodesInShortestPathOrder.length === 1)\n      this.setState({ visualizingAlgorithm: false });\n    for (let i = 1; i < nodesInShortestPathOrder.length; i++) {\n      if (i === nodesInShortestPathOrder.length - 1) {\n        setTimeout(() => {\n          let newGrid = updateNodesForRender(\n            this.state.grid,\n            nodesInShortestPathOrder,\n            visitedNodesInOrder\n          );\n          this.setState({ grid: newGrid, visualizingAlgorithm: false });\n        }, i * (3 * this.state.speed));\n        return;\n      }\n      let node = nodesInShortestPathOrder[i];\n      setTimeout(() => {\n        //shortest path node\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-shortest-path\";\n      }, i * (3 * this.state.speed));\n    }\n  };\n\n  animateAlgorithm = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n    let newGrid = this.state.grid.slice();\n    for (let row of newGrid) {\n      for (let node of row) {\n        let newNode = {\n          ...node,\n          isVisited: false,\n        };\n        newGrid[node.row][node.col] = newNode;\n      }\n    }\n    this.setState({ grid: newGrid });\n    for (let i = 1; i <= visitedNodesInOrder.length; i++) {\n      let node = visitedNodesInOrder[i];\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(\n            nodesInShortestPathOrder,\n            visitedNodesInOrder\n          );\n        }, i * this.state.speed);\n        return;\n      }\n      setTimeout(() => {\n        //visited node\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-visited\";\n      }, i * this.state.speed);\n    }\n  };\n\n  visualizeDijkstra() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n    this.setState({ visualizingAlgorithm: true });\n    setTimeout(() => {\n      const { grid } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n      const nodesInShortestPathOrder = getNodesInShortestPathOrderDijkstra(\n        finishNode\n      );\n      this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, this.state.speed);\n  }\n\n\n  animateMaze = (walls) => {\n    for (let i = 0; i <= walls.length; i++) {\n      if (i === walls.length) {\n        setTimeout(() => {\n          this.clearGrid();\n          let newGrid = getNewGridWithMaze(this.state.grid, walls);\n          this.setState({ grid: newGrid, generatingMaze: false });\n        }, i * this.state.mazeSpeed);\n        return;\n      }\n      let wall = walls[i];\n      let node = this.state.grid[wall[0]][wall[1]];\n      setTimeout(() => {\n        //Walls\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-wall-animated\";\n      }, i * this.state.mazeSpeed);\n    }\n  };\n\n\n\n  generateRecursiveDivisionMaze() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n    this.setState({ generatingMaze: true });\n    setTimeout(() => {\n      const { grid } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const walls = recursiveDivisionMaze(grid, startNode, finishNode);\n      this.animateMaze(walls);\n    }, this.state.mazeSpeed);\n  }\n\n  render() {\n    let { grid } = this.state;\n    return (\n      <React.Fragment>\n        <NavBar\n          visualizingAlgorithm={this.state.visualizingAlgorithm}\n          generatingMaze={this.state.generatingMaze}\n          visualizeDijkstra={this.visualizeDijkstra.bind(this)}\n          generateRecursiveDivisionMaze={this.generateRecursiveDivisionMaze.bind( this)}\n          clearGrid={this.clearGrid.bind(this)}\n          clearPath={this.clearPath.bind(this)}\n          updateSpeed={this.updateSpeed.bind(this)}\n        />\n\n        <div\n          className={\n            this.state.visualizingAlgorithm || this.state.generatingMaze\n              ? \"grid-visualizing\"\n              : \"grid\"\n          }\n        >\n          {grid.map((row, rowId) => {\n            return (\n              <div key={rowId}>\n                {row.map((node, nodeId) => {\n                  const {\n                    row,\n                    col,\n                    isStart,\n                    isFinish,\n                    isVisited,\n                    isShortest,\n                    isWall,\n                  } = node;\n                  return (\n                    <Node\n                      key={nodeId}\n                      row={row}\n                      col={col}\n                      isStart={isStart}\n                      isFinish={isFinish}\n                      isVisited={isVisited}\n                      isShortest={isShortest}\n                      isWall={isWall}\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                      onMouseEnter={(row, col) =>\n                        this.handleMouseEnter(row, col)\n                      }\n                      onMouseUp={() => this.handleMouseUp()}\n                      width={this.state.width}\n                      height={this.state.height}\n                      numRows={this.state.numRows}\n                      numColumns={this.state.numColumns}\n                    ></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n        <div className=\"learn\" id=\"learn\">\n        <h1 class=\"learn_header\">Dijkstra's Algorithm</h1><hr></hr><br></br>\n          <p class=\"learn_intro\"><strong>Dijkstra's Algorithm</strong> basically starts at the node that you choose (the source node) and it analyzes the graph to find the shortest path between that node and all the other nodes in the graph.\nThe algorithm keeps track of the currently known shortest distance from each node to the source node and it updates these values if it finds a shorter path.\nOnce the algorithm has found the shortest path between the source node and another node, that node is marked as \"visited\" and added to the path.\nThe process continues until all the nodes in the graph have been added to the path. This way, we have a path that connects the source node to all other nodes following the shortest path possible to reach each node.</p>\n\n          <h3 class=\"algo\">Algorithm:</h3>\n          <div class=\"algo_content\">\n          1) Create a set sptSet (shortest path tree set) that keeps track of vertices included in the shortest-path tree, i.e., whose minimum distance from the source is calculated and finalized. Initially, this set is empty. <br></br>\n2) Assign a distance value to all vertices in the input graph. Initialize all distance values as INFINITE. Assign distance value as 0 for the source vertex so that it is picked first. <br></br>\n3) While sptSet doesn’t include all vertices <br></br>\n….a) Pick a vertex u which is not there in sptSet and has a minimum distance value. <br></br>\n….b) Include u to sptSet. <br></br>\n….c) Update distance value of all adjacent vertices of u. <br></br>To update the distance values, iterate through all adjacent vertices. For every adjacent vertex v, if the sum of distance value of u (from source) and weight of edge u-v, is less than the distance value of v, then update the distance value of v. <br></br>\n          </div>\n          </div>\n      </React.Fragment>\n    );\n    \n  }\n}\n\nfunction getInitialNum(width, height) {\n  let numColumns;\n  if (width > 1500) {\n    numColumns = Math.floor(width / 25);\n  } else if (width > 1250) {\n    numColumns = Math.floor(width / 22.5);\n  } else if (width > 1000) {\n    numColumns = Math.floor(width / 20);\n  } else if (width > 750) {\n    numColumns = Math.floor(width / 17.5);\n  } else if (width > 500) {\n    numColumns = Math.floor(width / 15);\n  } else if (width > 250) {\n    numColumns = Math.floor(width / 12.5);\n  } else if (width > 0) {\n    numColumns = Math.floor(width / 10);\n  }\n  let cellWidth = Math.floor(width / numColumns);\n  let numRows = Math.floor(height / cellWidth);\n  return [numRows, numColumns];\n}\n\nfunction getRandomNums(num) {\n  let randomNums1 = [];\n  let temp = 2;\n  for (let i = 5; i < num / 2; i += 2) {\n    randomNums1.push(temp);\n    temp += 2;\n  }\n  let randomNums2 = [];\n  temp = -2;\n  for (let i = num / 2; i < num - 5; i += 2) {\n    randomNums2.push(temp);\n    temp -= 2;\n  }\n  return [randomNums1, randomNums2];\n}\n\nfunction getStartFinishNode(numRows, numColumns) {\n  let randomNums;\n  let x;\n  let y;\n  let startNodeRow;\n  let startNodeCol;\n  let finishNodeRow;\n  let finishNodeCol;\n  if (numRows < numColumns) {\n    randomNums = getRandomNums(numRows);\n    x = Math.floor(numRows / 2);\n    y = Math.floor(numColumns / 4);\n    if (x % 2 !== 0) x -= 1;\n    if (y % 2 !== 0) y += 1;\n    startNodeRow =\n      x + randomNums[1][Math.floor(Math.random() * randomNums[1].length)];\n    startNodeCol = y + [-6, -4, -2, 0][Math.floor(Math.random() * 4)];\n    finishNodeRow =\n      x + randomNums[0][Math.floor(Math.random() * randomNums[0].length)];\n    finishNodeCol =\n      numColumns - y + [0, 2, 4, 6][Math.floor(Math.random() * 4)];\n  } else {\n    randomNums = getRandomNums(numColumns);\n    x = Math.floor(numRows / 4);\n    y = Math.floor(numColumns / 2);\n    if (x % 2 !== 0) x -= 1;\n    if (y % 2 !== 0) y += 1;\n    startNodeRow = x + [-6, -4, -2, 0][Math.floor(Math.random() * 4)];\n    startNodeCol =\n      y + randomNums[1][Math.floor(Math.random() * randomNums[1].length)];\n    finishNodeRow = numRows - x + [0, 2, 4, 6][Math.floor(Math.random() * 4)];\n    finishNodeCol =\n      y + randomNums[0][Math.floor(Math.random() * randomNums[0].length)];\n  }\n  return [startNodeRow, startNodeCol, finishNodeRow, finishNodeCol];\n}\n\nconst getInitialGrid = (numRows, numColumns) => {\n  let grid = [];\n  for (let row = 0; row < numRows; row++) {\n    let currentRow = [];\n    for (let col = 0; col < numColumns; col++) {\n      currentRow.push(createNode(row, col));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (row, col) => {\n  return {\n    row,\n    col,\n    isStart: row === startNodeRow && col === startNodeCol,\n    isFinish: row === finishNodeRow && col === finishNodeCol,\n    distance: Infinity,\n    totalDistance: Infinity,\n    isVisited: false,\n    isShortest: false,\n    isWall: false,\n    previousNode: null,\n  };\n};\n\nconst getNewGridWithWalls = (grid, row, col) => {\n  let newGrid = grid.slice();\n  let node = grid[row][col];\n  let newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst getNewGridWithMaze = (grid, walls) => {\n  let newGrid = grid.slice();\n  for (let wall of walls) {\n    let node = grid[wall[0]][wall[1]];\n    let newNode = {\n      ...node,\n      isWall: true,\n    };\n    newGrid[wall[0]][wall[1]] = newNode;\n  }\n  return newGrid;\n};\n\nconst getGridWithoutPath = (grid) => {\n  let newGrid = grid.slice();\n  for (let row of grid) {\n    for (let node of row) {\n      let newNode = {\n        ...node,\n        distance: Infinity,\n        totalDistance: Infinity,\n        isVisited: false,\n        isShortest: false,\n        previousNode: null,\n      };\n      newGrid[node.row][node.col] = newNode;\n    }\n  }\n  return newGrid;\n};\n\nconst updateNodesForRender = (\n  grid,\n  nodesInShortestPathOrder,\n  visitedNodesInOrder\n) => {\n  let newGrid = grid.slice();\n  for (let node of visitedNodesInOrder) {\n    if (\n      (node.row === startNodeRow && node.col === startNodeCol) ||\n      (node.row === finishNodeRow && node.col === finishNodeCol)\n    )\n      continue;\n    let newNode = {\n      ...node,\n      isVisited: true,\n    };\n    newGrid[node.row][node.col] = newNode;\n  }\n  for (let node of nodesInShortestPathOrder) {\n    if (node.row === finishNodeRow && node.col === finishNodeCol) {\n      return newGrid;\n    }\n    let newNode = {\n      ...node,\n      isVisited: false,\n      isShortest: true,\n    };\n    newGrid[node.row][node.col] = newNode;\n  }\n};\n\nconst getVisitedNodesInOrder = (\n  visitedNodesInOrderStart,\n  visitedNodesInOrderFinish\n) => {\n  let visitedNodesInOrder = [];\n  let n = Math.max(\n    visitedNodesInOrderStart.length,\n    visitedNodesInOrderFinish.length\n  );\n  for (let i = 0; i < n; i++) {\n    if (visitedNodesInOrderStart[i] !== undefined) {\n      visitedNodesInOrder.push(visitedNodesInOrderStart[i]);\n    }\n    if (visitedNodesInOrderFinish[i] !== undefined) {\n      visitedNodesInOrder.push(visitedNodesInOrderFinish[i]);\n    }\n  }\n  return visitedNodesInOrder;\n};\n\n\n\nexport default PathfindingVisualizer;\n\n\n"]},"metadata":{},"sourceType":"module"}