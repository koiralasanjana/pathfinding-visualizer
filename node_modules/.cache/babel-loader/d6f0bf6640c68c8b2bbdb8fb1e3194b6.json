{"ast":null,"code":"var _jsxFileName = \"F:\\\\Deerwalk\\\\semester-5\\\\Micro Project\\\\pathfinding-visualizer-master\\\\src\\\\pathfindingVisualizer\\\\pathfindingVisualizer.jsx\";\nimport React, { Component } from \"react\";\nimport \"./pathfindingVisualizer.css\";\nimport Node from \"./Node/node\";\nimport NavBar from \"./navbar\"; //Pathfinding Algorithms\n\nimport { dijkstra, getNodesInShortestPathOrderDijkstra } from \"../pathfindingAlgorithms/dijkstra\"; //Maze Algorithms\n\nimport { recursiveDivisionMaze } from \"../mazeAlgorithms/recursiveDivision\";\nconst initialNum = getInitialNum(window.innerWidth, window.innerHeight);\nconst initialNumRows = initialNum[0];\nconst initialNumColumns = initialNum[1];\nconst startFinishNode = getStartFinishNode(initialNumRows, initialNumColumns);\nconst startNodeRow = startFinishNode[0];\nconst startNodeCol = startFinishNode[1];\nconst finishNodeRow = startFinishNode[2];\nconst finishNodeCol = startFinishNode[3];\n\nclass PathfindingVisualizer extends Component {\n  constructor(...args) {\n    super(...args);\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n      visualizingAlgorithm: false,\n      generatingMaze: false,\n      width: window.innerWidth,\n      height: window.innerHeight,\n      numRows: initialNumRows,\n      numColumns: initialNumColumns,\n      speed: 10,\n      mazeSpeed: 10\n    };\n\n    this.updateDimensions = () => {\n      this.setState({\n        width: window.innerWidth,\n        height: window.innerHeight\n      });\n    };\n\n    this.updateSpeed = (path, maze) => {\n      this.setState({\n        speed: path,\n        mazeSpeed: maze\n      });\n    };\n\n    this.animateShortestPath = (nodesInShortestPathOrder, visitedNodesInOrder) => {\n      if (nodesInShortestPathOrder.length === 1) this.setState({\n        visualizingAlgorithm: false\n      });\n\n      for (let i = 1; i < nodesInShortestPathOrder.length; i++) {\n        if (i === nodesInShortestPathOrder.length - 1) {\n          setTimeout(() => {\n            let newGrid = updateNodesForRender(this.state.grid, nodesInShortestPathOrder, visitedNodesInOrder);\n            this.setState({\n              grid: newGrid,\n              visualizingAlgorithm: false\n            });\n          }, i * (3 * this.state.speed));\n          return;\n        }\n\n        let node = nodesInShortestPathOrder[i];\n        setTimeout(() => {\n          //shortest path node\n          document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-shortest-path\";\n        }, i * (3 * this.state.speed));\n      }\n    };\n\n    this.animateAlgorithm = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n      let newGrid = this.state.grid.slice();\n\n      for (let row of newGrid) {\n        for (let node of row) {\n          let newNode = { ...node,\n            isVisited: false\n          };\n          newGrid[node.row][node.col] = newNode;\n        }\n      }\n\n      this.setState({\n        grid: newGrid\n      });\n\n      for (let i = 1; i <= visitedNodesInOrder.length; i++) {\n        let node = visitedNodesInOrder[i];\n\n        if (i === visitedNodesInOrder.length) {\n          setTimeout(() => {\n            this.animateShortestPath(nodesInShortestPathOrder, visitedNodesInOrder);\n          }, i * this.state.speed);\n          return;\n        }\n\n        setTimeout(() => {\n          //visited node\n          document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-visited\";\n        }, i * this.state.speed);\n      }\n    };\n\n    this.animateMaze = walls => {\n      for (let i = 0; i <= walls.length; i++) {\n        if (i === walls.length) {\n          setTimeout(() => {\n            this.clearGrid();\n            let newGrid = getNewGridWithMaze(this.state.grid, walls);\n            this.setState({\n              grid: newGrid,\n              generatingMaze: false\n            });\n          }, i * this.state.mazeSpeed);\n          return;\n        }\n\n        let wall = walls[i];\n        let node = this.state.grid[wall[0]][wall[1]];\n        setTimeout(() => {\n          //Walls\n          document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-wall-animated\";\n        }, i * this.state.mazeSpeed);\n      }\n    };\n  }\n\n  componentDidMount() {\n    window.addEventListener(\"resize\", this.updateDimensions);\n    const grid = getInitialGrid(this.state.numRows, this.state.numColumns);\n    this.setState({\n      grid\n    });\n  }\n\n  handleMouseDown(row, col) {\n    const newGrid = getNewGridWithWalls(this.state.grid, row, col);\n    this.setState({\n      grid: newGrid,\n      mouseIsPressed: true\n    });\n  }\n\n  handleMouseEnter(row, col) {\n    if (this.state.mouseIsPressed) {\n      const newGrid = getNewGridWithWalls(this.state.grid, row, col);\n      this.setState({\n        grid: newGrid,\n        mouseIsPressed: true\n      });\n    }\n  }\n\n  handleMouseUp() {\n    this.setState({\n      mouseIsPressed: false\n    });\n  }\n\n  clearGrid() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n\n    for (let row = 0; row < this.state.grid.length; row++) {\n      for (let col = 0; col < this.state.grid[0].length; col++) {\n        if (!(row === startNodeRow && col === startNodeCol || row === finishNodeRow && col === finishNodeCol)) {\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\n        }\n      }\n    }\n\n    const newGrid = getInitialGrid(this.state.numRows, this.state.numColumns);\n    this.setState({\n      grid: newGrid,\n      visualizingAlgorithm: false,\n      generatingMaze: false\n    });\n  }\n\n  clearPath() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n\n    for (let row = 0; row < this.state.grid.length; row++) {\n      for (let col = 0; col < this.state.grid[0].length; col++) {\n        if (document.getElementById(`node-${row}-${col}`).className === \"node node-shortest-path\") {\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\n        }\n      }\n    }\n\n    const newGrid = getGridWithoutPath(this.state.grid);\n    this.setState({\n      grid: newGrid,\n      visualizingAlgorithm: false,\n      generatingMaze: false\n    });\n  }\n\n  visualizeDijkstra() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n\n    this.setState({\n      visualizingAlgorithm: true\n    });\n    setTimeout(() => {\n      const {\n        grid\n      } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n      const nodesInShortestPathOrder = getNodesInShortestPathOrderDijkstra(finishNode);\n      this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, this.state.speed);\n  }\n\n  generateRecursiveDivisionMaze() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n\n    this.setState({\n      generatingMaze: true\n    });\n    setTimeout(() => {\n      const {\n        grid\n      } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const walls = recursiveDivisionMaze(grid, startNode, finishNode);\n      this.animateMaze(walls);\n    }, this.state.mazeSpeed);\n  }\n\n  render() {\n    let {\n      grid\n    } = this.state;\n    return /*#__PURE__*/React.createElement(React.Fragment, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 231,\n        columnNumber: 7\n      }\n    }, /*#__PURE__*/React.createElement(NavBar, {\n      visualizingAlgorithm: this.state.visualizingAlgorithm,\n      generatingMaze: this.state.generatingMaze,\n      visualizeDijkstra: this.visualizeDijkstra.bind(this),\n      generateRecursiveDivisionMaze: this.generateRecursiveDivisionMaze.bind(this),\n      clearGrid: this.clearGrid.bind(this),\n      clearPath: this.clearPath.bind(this),\n      updateSpeed: this.updateSpeed.bind(this),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 232,\n        columnNumber: 9\n      }\n    }), /*#__PURE__*/React.createElement(\"div\", {\n      className: this.state.visualizingAlgorithm || this.state.generatingMaze ? \"grid-visualizing\" : \"grid\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 241,\n        columnNumber: 9\n      }\n    }, grid.map((row, rowId) => {\n      return /*#__PURE__*/React.createElement(\"div\", {\n        key: rowId,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 250,\n          columnNumber: 15\n        }\n      }, row.map((node, nodeId) => {\n        const {\n          row,\n          col,\n          isStart,\n          isFinish,\n          isVisited,\n          isShortest,\n          isWall\n        } = node;\n        return /*#__PURE__*/React.createElement(Node, {\n          key: nodeId,\n          row: row,\n          col: col,\n          isStart: isStart,\n          isFinish: isFinish,\n          isVisited: isVisited,\n          isShortest: isShortest,\n          isWall: isWall,\n          onMouseDown: (row, col) => this.handleMouseDown(row, col),\n          onMouseEnter: (row, col) => this.handleMouseEnter(row, col),\n          onMouseUp: () => this.handleMouseUp(),\n          width: this.state.width,\n          height: this.state.height,\n          numRows: this.state.numRows,\n          numColumns: this.state.numColumns,\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 262,\n            columnNumber: 21\n          }\n        });\n      }));\n    })));\n  }\n\n}\n\nfunction getInitialNum(width, height) {\n  let numColumns;\n\n  if (width > 1500) {\n    numColumns = Math.floor(width / 25);\n  } else if (width > 1250) {\n    numColumns = Math.floor(width / 22.5);\n  } else if (width > 1000) {\n    numColumns = Math.floor(width / 20);\n  } else if (width > 750) {\n    numColumns = Math.floor(width / 17.5);\n  } else if (width > 500) {\n    numColumns = Math.floor(width / 15);\n  } else if (width > 250) {\n    numColumns = Math.floor(width / 12.5);\n  } else if (width > 0) {\n    numColumns = Math.floor(width / 10);\n  }\n\n  let cellWidth = Math.floor(width / numColumns);\n  let numRows = Math.floor(height / cellWidth);\n  return [numRows, numColumns];\n}\n\nfunction getRandomNums(num) {\n  let randomNums1 = [];\n  let temp = 2;\n\n  for (let i = 5; i < num / 2; i += 2) {\n    randomNums1.push(temp);\n    temp += 2;\n  }\n\n  let randomNums2 = [];\n  temp = -2;\n\n  for (let i = num / 2; i < num - 5; i += 2) {\n    randomNums2.push(temp);\n    temp -= 2;\n  }\n\n  return [randomNums1, randomNums2];\n}\n\nfunction getStartFinishNode(numRows, numColumns) {\n  let randomNums;\n  let x;\n  let y;\n  let startNodeRow;\n  let startNodeCol;\n  let finishNodeRow;\n  let finishNodeCol;\n\n  if (numRows < numColumns) {\n    randomNums = getRandomNums(numRows);\n    x = Math.floor(numRows / 2);\n    y = Math.floor(numColumns / 4);\n    if (x % 2 !== 0) x -= 1;\n    if (y % 2 !== 0) y += 1;\n    startNodeRow = x + randomNums[1][Math.floor(Math.random() * randomNums[1].length)];\n    startNodeCol = y + [-6, -4, -2, 0][Math.floor(Math.random() * 4)];\n    finishNodeRow = x + randomNums[0][Math.floor(Math.random() * randomNums[0].length)];\n    finishNodeCol = numColumns - y + [0, 2, 4, 6][Math.floor(Math.random() * 4)];\n  } else {\n    randomNums = getRandomNums(numColumns);\n    x = Math.floor(numRows / 4);\n    y = Math.floor(numColumns / 2);\n    if (x % 2 !== 0) x -= 1;\n    if (y % 2 !== 0) y += 1;\n    startNodeRow = x + [-6, -4, -2, 0][Math.floor(Math.random() * 4)];\n    startNodeCol = y + randomNums[1][Math.floor(Math.random() * randomNums[1].length)];\n    finishNodeRow = numRows - x + [0, 2, 4, 6][Math.floor(Math.random() * 4)];\n    finishNodeCol = y + randomNums[0][Math.floor(Math.random() * randomNums[0].length)];\n  }\n\n  return [startNodeRow, startNodeCol, finishNodeRow, finishNodeCol];\n}\n\nconst getInitialGrid = (numRows, numColumns) => {\n  let grid = [];\n\n  for (let row = 0; row < numRows; row++) {\n    let currentRow = [];\n\n    for (let col = 0; col < numColumns; col++) {\n      currentRow.push(createNode(row, col));\n    }\n\n    grid.push(currentRow);\n  }\n\n  return grid;\n};\n\nconst createNode = (row, col) => {\n  return {\n    row,\n    col,\n    isStart: row === startNodeRow && col === startNodeCol,\n    isFinish: row === finishNodeRow && col === finishNodeCol,\n    distance: Infinity,\n    totalDistance: Infinity,\n    isVisited: false,\n    isShortest: false,\n    isWall: false,\n    previousNode: null\n  };\n};\n\nconst getNewGridWithWalls = (grid, row, col) => {\n  let newGrid = grid.slice();\n  let node = grid[row][col];\n  let newNode = { ...node,\n    isWall: !node.isWall\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst getNewGridWithMaze = (grid, walls) => {\n  let newGrid = grid.slice();\n\n  for (let wall of walls) {\n    let node = grid[wall[0]][wall[1]];\n    let newNode = { ...node,\n      isWall: true\n    };\n    newGrid[wall[0]][wall[1]] = newNode;\n  }\n\n  return newGrid;\n};\n\nconst getGridWithoutPath = grid => {\n  let newGrid = grid.slice();\n\n  for (let row of grid) {\n    for (let node of row) {\n      let newNode = { ...node,\n        distance: Infinity,\n        totalDistance: Infinity,\n        isVisited: false,\n        isShortest: false,\n        previousNode: null\n      };\n      newGrid[node.row][node.col] = newNode;\n    }\n  }\n\n  return newGrid;\n};\n\nconst updateNodesForRender = (grid, nodesInShortestPathOrder, visitedNodesInOrder) => {\n  let newGrid = grid.slice();\n\n  for (let node of visitedNodesInOrder) {\n    if (node.row === startNodeRow && node.col === startNodeCol || node.row === finishNodeRow && node.col === finishNodeCol) continue;\n    let newNode = { ...node,\n      isVisited: true\n    };\n    newGrid[node.row][node.col] = newNode;\n  }\n\n  for (let node of nodesInShortestPathOrder) {\n    if (node.row === finishNodeRow && node.col === finishNodeCol) {\n      return newGrid;\n    }\n\n    let newNode = { ...node,\n      isVisited: false,\n      isShortest: true\n    };\n    newGrid[node.row][node.col] = newNode;\n  }\n};\n\nconst getVisitedNodesInOrder = (visitedNodesInOrderStart, visitedNodesInOrderFinish) => {\n  let visitedNodesInOrder = [];\n  let n = Math.max(visitedNodesInOrderStart.length, visitedNodesInOrderFinish.length);\n\n  for (let i = 0; i < n; i++) {\n    if (visitedNodesInOrderStart[i] !== undefined) {\n      visitedNodesInOrder.push(visitedNodesInOrderStart[i]);\n    }\n\n    if (visitedNodesInOrderFinish[i] !== undefined) {\n      visitedNodesInOrder.push(visitedNodesInOrderFinish[i]);\n    }\n  }\n\n  return visitedNodesInOrder;\n};\n\n/*#__PURE__*/\nReact.createElement(\"html\", {\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 488,\n    columnNumber: 1\n  }\n}, /*#__PURE__*/React.createElement(\"li\", {\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 489,\n    columnNumber: 1\n  }\n}, /*#__PURE__*/React.createElement(\"button\", {\n  type: \"button\",\n  className: \"btn btn-success\",\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 490,\n    columnNumber: 1\n  }\n}, /*#__PURE__*/React.createElement(\"a\", {\n  href: \"#learn\",\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 492,\n    columnNumber: 29\n  }\n}), \"Learn More\")), /*#__PURE__*/React.createElement(\"div\", {\n  id: \"learn\",\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 496,\n    columnNumber: 3\n  }\n}, /*#__PURE__*/React.createElement(\"h1\", {\n  class: \"learn_header\",\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 497,\n    columnNumber: 3\n  }\n}, \"Dijkstra's Algorithm\"), /*#__PURE__*/React.createElement(\"hr\", {\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 497,\n    columnNumber: 53\n  }\n}), /*#__PURE__*/React.createElement(\"br\", {\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 497,\n    columnNumber: 62\n  }\n}), /*#__PURE__*/React.createElement(\"br\", {\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 497,\n    columnNumber: 71\n  }\n}), /*#__PURE__*/React.createElement(\"p\", {\n  class: \"learn_intro\",\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 498,\n    columnNumber: 3\n  }\n}, /*#__PURE__*/React.createElement(\"strong\", {\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 498,\n    columnNumber: 26\n  }\n}, \"Dijkstra's Algorithm\"), \" basically starts at the node that you choose (the source node) and it analyzes the graph to find the shortest path between that node and all the other nodes in the graph. The algorithm keeps track of the currently known shortest distance from each node to the source node and it updates these values if it finds a shorter path. Once the algorithm has found the shortest path between the source node and another node, that node is marked as \\\"visited\\\" and added to the path. The process continues until all the nodes in the graph have been added to the path. This way, we have a path that connects the source node to all other nodes following the shortest path possible to reach each node.\"), /*#__PURE__*/React.createElement(\"h3\", {\n  class: \"algo\",\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 503,\n    columnNumber: 3\n  }\n}, \"Algorithm:\"), /*#__PURE__*/React.createElement(\"div\", {\n  class: \"algo_content\",\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 504,\n    columnNumber: 3\n  }\n}, \"1) Create a set sptSet (shortest path tree set) that keeps track of vertices included in the shortest-path tree, i.e., whose minimum distance from the source is calculated and finalized. Initially, this set is empty. \", /*#__PURE__*/React.createElement(\"br\", {\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 505,\n    columnNumber: 220\n  }\n}), \"2) Assign a distance value to all vertices in the input graph. Initialize all distance values as INFINITE. Assign distance value as 0 for the source vertex so that it is picked first. \", /*#__PURE__*/React.createElement(\"br\", {\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 506,\n    columnNumber: 185\n  }\n}), \"3) While sptSet doesn\\u2019t include all vertices \", /*#__PURE__*/React.createElement(\"br\", {\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 507,\n    columnNumber: 46\n  }\n}), \"\\u2026.a) Pick a vertex u which is not there in sptSet and has a minimum distance value. \", /*#__PURE__*/React.createElement(\"br\", {\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 508,\n    columnNumber: 85\n  }\n}), \"\\u2026.b) Include u to sptSet. \", /*#__PURE__*/React.createElement(\"br\", {\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 509,\n    columnNumber: 27\n  }\n}), \"\\u2026.c) Update distance value of all adjacent vertices of u. \", /*#__PURE__*/React.createElement(\"br\", {\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 510,\n    columnNumber: 59\n  }\n}), \"To update the distance values, iterate through all adjacent vertices. For every adjacent vertex v, if the sum of distance value of u (from source) and weight of edge u-v, is less than the distance value of v, then update the distance value of v. \", /*#__PURE__*/React.createElement(\"br\", {\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 510,\n    columnNumber: 314\n  }\n}))));\nexport default PathfindingVisualizer;","map":{"version":3,"sources":["F:/Deerwalk/semester-5/Micro Project/pathfinding-visualizer-master/src/pathfindingVisualizer/pathfindingVisualizer.jsx"],"names":["React","Component","Node","NavBar","dijkstra","getNodesInShortestPathOrderDijkstra","recursiveDivisionMaze","initialNum","getInitialNum","window","innerWidth","innerHeight","initialNumRows","initialNumColumns","startFinishNode","getStartFinishNode","startNodeRow","startNodeCol","finishNodeRow","finishNodeCol","PathfindingVisualizer","state","grid","mouseIsPressed","visualizingAlgorithm","generatingMaze","width","height","numRows","numColumns","speed","mazeSpeed","updateDimensions","setState","updateSpeed","path","maze","animateShortestPath","nodesInShortestPathOrder","visitedNodesInOrder","length","i","setTimeout","newGrid","updateNodesForRender","node","document","getElementById","row","col","className","animateAlgorithm","slice","newNode","isVisited","animateMaze","walls","clearGrid","getNewGridWithMaze","wall","componentDidMount","addEventListener","getInitialGrid","handleMouseDown","getNewGridWithWalls","handleMouseEnter","handleMouseUp","clearPath","getGridWithoutPath","visualizeDijkstra","startNode","finishNode","generateRecursiveDivisionMaze","render","bind","map","rowId","nodeId","isStart","isFinish","isShortest","isWall","Math","floor","cellWidth","getRandomNums","num","randomNums1","temp","push","randomNums2","randomNums","x","y","random","currentRow","createNode","distance","Infinity","totalDistance","previousNode","getVisitedNodesInOrder","visitedNodesInOrderStart","visitedNodesInOrderFinish","n","max","undefined"],"mappings":"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","sourcesContent":["import React, { Component } from \"react\";\nimport \"./pathfindingVisualizer.css\";\nimport Node from \"./Node/node\";\nimport NavBar from \"./navbar\";\n\n//Pathfinding Algorithms\nimport {\n  dijkstra,\n  getNodesInShortestPathOrderDijkstra,\n} from \"../pathfindingAlgorithms/dijkstra\";\n\n\n//Maze Algorithms\nimport { recursiveDivisionMaze } from \"../mazeAlgorithms/recursiveDivision\";\n\nconst initialNum = getInitialNum(window.innerWidth, window.innerHeight);\nconst initialNumRows = initialNum[0];\nconst initialNumColumns = initialNum[1];\n\nconst startFinishNode = getStartFinishNode(initialNumRows, initialNumColumns);\nconst startNodeRow = startFinishNode[0];\nconst startNodeCol = startFinishNode[1];\nconst finishNodeRow = startFinishNode[2];\nconst finishNodeCol = startFinishNode[3];\n\nclass PathfindingVisualizer extends Component {\n  state = {\n    grid: [],\n    mouseIsPressed: false,\n    visualizingAlgorithm: false,\n    generatingMaze: false,\n    width: window.innerWidth,\n    height: window.innerHeight,\n    numRows: initialNumRows,\n    numColumns: initialNumColumns,\n    speed: 10,\n    mazeSpeed: 10,\n  };\n\n  updateDimensions = () => {\n    this.setState({\n      width: window.innerWidth,\n      height: window.innerHeight,\n    });\n  };\n\n  updateSpeed = (path, maze) => {\n    this.setState({ speed: path, mazeSpeed: maze });\n  };\n\n  componentDidMount() {\n    window.addEventListener(\"resize\", this.updateDimensions);\n    const grid = getInitialGrid(this.state.numRows, this.state.numColumns);\n    this.setState({ grid });\n  }\n\n  handleMouseDown(row, col) {\n    const newGrid = getNewGridWithWalls(this.state.grid, row, col);\n    this.setState({ grid: newGrid, mouseIsPressed: true });\n  }\n\n  handleMouseEnter(row, col) {\n    if (this.state.mouseIsPressed) {\n      const newGrid = getNewGridWithWalls(this.state.grid, row, col);\n      this.setState({ grid: newGrid, mouseIsPressed: true });\n    }\n  }\n\n  handleMouseUp() {\n    this.setState({ mouseIsPressed: false });\n  }\n\n  clearGrid() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n    for (let row = 0; row < this.state.grid.length; row++) {\n      for (let col = 0; col < this.state.grid[0].length; col++) {\n        if (\n          !(\n            (row === startNodeRow && col === startNodeCol) ||\n            (row === finishNodeRow && col === finishNodeCol)\n          )\n        ) {\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\n        }\n      }\n    }\n    const newGrid = getInitialGrid(this.state.numRows, this.state.numColumns);\n    this.setState({\n      grid: newGrid,\n      visualizingAlgorithm: false,\n      generatingMaze: false,\n    });\n  }\n\n  clearPath() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n    for (let row = 0; row < this.state.grid.length; row++) {\n      for (let col = 0; col < this.state.grid[0].length; col++) {\n        if (\n          document.getElementById(`node-${row}-${col}`).className ===\n          \"node node-shortest-path\"\n        ) {\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\n        }\n      }\n    }\n    const newGrid = getGridWithoutPath(this.state.grid);\n    this.setState({\n      grid: newGrid,\n      visualizingAlgorithm: false,\n      generatingMaze: false,\n    });\n  }\n\n  animateShortestPath = (nodesInShortestPathOrder, visitedNodesInOrder) => {\n    if (nodesInShortestPathOrder.length === 1)\n      this.setState({ visualizingAlgorithm: false });\n    for (let i = 1; i < nodesInShortestPathOrder.length; i++) {\n      if (i === nodesInShortestPathOrder.length - 1) {\n        setTimeout(() => {\n          let newGrid = updateNodesForRender(\n            this.state.grid,\n            nodesInShortestPathOrder,\n            visitedNodesInOrder\n          );\n          this.setState({ grid: newGrid, visualizingAlgorithm: false });\n        }, i * (3 * this.state.speed));\n        return;\n      }\n      let node = nodesInShortestPathOrder[i];\n      setTimeout(() => {\n        //shortest path node\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-shortest-path\";\n      }, i * (3 * this.state.speed));\n    }\n  };\n\n  animateAlgorithm = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n    let newGrid = this.state.grid.slice();\n    for (let row of newGrid) {\n      for (let node of row) {\n        let newNode = {\n          ...node,\n          isVisited: false,\n        };\n        newGrid[node.row][node.col] = newNode;\n      }\n    }\n    this.setState({ grid: newGrid });\n    for (let i = 1; i <= visitedNodesInOrder.length; i++) {\n      let node = visitedNodesInOrder[i];\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(\n            nodesInShortestPathOrder,\n            visitedNodesInOrder\n          );\n        }, i * this.state.speed);\n        return;\n      }\n      setTimeout(() => {\n        //visited node\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-visited\";\n      }, i * this.state.speed);\n    }\n  };\n\n  visualizeDijkstra() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n    this.setState({ visualizingAlgorithm: true });\n    setTimeout(() => {\n      const { grid } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n      const nodesInShortestPathOrder = getNodesInShortestPathOrderDijkstra(\n        finishNode\n      );\n      this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, this.state.speed);\n  }\n\n\n  animateMaze = (walls) => {\n    for (let i = 0; i <= walls.length; i++) {\n      if (i === walls.length) {\n        setTimeout(() => {\n          this.clearGrid();\n          let newGrid = getNewGridWithMaze(this.state.grid, walls);\n          this.setState({ grid: newGrid, generatingMaze: false });\n        }, i * this.state.mazeSpeed);\n        return;\n      }\n      let wall = walls[i];\n      let node = this.state.grid[wall[0]][wall[1]];\n      setTimeout(() => {\n        //Walls\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-wall-animated\";\n      }, i * this.state.mazeSpeed);\n    }\n  };\n\n\n\n  generateRecursiveDivisionMaze() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n    this.setState({ generatingMaze: true });\n    setTimeout(() => {\n      const { grid } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const walls = recursiveDivisionMaze(grid, startNode, finishNode);\n      this.animateMaze(walls);\n    }, this.state.mazeSpeed);\n  }\n\n  render() {\n    let { grid } = this.state;\n    return (\n      <React.Fragment>\n        <NavBar\n          visualizingAlgorithm={this.state.visualizingAlgorithm}\n          generatingMaze={this.state.generatingMaze}\n          visualizeDijkstra={this.visualizeDijkstra.bind(this)}\n          generateRecursiveDivisionMaze={this.generateRecursiveDivisionMaze.bind( this)}\n          clearGrid={this.clearGrid.bind(this)}\n          clearPath={this.clearPath.bind(this)}\n          updateSpeed={this.updateSpeed.bind(this)}\n        />\n        <div\n          className={\n            this.state.visualizingAlgorithm || this.state.generatingMaze\n              ? \"grid-visualizing\"\n              : \"grid\"\n          }\n        >\n          {grid.map((row, rowId) => {\n            return (\n              <div key={rowId}>\n                {row.map((node, nodeId) => {\n                  const {\n                    row,\n                    col,\n                    isStart,\n                    isFinish,\n                    isVisited,\n                    isShortest,\n                    isWall,\n                  } = node;\n                  return (\n                    <Node\n                      key={nodeId}\n                      row={row}\n                      col={col}\n                      isStart={isStart}\n                      isFinish={isFinish}\n                      isVisited={isVisited}\n                      isShortest={isShortest}\n                      isWall={isWall}\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                      onMouseEnter={(row, col) =>\n                        this.handleMouseEnter(row, col)\n                      }\n                      onMouseUp={() => this.handleMouseUp()}\n                      width={this.state.width}\n                      height={this.state.height}\n                      numRows={this.state.numRows}\n                      numColumns={this.state.numColumns}\n                    ></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </React.Fragment>\n    );\n  }\n}\n\nfunction getInitialNum(width, height) {\n  let numColumns;\n  if (width > 1500) {\n    numColumns = Math.floor(width / 25);\n  } else if (width > 1250) {\n    numColumns = Math.floor(width / 22.5);\n  } else if (width > 1000) {\n    numColumns = Math.floor(width / 20);\n  } else if (width > 750) {\n    numColumns = Math.floor(width / 17.5);\n  } else if (width > 500) {\n    numColumns = Math.floor(width / 15);\n  } else if (width > 250) {\n    numColumns = Math.floor(width / 12.5);\n  } else if (width > 0) {\n    numColumns = Math.floor(width / 10);\n  }\n  let cellWidth = Math.floor(width / numColumns);\n  let numRows = Math.floor(height / cellWidth);\n  return [numRows, numColumns];\n}\n\nfunction getRandomNums(num) {\n  let randomNums1 = [];\n  let temp = 2;\n  for (let i = 5; i < num / 2; i += 2) {\n    randomNums1.push(temp);\n    temp += 2;\n  }\n  let randomNums2 = [];\n  temp = -2;\n  for (let i = num / 2; i < num - 5; i += 2) {\n    randomNums2.push(temp);\n    temp -= 2;\n  }\n  return [randomNums1, randomNums2];\n}\n\nfunction getStartFinishNode(numRows, numColumns) {\n  let randomNums;\n  let x;\n  let y;\n  let startNodeRow;\n  let startNodeCol;\n  let finishNodeRow;\n  let finishNodeCol;\n  if (numRows < numColumns) {\n    randomNums = getRandomNums(numRows);\n    x = Math.floor(numRows / 2);\n    y = Math.floor(numColumns / 4);\n    if (x % 2 !== 0) x -= 1;\n    if (y % 2 !== 0) y += 1;\n    startNodeRow =\n      x + randomNums[1][Math.floor(Math.random() * randomNums[1].length)];\n    startNodeCol = y + [-6, -4, -2, 0][Math.floor(Math.random() * 4)];\n    finishNodeRow =\n      x + randomNums[0][Math.floor(Math.random() * randomNums[0].length)];\n    finishNodeCol =\n      numColumns - y + [0, 2, 4, 6][Math.floor(Math.random() * 4)];\n  } else {\n    randomNums = getRandomNums(numColumns);\n    x = Math.floor(numRows / 4);\n    y = Math.floor(numColumns / 2);\n    if (x % 2 !== 0) x -= 1;\n    if (y % 2 !== 0) y += 1;\n    startNodeRow = x + [-6, -4, -2, 0][Math.floor(Math.random() * 4)];\n    startNodeCol =\n      y + randomNums[1][Math.floor(Math.random() * randomNums[1].length)];\n    finishNodeRow = numRows - x + [0, 2, 4, 6][Math.floor(Math.random() * 4)];\n    finishNodeCol =\n      y + randomNums[0][Math.floor(Math.random() * randomNums[0].length)];\n  }\n  return [startNodeRow, startNodeCol, finishNodeRow, finishNodeCol];\n}\n\nconst getInitialGrid = (numRows, numColumns) => {\n  let grid = [];\n  for (let row = 0; row < numRows; row++) {\n    let currentRow = [];\n    for (let col = 0; col < numColumns; col++) {\n      currentRow.push(createNode(row, col));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (row, col) => {\n  return {\n    row,\n    col,\n    isStart: row === startNodeRow && col === startNodeCol,\n    isFinish: row === finishNodeRow && col === finishNodeCol,\n    distance: Infinity,\n    totalDistance: Infinity,\n    isVisited: false,\n    isShortest: false,\n    isWall: false,\n    previousNode: null,\n  };\n};\n\nconst getNewGridWithWalls = (grid, row, col) => {\n  let newGrid = grid.slice();\n  let node = grid[row][col];\n  let newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst getNewGridWithMaze = (grid, walls) => {\n  let newGrid = grid.slice();\n  for (let wall of walls) {\n    let node = grid[wall[0]][wall[1]];\n    let newNode = {\n      ...node,\n      isWall: true,\n    };\n    newGrid[wall[0]][wall[1]] = newNode;\n  }\n  return newGrid;\n};\n\nconst getGridWithoutPath = (grid) => {\n  let newGrid = grid.slice();\n  for (let row of grid) {\n    for (let node of row) {\n      let newNode = {\n        ...node,\n        distance: Infinity,\n        totalDistance: Infinity,\n        isVisited: false,\n        isShortest: false,\n        previousNode: null,\n      };\n      newGrid[node.row][node.col] = newNode;\n    }\n  }\n  return newGrid;\n};\n\nconst updateNodesForRender = (\n  grid,\n  nodesInShortestPathOrder,\n  visitedNodesInOrder\n) => {\n  let newGrid = grid.slice();\n  for (let node of visitedNodesInOrder) {\n    if (\n      (node.row === startNodeRow && node.col === startNodeCol) ||\n      (node.row === finishNodeRow && node.col === finishNodeCol)\n    )\n      continue;\n    let newNode = {\n      ...node,\n      isVisited: true,\n    };\n    newGrid[node.row][node.col] = newNode;\n  }\n  for (let node of nodesInShortestPathOrder) {\n    if (node.row === finishNodeRow && node.col === finishNodeCol) {\n      return newGrid;\n    }\n    let newNode = {\n      ...node,\n      isVisited: false,\n      isShortest: true,\n    };\n    newGrid[node.row][node.col] = newNode;\n  }\n};\n\nconst getVisitedNodesInOrder = (\n  visitedNodesInOrderStart,\n  visitedNodesInOrderFinish\n) => {\n  let visitedNodesInOrder = [];\n  let n = Math.max(\n    visitedNodesInOrderStart.length,\n    visitedNodesInOrderFinish.length\n  );\n  for (let i = 0; i < n; i++) {\n    if (visitedNodesInOrderStart[i] !== undefined) {\n      visitedNodesInOrder.push(visitedNodesInOrderStart[i]);\n    }\n    if (visitedNodesInOrderFinish[i] !== undefined) {\n      visitedNodesInOrder.push(visitedNodesInOrderFinish[i]);\n    }\n  }\n  return visitedNodesInOrder;\n};\n\n\n<html>\n<li>\n<button\ntype=\"button\"\nclassName=\"btn btn-success\"><a href=\"#learn\"></a>\n  Learn More\n</button>\n</li>\n  <div id='learn'>\n  <h1 class=\"learn_header\">Dijkstra's Algorithm</h1><hr></hr><br></br><br></br>\n  <p class=\"learn_intro\"><strong>Dijkstra's Algorithm</strong> basically starts at the node that you choose (the source node) and it analyzes the graph to find the shortest path between that node and all the other nodes in the graph.\nThe algorithm keeps track of the currently known shortest distance from each node to the source node and it updates these values if it finds a shorter path.\nOnce the algorithm has found the shortest path between the source node and another node, that node is marked as \"visited\" and added to the path.\nThe process continues until all the nodes in the graph have been added to the path. This way, we have a path that connects the source node to all other nodes following the shortest path possible to reach each node.</p>\n\n  <h3 class=\"algo\">Algorithm:</h3>\n  <div class=\"algo_content\">\n  1) Create a set sptSet (shortest path tree set) that keeps track of vertices included in the shortest-path tree, i.e., whose minimum distance from the source is calculated and finalized. Initially, this set is empty. <br></br>\n2) Assign a distance value to all vertices in the input graph. Initialize all distance values as INFINITE. Assign distance value as 0 for the source vertex so that it is picked first. <br></br>\n3) While sptSet doesn’t include all vertices <br></br>\n….a) Pick a vertex u which is not there in sptSet and has a minimum distance value. <br></br>\n….b) Include u to sptSet. <br></br>\n….c) Update distance value of all adjacent vertices of u. <br></br>To update the distance values, iterate through all adjacent vertices. For every adjacent vertex v, if the sum of distance value of u (from source) and weight of edge u-v, is less than the distance value of v, then update the distance value of v. <br></br>\n  </div>\n  </div>\n\n  </html>\n\n\n\nexport default PathfindingVisualizer;\n\n\n"]},"metadata":{},"sourceType":"module"}