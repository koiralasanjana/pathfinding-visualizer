{"ast":null,"code":"let walls;\nexport function horizontalMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getHorizontalWalls(vertical, horizontal, startNode, finishNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n\n  return result;\n}\n\nfunction getHorizontalWalls(vertical, horizontal, startNode, finishNode) {\n  if (horizontal.length < 2) {\n    return;\n  }\n\n  let choice = Math.floor(Math.random() * 2);\n\n  for (let num of horizontal) {\n    if (choice === 0 && num % 2 !== 0) {\n      addWall(num, vertical, startNode, finishNode);\n    }\n\n    if (choice === 1 && num % 2 === 0) {\n      addWall(num, vertical, startNode, finishNode);\n    }\n  }\n}\n\nfunction addWall(num, vertical, startNode, finishNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n\n  for (let temp of vertical) {\n    if (num === startNode.row && temp === startNode.col || num === finishNode.row && temp === finishNode.col) {\n      isStartFinish = true;\n      continue;\n    }\n\n    tempWalls.push([num, temp]);\n  }\n\n  if (!isStartFinish) {\n    tempWalls.splice(Math.floor(Math.random() * tempWalls.length), 1);\n  }\n\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}","map":{"version":3,"sources":["F:/Deerwalk/semester-5/Micro Project/pathfinding-visualizer-master/src/mazeAlgorithms/horizontalMaze.js"],"names":["walls","horizontalMaze","grid","startNode","finishNode","vertical","range","length","horizontal","getHorizontalWalls","len","result","i","push","choice","Math","floor","random","num","addWall","isStartFinish","tempWalls","temp","row","col","splice","wall"],"mappings":"AAAA,IAAIA,KAAJ;AACA,OAAO,SAASC,cAAT,CAAwBC,IAAxB,EAA8BC,SAA9B,EAAyCC,UAAzC,EAAqD;AAC1D,MAAI,CAACD,SAAD,IAAc,CAACC,UAAf,IAA6BD,SAAS,KAAKC,UAA/C,EAA2D;AACzD,WAAO,KAAP;AACD;;AACD,MAAIC,QAAQ,GAAGC,KAAK,CAACJ,IAAI,CAAC,CAAD,CAAJ,CAAQK,MAAT,CAApB;AACA,MAAIC,UAAU,GAAGF,KAAK,CAACJ,IAAI,CAACK,MAAN,CAAtB;AACAP,EAAAA,KAAK,GAAG,EAAR;AACAS,EAAAA,kBAAkB,CAACJ,QAAD,EAAWG,UAAX,EAAuBL,SAAvB,EAAkCC,UAAlC,CAAlB;AACA,SAAOJ,KAAP;AACD;;AAED,SAASM,KAAT,CAAeI,GAAf,EAAoB;AAClB,MAAIC,MAAM,GAAG,EAAb;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,GAApB,EAAyBE,CAAC,EAA1B,EAA8B;AAC5BD,IAAAA,MAAM,CAACE,IAAP,CAAYD,CAAZ;AACD;;AACD,SAAOD,MAAP;AACD;;AAED,SAASF,kBAAT,CAA4BJ,QAA5B,EAAsCG,UAAtC,EAAkDL,SAAlD,EAA6DC,UAA7D,EAAyE;AACvE,MAAII,UAAU,CAACD,MAAX,GAAoB,CAAxB,EAA2B;AACzB;AACD;;AAED,MAAIO,MAAM,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAgB,CAA3B,CAAb;;AACA,OAAK,IAAIC,GAAT,IAAgBV,UAAhB,EAA4B;AAC1B,QAAIM,MAAM,KAAK,CAAX,IAAgBI,GAAG,GAAG,CAAN,KAAY,CAAhC,EAAmC;AACjCC,MAAAA,OAAO,CAACD,GAAD,EAAMb,QAAN,EAAgBF,SAAhB,EAA2BC,UAA3B,CAAP;AACD;;AACD,QAAIU,MAAM,KAAK,CAAX,IAAgBI,GAAG,GAAG,CAAN,KAAY,CAAhC,EAAmC;AACjCC,MAAAA,OAAO,CAACD,GAAD,EAAMb,QAAN,EAAgBF,SAAhB,EAA2BC,UAA3B,CAAP;AACD;AACF;AACF;;AAED,SAASe,OAAT,CAAiBD,GAAjB,EAAsBb,QAAtB,EAAgCF,SAAhC,EAA2CC,UAA3C,EAAuD;AACrD,MAAIgB,aAAa,GAAG,KAApB;AACA,MAAIC,SAAS,GAAG,EAAhB;;AACA,OAAK,IAAIC,IAAT,IAAiBjB,QAAjB,EAA2B;AACzB,QACGa,GAAG,KAAKf,SAAS,CAACoB,GAAlB,IAAyBD,IAAI,KAAKnB,SAAS,CAACqB,GAA7C,IACCN,GAAG,KAAKd,UAAU,CAACmB,GAAnB,IAA0BD,IAAI,KAAKlB,UAAU,CAACoB,GAFjD,EAGE;AACAJ,MAAAA,aAAa,GAAG,IAAhB;AACA;AACD;;AACDC,IAAAA,SAAS,CAACR,IAAV,CAAe,CAACK,GAAD,EAAMI,IAAN,CAAf;AACD;;AACD,MAAI,CAACF,aAAL,EAAoB;AAClBC,IAAAA,SAAS,CAACI,MAAV,CAAiBV,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAgBI,SAAS,CAACd,MAArC,CAAjB,EAA+D,CAA/D;AACD;;AACD,OAAK,IAAImB,IAAT,IAAiBL,SAAjB,EAA4B;AAC1BrB,IAAAA,KAAK,CAACa,IAAN,CAAWa,IAAX;AACD;AACF","sourcesContent":["let walls;\nexport function horizontalMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getHorizontalWalls(vertical, horizontal, startNode, finishNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n}\n\nfunction getHorizontalWalls(vertical, horizontal, startNode, finishNode) {\n  if (horizontal.length < 2) {\n    return;\n  }\n\n  let choice = Math.floor(Math.random() * 2);\n  for (let num of horizontal) {\n    if (choice === 0 && num % 2 !== 0) {\n      addWall(num, vertical, startNode, finishNode);\n    }\n    if (choice === 1 && num % 2 === 0) {\n      addWall(num, vertical, startNode, finishNode);\n    }\n  }\n}\n\nfunction addWall(num, vertical, startNode, finishNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  for (let temp of vertical) {\n    if (\n      (num === startNode.row && temp === startNode.col) ||\n      (num === finishNode.row && temp === finishNode.col)\n    ) {\n      isStartFinish = true;\n      continue;\n    }\n    tempWalls.push([num, temp]);\n  }\n  if (!isStartFinish) {\n    tempWalls.splice(Math.floor(Math.random() * tempWalls.length), 1);\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}