{"ast":null,"code":"var _jsxFileName = \"F:\\\\Deerwalk\\\\semester-5\\\\Micro Project\\\\pathfinding-visualizer-master\\\\src\\\\pathfindingVisualizer\\\\pathfindingVisualizer.jsx\";\nimport React, { Component } from \"react\";\nimport \"./pathfindingVisualizer.css\";\nimport Node from \"./Node/node\";\nimport NavBar from \"./navbar\"; //Pathfinding Algorithms\n\nimport { dijkstra, getNodesInShortestPathOrderDijkstra } from \"../pathfindingAlgorithms/dijkstra\"; //Maze Algorithms\n\nimport { recursiveDivisionMaze } from \"../mazeAlgorithms/recursiveDivision\";\nconst initialNum = getInitialNum(window.innerWidth, window.innerHeight);\nconst initialNumRows = initialNum[0];\nconst initialNumColumns = initialNum[1];\nconst startFinishNode = getStartFinishNode(initialNumRows, initialNumColumns);\nconst startNodeRow = startFinishNode[0];\nconst startNodeCol = startFinishNode[1];\nconst finishNodeRow = startFinishNode[2];\nconst finishNodeCol = startFinishNode[3];\n\nclass PathfindingVisualizer extends Component {\n  constructor(...args) {\n    super(...args);\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n      visualizingAlgorithm: false,\n      generatingMaze: false,\n      width: window.innerWidth,\n      height: window.innerHeight,\n      numRows: initialNumRows,\n      numColumns: initialNumColumns,\n      speed: 10,\n      mazeSpeed: 10\n    };\n\n    this.updateDimensions = () => {\n      this.setState({\n        width: window.innerWidth,\n        height: window.innerHeight\n      });\n    };\n\n    this.updateSpeed = (path, maze) => {\n      this.setState({\n        speed: path,\n        mazeSpeed: maze\n      });\n    };\n\n    this.animateShortestPath = (nodesInShortestPathOrder, visitedNodesInOrder) => {\n      if (nodesInShortestPathOrder.length === 1) this.setState({\n        visualizingAlgorithm: false\n      });\n\n      for (let i = 1; i < nodesInShortestPathOrder.length; i++) {\n        if (i === nodesInShortestPathOrder.length - 1) {\n          setTimeout(() => {\n            let newGrid = updateNodesForRender(this.state.grid, nodesInShortestPathOrder, visitedNodesInOrder);\n            this.setState({\n              grid: newGrid,\n              visualizingAlgorithm: false\n            });\n          }, i * (3 * this.state.speed));\n          return;\n        }\n\n        let node = nodesInShortestPathOrder[i];\n        setTimeout(() => {\n          //shortest path node\n          document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-shortest-path\";\n        }, i * (3 * this.state.speed));\n      }\n    };\n\n    this.animateAlgorithm = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n      let newGrid = this.state.grid.slice();\n\n      for (let row of newGrid) {\n        for (let node of row) {\n          let newNode = { ...node,\n            isVisited: false\n          };\n          newGrid[node.row][node.col] = newNode;\n        }\n      }\n\n      this.setState({\n        grid: newGrid\n      });\n\n      for (let i = 1; i <= visitedNodesInOrder.length; i++) {\n        let node = visitedNodesInOrder[i];\n\n        if (i === visitedNodesInOrder.length) {\n          setTimeout(() => {\n            this.animateShortestPath(nodesInShortestPathOrder, visitedNodesInOrder);\n          }, i * this.state.speed);\n          return;\n        }\n\n        setTimeout(() => {\n          //visited node\n          document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-visited\";\n        }, i * this.state.speed);\n      }\n    };\n\n    this.animateRandomWalk = visitedNodesInOrder => {\n      for (let i = 1; i <= visitedNodesInOrder.length; i++) {\n        if (i === visitedNodesInOrder.length) {\n          setTimeout(() => {\n            this.setState({\n              visualizingAlgorithm: false\n            });\n          }, i * this.state.speed);\n          return;\n        }\n\n        let node = visitedNodesInOrder[i];\n\n        if (i === visitedNodesInOrder.length - 1) {\n          setTimeout(() => {\n            //finish node\n            document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-finish-reached\";\n          }, i * this.state.speed);\n          continue;\n        }\n\n        setTimeout(() => {\n          //visited node\n          document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-visited\";\n        }, i * this.state.speed);\n      }\n    };\n\n    this.animateMaze = walls => {\n      for (let i = 0; i <= walls.length; i++) {\n        if (i === walls.length) {\n          setTimeout(() => {\n            this.clearGrid();\n            let newGrid = getNewGridWithMaze(this.state.grid, walls);\n            this.setState({\n              grid: newGrid,\n              generatingMaze: false\n            });\n          }, i * this.state.mazeSpeed);\n          return;\n        }\n\n        let wall = walls[i];\n        let node = this.state.grid[wall[0]][wall[1]];\n        setTimeout(() => {\n          //Walls\n          document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-wall-animated\";\n        }, i * this.state.mazeSpeed);\n      }\n    };\n  }\n\n  componentDidMount() {\n    window.addEventListener(\"resize\", this.updateDimensions);\n    const grid = getInitialGrid(this.state.numRows, this.state.numColumns);\n    this.setState({\n      grid\n    });\n  }\n\n  handleMouseDown(row, col) {\n    const newGrid = getNewGridWithWalls(this.state.grid, row, col);\n    this.setState({\n      grid: newGrid,\n      mouseIsPressed: true\n    });\n  }\n\n  handleMouseEnter(row, col) {\n    if (this.state.mouseIsPressed) {\n      const newGrid = getNewGridWithWalls(this.state.grid, row, col);\n      this.setState({\n        grid: newGrid,\n        mouseIsPressed: true\n      });\n    }\n  }\n\n  handleMouseUp() {\n    this.setState({\n      mouseIsPressed: false\n    });\n  }\n\n  clearGrid() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n\n    for (let row = 0; row < this.state.grid.length; row++) {\n      for (let col = 0; col < this.state.grid[0].length; col++) {\n        if (!(row === startNodeRow && col === startNodeCol || row === finishNodeRow && col === finishNodeCol)) {\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\n        }\n      }\n    }\n\n    const newGrid = getInitialGrid(this.state.numRows, this.state.numColumns);\n    this.setState({\n      grid: newGrid,\n      visualizingAlgorithm: false,\n      generatingMaze: false\n    });\n  }\n\n  clearPath() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n\n    for (let row = 0; row < this.state.grid.length; row++) {\n      for (let col = 0; col < this.state.grid[0].length; col++) {\n        if (document.getElementById(`node-${row}-${col}`).className === \"node node-shortest-path\") {\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\n        }\n      }\n    }\n\n    const newGrid = getGridWithoutPath(this.state.grid);\n    this.setState({\n      grid: newGrid,\n      visualizingAlgorithm: false,\n      generatingMaze: false\n    });\n  }\n\n  animateBidirectionalAlgorithm(visitedNodesInOrderStart, visitedNodesInOrderFinish, nodesInShortestPathOrder, isShortedPath) {\n    let len = Math.max(visitedNodesInOrderStart.length, visitedNodesInOrderFinish.length);\n\n    for (let i = 1; i <= len; i++) {\n      let nodeA = visitedNodesInOrderStart[i];\n      let nodeB = visitedNodesInOrderFinish[i];\n\n      if (i === visitedNodesInOrderStart.length) {\n        setTimeout(() => {\n          let visitedNodesInOrder = getVisitedNodesInOrder(visitedNodesInOrderStart, visitedNodesInOrderFinish);\n\n          if (isShortedPath) {\n            this.animateShortestPath(nodesInShortestPathOrder, visitedNodesInOrder);\n          } else {\n            this.setState({\n              visualizingAlgorithm: false\n            });\n          }\n        }, i * this.state.speed);\n        return;\n      }\n\n      setTimeout(() => {\n        //visited nodes\n        if (nodeA !== undefined) document.getElementById(`node-${nodeA.row}-${nodeA.col}`).className = \"node node-visited\";\n        if (nodeB !== undefined) document.getElementById(`node-${nodeB.row}-${nodeB.col}`).className = \"node node-visited\";\n      }, i * this.state.speed);\n    }\n  }\n\n  visualizeDijkstra() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n\n    this.setState({\n      visualizingAlgorithm: true\n    });\n    setTimeout(() => {\n      const {\n        grid\n      } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n      const nodesInShortestPathOrder = getNodesInShortestPathOrderDijkstra(finishNode);\n      this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, this.state.speed);\n  }\n\n  visualizeAStar() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n\n    this.setState({\n      visualizingAlgorithm: true\n    });\n    setTimeout(() => {\n      const {\n        grid\n      } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const visitedNodesInOrder = astar(grid, startNode, finishNode);\n      const nodesInShortestPathOrder = getNodesInShortestPathOrderAstar(finishNode);\n      this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, this.state.speed);\n  }\n\n  visualizeBFS() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n\n    this.setState({\n      visualizingAlgorithm: true\n    });\n    setTimeout(() => {\n      const {\n        grid\n      } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const visitedNodesInOrder = breadthFirstSearch(grid, startNode, finishNode);\n      const nodesInShortestPathOrder = getNodesInShortestPathOrderBFS(finishNode);\n      this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, this.state.speed);\n  }\n\n  visualizeDFS() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n\n    this.setState({\n      visualizingAlgorithm: true\n    });\n    setTimeout(() => {\n      const {\n        grid\n      } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const visitedNodesInOrder = depthFirstSearch(grid, startNode, finishNode);\n      const nodesInShortestPathOrder = getNodesInShortestPathOrderDFS(finishNode);\n      this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, this.state.speed);\n  }\n\n  visualizeRandomWalk() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n\n    this.setState({\n      visualizingAlgorithm: true\n    });\n    setTimeout(() => {\n      const {\n        grid\n      } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const visitedNodesInOrder = randomWalk(grid, startNode, finishNode);\n      this.animateRandomWalk(visitedNodesInOrder);\n    }, this.state.speed);\n  }\n\n  visualizeGreedyBFS() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n\n    this.setState({\n      visualizingAlgorithm: true\n    });\n    setTimeout(() => {\n      const {\n        grid\n      } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const visitedNodesInOrder = greedyBFS(grid, startNode, finishNode);\n      const nodesInShortestPathOrder = getNodesInShortestPathOrderGreedyBFS(finishNode);\n      this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, this.state.speed);\n  }\n\n  visualizeBidirectionalGreedySearch() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n\n    this.setState({\n      visualizingAlgorithm: true\n    });\n    setTimeout(() => {\n      const {\n        grid\n      } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const visitedNodesInOrder = bidirectionalGreedySearch(grid, startNode, finishNode);\n      const visitedNodesInOrderStart = visitedNodesInOrder[0];\n      const visitedNodesInOrderFinish = visitedNodesInOrder[1];\n      const isShortedPath = visitedNodesInOrder[2];\n      const nodesInShortestPathOrder = getNodesInShortestPathOrderBidirectionalGreedySearch(visitedNodesInOrderStart[visitedNodesInOrderStart.length - 1], visitedNodesInOrderFinish[visitedNodesInOrderFinish.length - 1]);\n      this.animateBidirectionalAlgorithm(visitedNodesInOrderStart, visitedNodesInOrderFinish, nodesInShortestPathOrder, isShortedPath);\n    }, this.state.speed);\n  }\n\n  generateRandomMaze() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n\n    this.setState({\n      generatingMaze: true\n    });\n    setTimeout(() => {\n      const {\n        grid\n      } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const walls = randomMaze(grid, startNode, finishNode);\n      this.animateMaze(walls);\n    }, this.state.mazeSpeed);\n  }\n\n  generateRecursiveDivisionMaze() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n\n    this.setState({\n      generatingMaze: true\n    });\n    setTimeout(() => {\n      const {\n        grid\n      } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const walls = recursiveDivisionMaze(grid, startNode, finishNode);\n      this.animateMaze(walls);\n    }, this.state.mazeSpeed);\n  }\n\n  generateVerticalMaze() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n\n    this.setState({\n      generatingMaze: true\n    });\n    setTimeout(() => {\n      const {\n        grid\n      } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const walls = verticalMaze(grid, startNode, finishNode);\n      this.animateMaze(walls);\n    }, this.state.mazeSpeed);\n  }\n\n  generateHorizontalMaze() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n\n    this.setState({\n      generatingMaze: true\n    });\n    setTimeout(() => {\n      const {\n        grid\n      } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const walls = horizontalMaze(grid, startNode, finishNode);\n      this.animateMaze(walls);\n    }, this.state.mazeSpeed);\n  }\n\n  render() {\n    let {\n      grid\n    } = this.state;\n    return /*#__PURE__*/React.createElement(React.Fragment, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 454,\n        columnNumber: 7\n      }\n    }, /*#__PURE__*/React.createElement(NavBar, {\n      visualizingAlgorithm: this.state.visualizingAlgorithm,\n      generatingMaze: this.state.generatingMaze,\n      visualizeDijkstra: this.visualizeDijkstra.bind(this),\n      visualizeAStar: this.visualizeAStar.bind(this),\n      visualizeGreedyBFS: this.visualizeGreedyBFS.bind(this),\n      visualizeBidirectionalGreedySearch: this.visualizeBidirectionalGreedySearch.bind(this),\n      visualizeBFS: this.visualizeBFS.bind(this),\n      visualizeDFS: this.visualizeDFS.bind(this),\n      visualizeRandomWalk: this.visualizeRandomWalk.bind(this),\n      generateRandomMaze: this.generateRandomMaze.bind(this),\n      generateRecursiveDivisionMaze: this.generateRecursiveDivisionMaze.bind(this),\n      generateVerticalMaze: this.generateVerticalMaze.bind(this),\n      generateHorizontalMaze: this.generateHorizontalMaze.bind(this),\n      clearGrid: this.clearGrid.bind(this),\n      clearPath: this.clearPath.bind(this),\n      updateSpeed: this.updateSpeed.bind(this),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 455,\n        columnNumber: 9\n      }\n    }), /*#__PURE__*/React.createElement(\"div\", {\n      className: this.state.visualizingAlgorithm || this.state.generatingMaze ? \"grid-visualizing\" : \"grid\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 477,\n        columnNumber: 9\n      }\n    }, grid.map((row, rowId) => {\n      return /*#__PURE__*/React.createElement(\"div\", {\n        key: rowId,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 486,\n          columnNumber: 15\n        }\n      }, row.map((node, nodeId) => {\n        const {\n          row,\n          col,\n          isStart,\n          isFinish,\n          isVisited,\n          isShortest,\n          isWall\n        } = node;\n        return /*#__PURE__*/React.createElement(Node, {\n          key: nodeId,\n          row: row,\n          col: col,\n          isStart: isStart,\n          isFinish: isFinish,\n          isVisited: isVisited,\n          isShortest: isShortest,\n          isWall: isWall,\n          onMouseDown: (row, col) => this.handleMouseDown(row, col),\n          onMouseEnter: (row, col) => this.handleMouseEnter(row, col),\n          onMouseUp: () => this.handleMouseUp(),\n          width: this.state.width,\n          height: this.state.height,\n          numRows: this.state.numRows,\n          numColumns: this.state.numColumns,\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 498,\n            columnNumber: 21\n          }\n        });\n      }));\n    })));\n  }\n\n}\n\nfunction getInitialNum(width, height) {\n  let numColumns;\n\n  if (width > 1500) {\n    numColumns = Math.floor(width / 25);\n  } else if (width > 1250) {\n    numColumns = Math.floor(width / 22.5);\n  } else if (width > 1000) {\n    numColumns = Math.floor(width / 20);\n  } else if (width > 750) {\n    numColumns = Math.floor(width / 17.5);\n  } else if (width > 500) {\n    numColumns = Math.floor(width / 15);\n  } else if (width > 250) {\n    numColumns = Math.floor(width / 12.5);\n  } else if (width > 0) {\n    numColumns = Math.floor(width / 10);\n  }\n\n  let cellWidth = Math.floor(width / numColumns);\n  let numRows = Math.floor(height / cellWidth);\n  return [numRows, numColumns];\n}\n\nfunction getRandomNums(num) {\n  let randomNums1 = [];\n  let temp = 2;\n\n  for (let i = 5; i < num / 2; i += 2) {\n    randomNums1.push(temp);\n    temp += 2;\n  }\n\n  let randomNums2 = [];\n  temp = -2;\n\n  for (let i = num / 2; i < num - 5; i += 2) {\n    randomNums2.push(temp);\n    temp -= 2;\n  }\n\n  return [randomNums1, randomNums2];\n}\n\nfunction getStartFinishNode(numRows, numColumns) {\n  let randomNums;\n  let x;\n  let y;\n  let startNodeRow;\n  let startNodeCol;\n  let finishNodeRow;\n  let finishNodeCol;\n\n  if (numRows < numColumns) {\n    randomNums = getRandomNums(numRows);\n    x = Math.floor(numRows / 2);\n    y = Math.floor(numColumns / 4);\n    if (x % 2 !== 0) x -= 1;\n    if (y % 2 !== 0) y += 1;\n    startNodeRow = x + randomNums[1][Math.floor(Math.random() * randomNums[1].length)];\n    startNodeCol = y + [-6, -4, -2, 0][Math.floor(Math.random() * 4)];\n    finishNodeRow = x + randomNums[0][Math.floor(Math.random() * randomNums[0].length)];\n    finishNodeCol = numColumns - y + [0, 2, 4, 6][Math.floor(Math.random() * 4)];\n  } else {\n    randomNums = getRandomNums(numColumns);\n    x = Math.floor(numRows / 4);\n    y = Math.floor(numColumns / 2);\n    if (x % 2 !== 0) x -= 1;\n    if (y % 2 !== 0) y += 1;\n    startNodeRow = x + [-6, -4, -2, 0][Math.floor(Math.random() * 4)];\n    startNodeCol = y + randomNums[1][Math.floor(Math.random() * randomNums[1].length)];\n    finishNodeRow = numRows - x + [0, 2, 4, 6][Math.floor(Math.random() * 4)];\n    finishNodeCol = y + randomNums[0][Math.floor(Math.random() * randomNums[0].length)];\n  }\n\n  return [startNodeRow, startNodeCol, finishNodeRow, finishNodeCol];\n}\n\nconst getInitialGrid = (numRows, numColumns) => {\n  let grid = [];\n\n  for (let row = 0; row < numRows; row++) {\n    let currentRow = [];\n\n    for (let col = 0; col < numColumns; col++) {\n      currentRow.push(createNode(row, col));\n    }\n\n    grid.push(currentRow);\n  }\n\n  return grid;\n};\n\nconst createNode = (row, col) => {\n  return {\n    row,\n    col,\n    isStart: row === startNodeRow && col === startNodeCol,\n    isFinish: row === finishNodeRow && col === finishNodeCol,\n    distance: Infinity,\n    totalDistance: Infinity,\n    isVisited: false,\n    isShortest: false,\n    isWall: false,\n    previousNode: null\n  };\n};\n\nconst getNewGridWithWalls = (grid, row, col) => {\n  let newGrid = grid.slice();\n  let node = grid[row][col];\n  let newNode = { ...node,\n    isWall: !node.isWall\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst getNewGridWithMaze = (grid, walls) => {\n  let newGrid = grid.slice();\n\n  for (let wall of walls) {\n    let node = grid[wall[0]][wall[1]];\n    let newNode = { ...node,\n      isWall: true\n    };\n    newGrid[wall[0]][wall[1]] = newNode;\n  }\n\n  return newGrid;\n};\n\nconst getGridWithoutPath = grid => {\n  let newGrid = grid.slice();\n\n  for (let row of grid) {\n    for (let node of row) {\n      let newNode = { ...node,\n        distance: Infinity,\n        totalDistance: Infinity,\n        isVisited: false,\n        isShortest: false,\n        previousNode: null\n      };\n      newGrid[node.row][node.col] = newNode;\n    }\n  }\n\n  return newGrid;\n};\n\nconst updateNodesForRender = (grid, nodesInShortestPathOrder, visitedNodesInOrder) => {\n  let newGrid = grid.slice();\n\n  for (let node of visitedNodesInOrder) {\n    if (node.row === startNodeRow && node.col === startNodeCol || node.row === finishNodeRow && node.col === finishNodeCol) continue;\n    let newNode = { ...node,\n      isVisited: true\n    };\n    newGrid[node.row][node.col] = newNode;\n  }\n\n  for (let node of nodesInShortestPathOrder) {\n    if (node.row === finishNodeRow && node.col === finishNodeCol) {\n      return newGrid;\n    }\n\n    let newNode = { ...node,\n      isVisited: false,\n      isShortest: true\n    };\n    newGrid[node.row][node.col] = newNode;\n  }\n};\n\nconst getVisitedNodesInOrder = (visitedNodesInOrderStart, visitedNodesInOrderFinish) => {\n  let visitedNodesInOrder = [];\n  let n = Math.max(visitedNodesInOrderStart.length, visitedNodesInOrderFinish.length);\n\n  for (let i = 0; i < n; i++) {\n    if (visitedNodesInOrderStart[i] !== undefined) {\n      visitedNodesInOrder.push(visitedNodesInOrderStart[i]);\n    }\n\n    if (visitedNodesInOrderFinish[i] !== undefined) {\n      visitedNodesInOrder.push(visitedNodesInOrderFinish[i]);\n    }\n  }\n\n  return visitedNodesInOrder;\n};\n\nexport default PathfindingVisualizer;\n/* <button className=\"button\" onClick={() => this.visualizeDijkstra()}>\nDijkstra's\n</button>\n&nbsp;\n<button className=\"button\" onClick={() => this.visualizeAStar()}>\nA Star\n</button>\n&nbsp;\n<button className=\"button\" onClick={() => this.visualizeBFS()}>\nBreadth First Search\n</button>\n&nbsp;\n<button className=\"button\" onClick={() => this.visualizeDFS()}>\nDepth First Search\n</button>\n&nbsp;\n<button className=\"button\" onClick={() => this.visualizeRandomWalk()}>\nRandom Walk\n</button>\n&nbsp;\n<button className=\"button\" onClick={() => this.clearGrid()}>\nClear Grid\n</button>\n<br />\n<button className=\"button\" onClick={() => this.visualizeGreedyBFS()}>\nGreedy Best First Search\n</button>\n&nbsp;\n<button\nclassName=\"button\"\nonClick={() => this.visualizeBidirectionalGreedySearch()}\n>\nBidirectional Best First Search\n</button>\n&nbsp;\n<button className=\"button\" onClick={() => this.generateRandomMaze()}>\nRandom Maze\n</button>\n&nbsp;\n<button\nclassName=\"button\"\nonClick={() => this.generateRecursiveDivisionMaze()}\n>\nRecursive Division\n</button>\n&nbsp;\n<button\nclassName=\"button\"\nonClick={() => this.generateVerticalMaze()}\n>\nVertical Maze\n</button>\n&nbsp;\n<button\nclassName=\"button\"\nonClick={() => this.generateHorizontalMaze()}\n>\nHorizontal Maze\n</button>\n */","map":{"version":3,"sources":["F:/Deerwalk/semester-5/Micro Project/pathfinding-visualizer-master/src/pathfindingVisualizer/pathfindingVisualizer.jsx"],"names":["React","Component","Node","NavBar","dijkstra","getNodesInShortestPathOrderDijkstra","recursiveDivisionMaze","initialNum","getInitialNum","window","innerWidth","innerHeight","initialNumRows","initialNumColumns","startFinishNode","getStartFinishNode","startNodeRow","startNodeCol","finishNodeRow","finishNodeCol","PathfindingVisualizer","state","grid","mouseIsPressed","visualizingAlgorithm","generatingMaze","width","height","numRows","numColumns","speed","mazeSpeed","updateDimensions","setState","updateSpeed","path","maze","animateShortestPath","nodesInShortestPathOrder","visitedNodesInOrder","length","i","setTimeout","newGrid","updateNodesForRender","node","document","getElementById","row","col","className","animateAlgorithm","slice","newNode","isVisited","animateRandomWalk","animateMaze","walls","clearGrid","getNewGridWithMaze","wall","componentDidMount","addEventListener","getInitialGrid","handleMouseDown","getNewGridWithWalls","handleMouseEnter","handleMouseUp","clearPath","getGridWithoutPath","animateBidirectionalAlgorithm","visitedNodesInOrderStart","visitedNodesInOrderFinish","isShortedPath","len","Math","max","nodeA","nodeB","getVisitedNodesInOrder","undefined","visualizeDijkstra","startNode","finishNode","visualizeAStar","astar","getNodesInShortestPathOrderAstar","visualizeBFS","breadthFirstSearch","getNodesInShortestPathOrderBFS","visualizeDFS","depthFirstSearch","getNodesInShortestPathOrderDFS","visualizeRandomWalk","randomWalk","visualizeGreedyBFS","greedyBFS","getNodesInShortestPathOrderGreedyBFS","visualizeBidirectionalGreedySearch","bidirectionalGreedySearch","getNodesInShortestPathOrderBidirectionalGreedySearch","generateRandomMaze","randomMaze","generateRecursiveDivisionMaze","generateVerticalMaze","verticalMaze","generateHorizontalMaze","horizontalMaze","render","bind","map","rowId","nodeId","isStart","isFinish","isShortest","isWall","floor","cellWidth","getRandomNums","num","randomNums1","temp","push","randomNums2","randomNums","x","y","random","currentRow","createNode","distance","Infinity","totalDistance","previousNode","n"],"mappings":";AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AACA,OAAO,6BAAP;AACA,OAAOC,IAAP,MAAiB,aAAjB;AACA,OAAOC,MAAP,MAAmB,UAAnB,C,CAEA;;AACA,SACEC,QADF,EAEEC,mCAFF,QAGO,mCAHP,C,CAMA;;AACA,SAASC,qBAAT,QAAsC,qCAAtC;AAGA,MAAMC,UAAU,GAAGC,aAAa,CAACC,MAAM,CAACC,UAAR,EAAoBD,MAAM,CAACE,WAA3B,CAAhC;AACA,MAAMC,cAAc,GAAGL,UAAU,CAAC,CAAD,CAAjC;AACA,MAAMM,iBAAiB,GAAGN,UAAU,CAAC,CAAD,CAApC;AAEA,MAAMO,eAAe,GAAGC,kBAAkB,CAACH,cAAD,EAAiBC,iBAAjB,CAA1C;AACA,MAAMG,YAAY,GAAGF,eAAe,CAAC,CAAD,CAApC;AACA,MAAMG,YAAY,GAAGH,eAAe,CAAC,CAAD,CAApC;AACA,MAAMI,aAAa,GAAGJ,eAAe,CAAC,CAAD,CAArC;AACA,MAAMK,aAAa,GAAGL,eAAe,CAAC,CAAD,CAArC;;AAEA,MAAMM,qBAAN,SAAoCnB,SAApC,CAA8C;AAAA;AAAA;AAAA,SAC5CoB,KAD4C,GACpC;AACNC,MAAAA,IAAI,EAAE,EADA;AAENC,MAAAA,cAAc,EAAE,KAFV;AAGNC,MAAAA,oBAAoB,EAAE,KAHhB;AAINC,MAAAA,cAAc,EAAE,KAJV;AAKNC,MAAAA,KAAK,EAAEjB,MAAM,CAACC,UALR;AAMNiB,MAAAA,MAAM,EAAElB,MAAM,CAACE,WANT;AAONiB,MAAAA,OAAO,EAAEhB,cAPH;AAQNiB,MAAAA,UAAU,EAAEhB,iBARN;AASNiB,MAAAA,KAAK,EAAE,EATD;AAUNC,MAAAA,SAAS,EAAE;AAVL,KADoC;;AAAA,SAc5CC,gBAd4C,GAczB,MAAM;AACvB,WAAKC,QAAL,CAAc;AACZP,QAAAA,KAAK,EAAEjB,MAAM,CAACC,UADF;AAEZiB,QAAAA,MAAM,EAAElB,MAAM,CAACE;AAFH,OAAd;AAID,KAnB2C;;AAAA,SAqB5CuB,WArB4C,GAqB9B,CAACC,IAAD,EAAOC,IAAP,KAAgB;AAC5B,WAAKH,QAAL,CAAc;AAAEH,QAAAA,KAAK,EAAEK,IAAT;AAAeJ,QAAAA,SAAS,EAAEK;AAA1B,OAAd;AACD,KAvB2C;;AAAA,SA6F5CC,mBA7F4C,GA6FtB,CAACC,wBAAD,EAA2BC,mBAA3B,KAAmD;AACvE,UAAID,wBAAwB,CAACE,MAAzB,KAAoC,CAAxC,EACE,KAAKP,QAAL,CAAc;AAAET,QAAAA,oBAAoB,EAAE;AAAxB,OAAd;;AACF,WAAK,IAAIiB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,wBAAwB,CAACE,MAA7C,EAAqDC,CAAC,EAAtD,EAA0D;AACxD,YAAIA,CAAC,KAAKH,wBAAwB,CAACE,MAAzB,GAAkC,CAA5C,EAA+C;AAC7CE,UAAAA,UAAU,CAAC,MAAM;AACf,gBAAIC,OAAO,GAAGC,oBAAoB,CAChC,KAAKvB,KAAL,CAAWC,IADqB,EAEhCgB,wBAFgC,EAGhCC,mBAHgC,CAAlC;AAKA,iBAAKN,QAAL,CAAc;AAAEX,cAAAA,IAAI,EAAEqB,OAAR;AAAiBnB,cAAAA,oBAAoB,EAAE;AAAvC,aAAd;AACD,WAPS,EAOPiB,CAAC,IAAI,IAAI,KAAKpB,KAAL,CAAWS,KAAnB,CAPM,CAAV;AAQA;AACD;;AACD,YAAIe,IAAI,GAAGP,wBAAwB,CAACG,CAAD,CAAnC;AACAC,QAAAA,UAAU,CAAC,MAAM;AACf;AACAI,UAAAA,QAAQ,CAACC,cAAT,CAAyB,QAAOF,IAAI,CAACG,GAAI,IAAGH,IAAI,CAACI,GAAI,EAArD,EAAwDC,SAAxD,GACE,yBADF;AAED,SAJS,EAIPT,CAAC,IAAI,IAAI,KAAKpB,KAAL,CAAWS,KAAnB,CAJM,CAAV;AAKD;AACF,KAnH2C;;AAAA,SAqH5CqB,gBArH4C,GAqHzB,CAACZ,mBAAD,EAAsBD,wBAAtB,KAAmD;AACpE,UAAIK,OAAO,GAAG,KAAKtB,KAAL,CAAWC,IAAX,CAAgB8B,KAAhB,EAAd;;AACA,WAAK,IAAIJ,GAAT,IAAgBL,OAAhB,EAAyB;AACvB,aAAK,IAAIE,IAAT,IAAiBG,GAAjB,EAAsB;AACpB,cAAIK,OAAO,GAAG,EACZ,GAAGR,IADS;AAEZS,YAAAA,SAAS,EAAE;AAFC,WAAd;AAIAX,UAAAA,OAAO,CAACE,IAAI,CAACG,GAAN,CAAP,CAAkBH,IAAI,CAACI,GAAvB,IAA8BI,OAA9B;AACD;AACF;;AACD,WAAKpB,QAAL,CAAc;AAAEX,QAAAA,IAAI,EAAEqB;AAAR,OAAd;;AACA,WAAK,IAAIF,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIF,mBAAmB,CAACC,MAAzC,EAAiDC,CAAC,EAAlD,EAAsD;AACpD,YAAII,IAAI,GAAGN,mBAAmB,CAACE,CAAD,CAA9B;;AACA,YAAIA,CAAC,KAAKF,mBAAmB,CAACC,MAA9B,EAAsC;AACpCE,UAAAA,UAAU,CAAC,MAAM;AACf,iBAAKL,mBAAL,CACEC,wBADF,EAEEC,mBAFF;AAID,WALS,EAKPE,CAAC,GAAG,KAAKpB,KAAL,CAAWS,KALR,CAAV;AAMA;AACD;;AACDY,QAAAA,UAAU,CAAC,MAAM;AACf;AACAI,UAAAA,QAAQ,CAACC,cAAT,CAAyB,QAAOF,IAAI,CAACG,GAAI,IAAGH,IAAI,CAACI,GAAI,EAArD,EAAwDC,SAAxD,GACE,mBADF;AAED,SAJS,EAIPT,CAAC,GAAG,KAAKpB,KAAL,CAAWS,KAJR,CAAV;AAKD;AACF,KAlJ2C;;AAAA,SAoJ5CyB,iBApJ4C,GAoJvBhB,mBAAD,IAAyB;AAC3C,WAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIF,mBAAmB,CAACC,MAAzC,EAAiDC,CAAC,EAAlD,EAAsD;AACpD,YAAIA,CAAC,KAAKF,mBAAmB,CAACC,MAA9B,EAAsC;AACpCE,UAAAA,UAAU,CAAC,MAAM;AACf,iBAAKT,QAAL,CAAc;AAAET,cAAAA,oBAAoB,EAAE;AAAxB,aAAd;AACD,WAFS,EAEPiB,CAAC,GAAG,KAAKpB,KAAL,CAAWS,KAFR,CAAV;AAGA;AACD;;AACD,YAAIe,IAAI,GAAGN,mBAAmB,CAACE,CAAD,CAA9B;;AACA,YAAIA,CAAC,KAAKF,mBAAmB,CAACC,MAApB,GAA6B,CAAvC,EAA0C;AACxCE,UAAAA,UAAU,CAAC,MAAM;AACf;AACAI,YAAAA,QAAQ,CAACC,cAAT,CAAyB,QAAOF,IAAI,CAACG,GAAI,IAAGH,IAAI,CAACI,GAAI,EAArD,EAAwDC,SAAxD,GACE,0BADF;AAED,WAJS,EAIPT,CAAC,GAAG,KAAKpB,KAAL,CAAWS,KAJR,CAAV;AAKA;AACD;;AACDY,QAAAA,UAAU,CAAC,MAAM;AACf;AACAI,UAAAA,QAAQ,CAACC,cAAT,CAAyB,QAAOF,IAAI,CAACG,GAAI,IAAGH,IAAI,CAACI,GAAI,EAArD,EAAwDC,SAAxD,GACE,mBADF;AAED,SAJS,EAIPT,CAAC,GAAG,KAAKpB,KAAL,CAAWS,KAJR,CAAV;AAKD;AACF,KA3K2C;;AAAA,SA4V5C0B,WA5V4C,GA4V7BC,KAAD,IAAW;AACvB,WAAK,IAAIhB,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIgB,KAAK,CAACjB,MAA3B,EAAmCC,CAAC,EAApC,EAAwC;AACtC,YAAIA,CAAC,KAAKgB,KAAK,CAACjB,MAAhB,EAAwB;AACtBE,UAAAA,UAAU,CAAC,MAAM;AACf,iBAAKgB,SAAL;AACA,gBAAIf,OAAO,GAAGgB,kBAAkB,CAAC,KAAKtC,KAAL,CAAWC,IAAZ,EAAkBmC,KAAlB,CAAhC;AACA,iBAAKxB,QAAL,CAAc;AAAEX,cAAAA,IAAI,EAAEqB,OAAR;AAAiBlB,cAAAA,cAAc,EAAE;AAAjC,aAAd;AACD,WAJS,EAIPgB,CAAC,GAAG,KAAKpB,KAAL,CAAWU,SAJR,CAAV;AAKA;AACD;;AACD,YAAI6B,IAAI,GAAGH,KAAK,CAAChB,CAAD,CAAhB;AACA,YAAII,IAAI,GAAG,KAAKxB,KAAL,CAAWC,IAAX,CAAgBsC,IAAI,CAAC,CAAD,CAApB,EAAyBA,IAAI,CAAC,CAAD,CAA7B,CAAX;AACAlB,QAAAA,UAAU,CAAC,MAAM;AACf;AACAI,UAAAA,QAAQ,CAACC,cAAT,CAAyB,QAAOF,IAAI,CAACG,GAAI,IAAGH,IAAI,CAACI,GAAI,EAArD,EAAwDC,SAAxD,GACE,yBADF;AAED,SAJS,EAIPT,CAAC,GAAG,KAAKpB,KAAL,CAAWU,SAJR,CAAV;AAKD;AACF,KA9W2C;AAAA;;AAyB5C8B,EAAAA,iBAAiB,GAAG;AAClBpD,IAAAA,MAAM,CAACqD,gBAAP,CAAwB,QAAxB,EAAkC,KAAK9B,gBAAvC;AACA,UAAMV,IAAI,GAAGyC,cAAc,CAAC,KAAK1C,KAAL,CAAWO,OAAZ,EAAqB,KAAKP,KAAL,CAAWQ,UAAhC,CAA3B;AACA,SAAKI,QAAL,CAAc;AAAEX,MAAAA;AAAF,KAAd;AACD;;AAED0C,EAAAA,eAAe,CAAChB,GAAD,EAAMC,GAAN,EAAW;AACxB,UAAMN,OAAO,GAAGsB,mBAAmB,CAAC,KAAK5C,KAAL,CAAWC,IAAZ,EAAkB0B,GAAlB,EAAuBC,GAAvB,CAAnC;AACA,SAAKhB,QAAL,CAAc;AAAEX,MAAAA,IAAI,EAAEqB,OAAR;AAAiBpB,MAAAA,cAAc,EAAE;AAAjC,KAAd;AACD;;AAED2C,EAAAA,gBAAgB,CAAClB,GAAD,EAAMC,GAAN,EAAW;AACzB,QAAI,KAAK5B,KAAL,CAAWE,cAAf,EAA+B;AAC7B,YAAMoB,OAAO,GAAGsB,mBAAmB,CAAC,KAAK5C,KAAL,CAAWC,IAAZ,EAAkB0B,GAAlB,EAAuBC,GAAvB,CAAnC;AACA,WAAKhB,QAAL,CAAc;AAAEX,QAAAA,IAAI,EAAEqB,OAAR;AAAiBpB,QAAAA,cAAc,EAAE;AAAjC,OAAd;AACD;AACF;;AAED4C,EAAAA,aAAa,GAAG;AACd,SAAKlC,QAAL,CAAc;AAAEV,MAAAA,cAAc,EAAE;AAAlB,KAAd;AACD;;AAEDmC,EAAAA,SAAS,GAAG;AACV,QAAI,KAAKrC,KAAL,CAAWG,oBAAX,IAAmC,KAAKH,KAAL,CAAWI,cAAlD,EAAkE;AAChE;AACD;;AACD,SAAK,IAAIuB,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAG,KAAK3B,KAAL,CAAWC,IAAX,CAAgBkB,MAAxC,EAAgDQ,GAAG,EAAnD,EAAuD;AACrD,WAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAG,KAAK5B,KAAL,CAAWC,IAAX,CAAgB,CAAhB,EAAmBkB,MAA3C,EAAmDS,GAAG,EAAtD,EAA0D;AACxD,YACE,EACGD,GAAG,KAAKhC,YAAR,IAAwBiC,GAAG,KAAKhC,YAAjC,IACC+B,GAAG,KAAK9B,aAAR,IAAyB+B,GAAG,KAAK9B,aAFpC,CADF,EAKE;AACA2B,UAAAA,QAAQ,CAACC,cAAT,CAAyB,QAAOC,GAAI,IAAGC,GAAI,EAA3C,EAA8CC,SAA9C,GAA0D,MAA1D;AACD;AACF;AACF;;AACD,UAAMP,OAAO,GAAGoB,cAAc,CAAC,KAAK1C,KAAL,CAAWO,OAAZ,EAAqB,KAAKP,KAAL,CAAWQ,UAAhC,CAA9B;AACA,SAAKI,QAAL,CAAc;AACZX,MAAAA,IAAI,EAAEqB,OADM;AAEZnB,MAAAA,oBAAoB,EAAE,KAFV;AAGZC,MAAAA,cAAc,EAAE;AAHJ,KAAd;AAKD;;AAED2C,EAAAA,SAAS,GAAG;AACV,QAAI,KAAK/C,KAAL,CAAWG,oBAAX,IAAmC,KAAKH,KAAL,CAAWI,cAAlD,EAAkE;AAChE;AACD;;AACD,SAAK,IAAIuB,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAG,KAAK3B,KAAL,CAAWC,IAAX,CAAgBkB,MAAxC,EAAgDQ,GAAG,EAAnD,EAAuD;AACrD,WAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAG,KAAK5B,KAAL,CAAWC,IAAX,CAAgB,CAAhB,EAAmBkB,MAA3C,EAAmDS,GAAG,EAAtD,EAA0D;AACxD,YACEH,QAAQ,CAACC,cAAT,CAAyB,QAAOC,GAAI,IAAGC,GAAI,EAA3C,EAA8CC,SAA9C,KACA,yBAFF,EAGE;AACAJ,UAAAA,QAAQ,CAACC,cAAT,CAAyB,QAAOC,GAAI,IAAGC,GAAI,EAA3C,EAA8CC,SAA9C,GAA0D,MAA1D;AACD;AACF;AACF;;AACD,UAAMP,OAAO,GAAG0B,kBAAkB,CAAC,KAAKhD,KAAL,CAAWC,IAAZ,CAAlC;AACA,SAAKW,QAAL,CAAc;AACZX,MAAAA,IAAI,EAAEqB,OADM;AAEZnB,MAAAA,oBAAoB,EAAE,KAFV;AAGZC,MAAAA,cAAc,EAAE;AAHJ,KAAd;AAKD;;AAkFD6C,EAAAA,6BAA6B,CAC3BC,wBAD2B,EAE3BC,yBAF2B,EAG3BlC,wBAH2B,EAI3BmC,aAJ2B,EAK3B;AACA,QAAIC,GAAG,GAAGC,IAAI,CAACC,GAAL,CACRL,wBAAwB,CAAC/B,MADjB,EAERgC,yBAAyB,CAAChC,MAFlB,CAAV;;AAIA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIiC,GAArB,EAA0BjC,CAAC,EAA3B,EAA+B;AAC7B,UAAIoC,KAAK,GAAGN,wBAAwB,CAAC9B,CAAD,CAApC;AACA,UAAIqC,KAAK,GAAGN,yBAAyB,CAAC/B,CAAD,CAArC;;AACA,UAAIA,CAAC,KAAK8B,wBAAwB,CAAC/B,MAAnC,EAA2C;AACzCE,QAAAA,UAAU,CAAC,MAAM;AACf,cAAIH,mBAAmB,GAAGwC,sBAAsB,CAC9CR,wBAD8C,EAE9CC,yBAF8C,CAAhD;;AAIA,cAAIC,aAAJ,EAAmB;AACjB,iBAAKpC,mBAAL,CACEC,wBADF,EAEEC,mBAFF;AAID,WALD,MAKO;AACL,iBAAKN,QAAL,CAAc;AAAET,cAAAA,oBAAoB,EAAE;AAAxB,aAAd;AACD;AACF,SAbS,EAaPiB,CAAC,GAAG,KAAKpB,KAAL,CAAWS,KAbR,CAAV;AAcA;AACD;;AACDY,MAAAA,UAAU,CAAC,MAAM;AACf;AACA,YAAImC,KAAK,KAAKG,SAAd,EACElC,QAAQ,CAACC,cAAT,CAAyB,QAAO8B,KAAK,CAAC7B,GAAI,IAAG6B,KAAK,CAAC5B,GAAI,EAAvD,EAA0DC,SAA1D,GACE,mBADF;AAEF,YAAI4B,KAAK,KAAKE,SAAd,EACElC,QAAQ,CAACC,cAAT,CAAyB,QAAO+B,KAAK,CAAC9B,GAAI,IAAG8B,KAAK,CAAC7B,GAAI,EAAvD,EAA0DC,SAA1D,GACE,mBADF;AAEH,OARS,EAQPT,CAAC,GAAG,KAAKpB,KAAL,CAAWS,KARR,CAAV;AASD;AACF;;AAEDmD,EAAAA,iBAAiB,GAAG;AAClB,QAAI,KAAK5D,KAAL,CAAWG,oBAAX,IAAmC,KAAKH,KAAL,CAAWI,cAAlD,EAAkE;AAChE;AACD;;AACD,SAAKQ,QAAL,CAAc;AAAET,MAAAA,oBAAoB,EAAE;AAAxB,KAAd;AACAkB,IAAAA,UAAU,CAAC,MAAM;AACf,YAAM;AAAEpB,QAAAA;AAAF,UAAW,KAAKD,KAAtB;AACA,YAAM6D,SAAS,GAAG5D,IAAI,CAACN,YAAD,CAAJ,CAAmBC,YAAnB,CAAlB;AACA,YAAMkE,UAAU,GAAG7D,IAAI,CAACJ,aAAD,CAAJ,CAAoBC,aAApB,CAAnB;AACA,YAAMoB,mBAAmB,GAAGnC,QAAQ,CAACkB,IAAD,EAAO4D,SAAP,EAAkBC,UAAlB,CAApC;AACA,YAAM7C,wBAAwB,GAAGjC,mCAAmC,CAClE8E,UADkE,CAApE;AAGA,WAAKhC,gBAAL,CAAsBZ,mBAAtB,EAA2CD,wBAA3C;AACD,KATS,EASP,KAAKjB,KAAL,CAAWS,KATJ,CAAV;AAUD;;AAEDsD,EAAAA,cAAc,GAAG;AACf,QAAI,KAAK/D,KAAL,CAAWG,oBAAX,IAAmC,KAAKH,KAAL,CAAWI,cAAlD,EAAkE;AAChE;AACD;;AACD,SAAKQ,QAAL,CAAc;AAAET,MAAAA,oBAAoB,EAAE;AAAxB,KAAd;AACAkB,IAAAA,UAAU,CAAC,MAAM;AACf,YAAM;AAAEpB,QAAAA;AAAF,UAAW,KAAKD,KAAtB;AACA,YAAM6D,SAAS,GAAG5D,IAAI,CAACN,YAAD,CAAJ,CAAmBC,YAAnB,CAAlB;AACA,YAAMkE,UAAU,GAAG7D,IAAI,CAACJ,aAAD,CAAJ,CAAoBC,aAApB,CAAnB;AACA,YAAMoB,mBAAmB,GAAG8C,KAAK,CAAC/D,IAAD,EAAO4D,SAAP,EAAkBC,UAAlB,CAAjC;AACA,YAAM7C,wBAAwB,GAAGgD,gCAAgC,CAC/DH,UAD+D,CAAjE;AAGA,WAAKhC,gBAAL,CAAsBZ,mBAAtB,EAA2CD,wBAA3C;AACD,KATS,EASP,KAAKjB,KAAL,CAAWS,KATJ,CAAV;AAUD;;AAEDyD,EAAAA,YAAY,GAAG;AACb,QAAI,KAAKlE,KAAL,CAAWG,oBAAX,IAAmC,KAAKH,KAAL,CAAWI,cAAlD,EAAkE;AAChE;AACD;;AACD,SAAKQ,QAAL,CAAc;AAAET,MAAAA,oBAAoB,EAAE;AAAxB,KAAd;AACAkB,IAAAA,UAAU,CAAC,MAAM;AACf,YAAM;AAAEpB,QAAAA;AAAF,UAAW,KAAKD,KAAtB;AACA,YAAM6D,SAAS,GAAG5D,IAAI,CAACN,YAAD,CAAJ,CAAmBC,YAAnB,CAAlB;AACA,YAAMkE,UAAU,GAAG7D,IAAI,CAACJ,aAAD,CAAJ,CAAoBC,aAApB,CAAnB;AACA,YAAMoB,mBAAmB,GAAGiD,kBAAkB,CAC5ClE,IAD4C,EAE5C4D,SAF4C,EAG5CC,UAH4C,CAA9C;AAKA,YAAM7C,wBAAwB,GAAGmD,8BAA8B,CAC7DN,UAD6D,CAA/D;AAGA,WAAKhC,gBAAL,CAAsBZ,mBAAtB,EAA2CD,wBAA3C;AACD,KAbS,EAaP,KAAKjB,KAAL,CAAWS,KAbJ,CAAV;AAcD;;AAED4D,EAAAA,YAAY,GAAG;AACb,QAAI,KAAKrE,KAAL,CAAWG,oBAAX,IAAmC,KAAKH,KAAL,CAAWI,cAAlD,EAAkE;AAChE;AACD;;AACD,SAAKQ,QAAL,CAAc;AAAET,MAAAA,oBAAoB,EAAE;AAAxB,KAAd;AACAkB,IAAAA,UAAU,CAAC,MAAM;AACf,YAAM;AAAEpB,QAAAA;AAAF,UAAW,KAAKD,KAAtB;AACA,YAAM6D,SAAS,GAAG5D,IAAI,CAACN,YAAD,CAAJ,CAAmBC,YAAnB,CAAlB;AACA,YAAMkE,UAAU,GAAG7D,IAAI,CAACJ,aAAD,CAAJ,CAAoBC,aAApB,CAAnB;AACA,YAAMoB,mBAAmB,GAAGoD,gBAAgB,CAACrE,IAAD,EAAO4D,SAAP,EAAkBC,UAAlB,CAA5C;AACA,YAAM7C,wBAAwB,GAAGsD,8BAA8B,CAC7DT,UAD6D,CAA/D;AAGA,WAAKhC,gBAAL,CAAsBZ,mBAAtB,EAA2CD,wBAA3C;AACD,KATS,EASP,KAAKjB,KAAL,CAAWS,KATJ,CAAV;AAUD;;AAED+D,EAAAA,mBAAmB,GAAG;AACpB,QAAI,KAAKxE,KAAL,CAAWG,oBAAX,IAAmC,KAAKH,KAAL,CAAWI,cAAlD,EAAkE;AAChE;AACD;;AACD,SAAKQ,QAAL,CAAc;AAAET,MAAAA,oBAAoB,EAAE;AAAxB,KAAd;AACAkB,IAAAA,UAAU,CAAC,MAAM;AACf,YAAM;AAAEpB,QAAAA;AAAF,UAAW,KAAKD,KAAtB;AACA,YAAM6D,SAAS,GAAG5D,IAAI,CAACN,YAAD,CAAJ,CAAmBC,YAAnB,CAAlB;AACA,YAAMkE,UAAU,GAAG7D,IAAI,CAACJ,aAAD,CAAJ,CAAoBC,aAApB,CAAnB;AACA,YAAMoB,mBAAmB,GAAGuD,UAAU,CAACxE,IAAD,EAAO4D,SAAP,EAAkBC,UAAlB,CAAtC;AACA,WAAK5B,iBAAL,CAAuBhB,mBAAvB;AACD,KANS,EAMP,KAAKlB,KAAL,CAAWS,KANJ,CAAV;AAOD;;AAEDiE,EAAAA,kBAAkB,GAAG;AACnB,QAAI,KAAK1E,KAAL,CAAWG,oBAAX,IAAmC,KAAKH,KAAL,CAAWI,cAAlD,EAAkE;AAChE;AACD;;AACD,SAAKQ,QAAL,CAAc;AAAET,MAAAA,oBAAoB,EAAE;AAAxB,KAAd;AACAkB,IAAAA,UAAU,CAAC,MAAM;AACf,YAAM;AAAEpB,QAAAA;AAAF,UAAW,KAAKD,KAAtB;AACA,YAAM6D,SAAS,GAAG5D,IAAI,CAACN,YAAD,CAAJ,CAAmBC,YAAnB,CAAlB;AACA,YAAMkE,UAAU,GAAG7D,IAAI,CAACJ,aAAD,CAAJ,CAAoBC,aAApB,CAAnB;AACA,YAAMoB,mBAAmB,GAAGyD,SAAS,CAAC1E,IAAD,EAAO4D,SAAP,EAAkBC,UAAlB,CAArC;AACA,YAAM7C,wBAAwB,GAAG2D,oCAAoC,CACnEd,UADmE,CAArE;AAGA,WAAKhC,gBAAL,CAAsBZ,mBAAtB,EAA2CD,wBAA3C;AACD,KATS,EASP,KAAKjB,KAAL,CAAWS,KATJ,CAAV;AAUD;;AAEDoE,EAAAA,kCAAkC,GAAG;AACnC,QAAI,KAAK7E,KAAL,CAAWG,oBAAX,IAAmC,KAAKH,KAAL,CAAWI,cAAlD,EAAkE;AAChE;AACD;;AACD,SAAKQ,QAAL,CAAc;AAAET,MAAAA,oBAAoB,EAAE;AAAxB,KAAd;AACAkB,IAAAA,UAAU,CAAC,MAAM;AACf,YAAM;AAAEpB,QAAAA;AAAF,UAAW,KAAKD,KAAtB;AACA,YAAM6D,SAAS,GAAG5D,IAAI,CAACN,YAAD,CAAJ,CAAmBC,YAAnB,CAAlB;AACA,YAAMkE,UAAU,GAAG7D,IAAI,CAACJ,aAAD,CAAJ,CAAoBC,aAApB,CAAnB;AACA,YAAMoB,mBAAmB,GAAG4D,yBAAyB,CACnD7E,IADmD,EAEnD4D,SAFmD,EAGnDC,UAHmD,CAArD;AAKA,YAAMZ,wBAAwB,GAAGhC,mBAAmB,CAAC,CAAD,CAApD;AACA,YAAMiC,yBAAyB,GAAGjC,mBAAmB,CAAC,CAAD,CAArD;AACA,YAAMkC,aAAa,GAAGlC,mBAAmB,CAAC,CAAD,CAAzC;AACA,YAAMD,wBAAwB,GAAG8D,oDAAoD,CACnF7B,wBAAwB,CAACA,wBAAwB,CAAC/B,MAAzB,GAAkC,CAAnC,CAD2D,EAEnFgC,yBAAyB,CAACA,yBAAyB,CAAChC,MAA1B,GAAmC,CAApC,CAF0D,CAArF;AAIA,WAAK8B,6BAAL,CACEC,wBADF,EAEEC,yBAFF,EAGElC,wBAHF,EAIEmC,aAJF;AAMD,KAtBS,EAsBP,KAAKpD,KAAL,CAAWS,KAtBJ,CAAV;AAuBD;;AAsBDuE,EAAAA,kBAAkB,GAAG;AACnB,QAAI,KAAKhF,KAAL,CAAWG,oBAAX,IAAmC,KAAKH,KAAL,CAAWI,cAAlD,EAAkE;AAChE;AACD;;AACD,SAAKQ,QAAL,CAAc;AAAER,MAAAA,cAAc,EAAE;AAAlB,KAAd;AACAiB,IAAAA,UAAU,CAAC,MAAM;AACf,YAAM;AAAEpB,QAAAA;AAAF,UAAW,KAAKD,KAAtB;AACA,YAAM6D,SAAS,GAAG5D,IAAI,CAACN,YAAD,CAAJ,CAAmBC,YAAnB,CAAlB;AACA,YAAMkE,UAAU,GAAG7D,IAAI,CAACJ,aAAD,CAAJ,CAAoBC,aAApB,CAAnB;AACA,YAAMsC,KAAK,GAAG6C,UAAU,CAAChF,IAAD,EAAO4D,SAAP,EAAkBC,UAAlB,CAAxB;AACA,WAAK3B,WAAL,CAAiBC,KAAjB;AACD,KANS,EAMP,KAAKpC,KAAL,CAAWU,SANJ,CAAV;AAOD;;AAEDwE,EAAAA,6BAA6B,GAAG;AAC9B,QAAI,KAAKlF,KAAL,CAAWG,oBAAX,IAAmC,KAAKH,KAAL,CAAWI,cAAlD,EAAkE;AAChE;AACD;;AACD,SAAKQ,QAAL,CAAc;AAAER,MAAAA,cAAc,EAAE;AAAlB,KAAd;AACAiB,IAAAA,UAAU,CAAC,MAAM;AACf,YAAM;AAAEpB,QAAAA;AAAF,UAAW,KAAKD,KAAtB;AACA,YAAM6D,SAAS,GAAG5D,IAAI,CAACN,YAAD,CAAJ,CAAmBC,YAAnB,CAAlB;AACA,YAAMkE,UAAU,GAAG7D,IAAI,CAACJ,aAAD,CAAJ,CAAoBC,aAApB,CAAnB;AACA,YAAMsC,KAAK,GAAGnD,qBAAqB,CAACgB,IAAD,EAAO4D,SAAP,EAAkBC,UAAlB,CAAnC;AACA,WAAK3B,WAAL,CAAiBC,KAAjB;AACD,KANS,EAMP,KAAKpC,KAAL,CAAWU,SANJ,CAAV;AAOD;;AAEDyE,EAAAA,oBAAoB,GAAG;AACrB,QAAI,KAAKnF,KAAL,CAAWG,oBAAX,IAAmC,KAAKH,KAAL,CAAWI,cAAlD,EAAkE;AAChE;AACD;;AACD,SAAKQ,QAAL,CAAc;AAAER,MAAAA,cAAc,EAAE;AAAlB,KAAd;AACAiB,IAAAA,UAAU,CAAC,MAAM;AACf,YAAM;AAAEpB,QAAAA;AAAF,UAAW,KAAKD,KAAtB;AACA,YAAM6D,SAAS,GAAG5D,IAAI,CAACN,YAAD,CAAJ,CAAmBC,YAAnB,CAAlB;AACA,YAAMkE,UAAU,GAAG7D,IAAI,CAACJ,aAAD,CAAJ,CAAoBC,aAApB,CAAnB;AACA,YAAMsC,KAAK,GAAGgD,YAAY,CAACnF,IAAD,EAAO4D,SAAP,EAAkBC,UAAlB,CAA1B;AACA,WAAK3B,WAAL,CAAiBC,KAAjB;AACD,KANS,EAMP,KAAKpC,KAAL,CAAWU,SANJ,CAAV;AAOD;;AAED2E,EAAAA,sBAAsB,GAAG;AACvB,QAAI,KAAKrF,KAAL,CAAWG,oBAAX,IAAmC,KAAKH,KAAL,CAAWI,cAAlD,EAAkE;AAChE;AACD;;AACD,SAAKQ,QAAL,CAAc;AAAER,MAAAA,cAAc,EAAE;AAAlB,KAAd;AACAiB,IAAAA,UAAU,CAAC,MAAM;AACf,YAAM;AAAEpB,QAAAA;AAAF,UAAW,KAAKD,KAAtB;AACA,YAAM6D,SAAS,GAAG5D,IAAI,CAACN,YAAD,CAAJ,CAAmBC,YAAnB,CAAlB;AACA,YAAMkE,UAAU,GAAG7D,IAAI,CAACJ,aAAD,CAAJ,CAAoBC,aAApB,CAAnB;AACA,YAAMsC,KAAK,GAAGkD,cAAc,CAACrF,IAAD,EAAO4D,SAAP,EAAkBC,UAAlB,CAA5B;AACA,WAAK3B,WAAL,CAAiBC,KAAjB;AACD,KANS,EAMP,KAAKpC,KAAL,CAAWU,SANJ,CAAV;AAOD;;AAED6E,EAAAA,MAAM,GAAG;AACP,QAAI;AAAEtF,MAAAA;AAAF,QAAW,KAAKD,KAApB;AACA,wBACE,oBAAC,KAAD,CAAO,QAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBACE,oBAAC,MAAD;AACE,MAAA,oBAAoB,EAAE,KAAKA,KAAL,CAAWG,oBADnC;AAEE,MAAA,cAAc,EAAE,KAAKH,KAAL,CAAWI,cAF7B;AAGE,MAAA,iBAAiB,EAAE,KAAKwD,iBAAL,CAAuB4B,IAAvB,CAA4B,IAA5B,CAHrB;AAIE,MAAA,cAAc,EAAE,KAAKzB,cAAL,CAAoByB,IAApB,CAAyB,IAAzB,CAJlB;AAKE,MAAA,kBAAkB,EAAE,KAAKd,kBAAL,CAAwBc,IAAxB,CAA6B,IAA7B,CALtB;AAME,MAAA,kCAAkC,EAAE,KAAKX,kCAAL,CAAwCW,IAAxC,CAClC,IADkC,CANtC;AASE,MAAA,YAAY,EAAE,KAAKtB,YAAL,CAAkBsB,IAAlB,CAAuB,IAAvB,CAThB;AAUE,MAAA,YAAY,EAAE,KAAKnB,YAAL,CAAkBmB,IAAlB,CAAuB,IAAvB,CAVhB;AAWE,MAAA,mBAAmB,EAAE,KAAKhB,mBAAL,CAAyBgB,IAAzB,CAA8B,IAA9B,CAXvB;AAYE,MAAA,kBAAkB,EAAE,KAAKR,kBAAL,CAAwBQ,IAAxB,CAA6B,IAA7B,CAZtB;AAaE,MAAA,6BAA6B,EAAE,KAAKN,6BAAL,CAAmCM,IAAnC,CAC7B,IAD6B,CAbjC;AAgBE,MAAA,oBAAoB,EAAE,KAAKL,oBAAL,CAA0BK,IAA1B,CAA+B,IAA/B,CAhBxB;AAiBE,MAAA,sBAAsB,EAAE,KAAKH,sBAAL,CAA4BG,IAA5B,CAAiC,IAAjC,CAjB1B;AAkBE,MAAA,SAAS,EAAE,KAAKnD,SAAL,CAAemD,IAAf,CAAoB,IAApB,CAlBb;AAmBE,MAAA,SAAS,EAAE,KAAKzC,SAAL,CAAeyC,IAAf,CAAoB,IAApB,CAnBb;AAoBE,MAAA,WAAW,EAAE,KAAK3E,WAAL,CAAiB2E,IAAjB,CAAsB,IAAtB,CApBf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MADF,eAuBE;AACE,MAAA,SAAS,EACP,KAAKxF,KAAL,CAAWG,oBAAX,IAAmC,KAAKH,KAAL,CAAWI,cAA9C,GACI,kBADJ,GAEI,MAJR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAOGH,IAAI,CAACwF,GAAL,CAAS,CAAC9D,GAAD,EAAM+D,KAAN,KAAgB;AACxB,0BACE;AAAK,QAAA,GAAG,EAAEA,KAAV;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SACG/D,GAAG,CAAC8D,GAAJ,CAAQ,CAACjE,IAAD,EAAOmE,MAAP,KAAkB;AACzB,cAAM;AACJhE,UAAAA,GADI;AAEJC,UAAAA,GAFI;AAGJgE,UAAAA,OAHI;AAIJC,UAAAA,QAJI;AAKJ5D,UAAAA,SALI;AAMJ6D,UAAAA,UANI;AAOJC,UAAAA;AAPI,YAQFvE,IARJ;AASA,4BACE,oBAAC,IAAD;AACE,UAAA,GAAG,EAAEmE,MADP;AAEE,UAAA,GAAG,EAAEhE,GAFP;AAGE,UAAA,GAAG,EAAEC,GAHP;AAIE,UAAA,OAAO,EAAEgE,OAJX;AAKE,UAAA,QAAQ,EAAEC,QALZ;AAME,UAAA,SAAS,EAAE5D,SANb;AAOE,UAAA,UAAU,EAAE6D,UAPd;AAQE,UAAA,MAAM,EAAEC,MARV;AASE,UAAA,WAAW,EAAE,CAACpE,GAAD,EAAMC,GAAN,KAAc,KAAKe,eAAL,CAAqBhB,GAArB,EAA0BC,GAA1B,CAT7B;AAUE,UAAA,YAAY,EAAE,CAACD,GAAD,EAAMC,GAAN,KACZ,KAAKiB,gBAAL,CAAsBlB,GAAtB,EAA2BC,GAA3B,CAXJ;AAaE,UAAA,SAAS,EAAE,MAAM,KAAKkB,aAAL,EAbnB;AAcE,UAAA,KAAK,EAAE,KAAK9C,KAAL,CAAWK,KAdpB;AAeE,UAAA,MAAM,EAAE,KAAKL,KAAL,CAAWM,MAfrB;AAgBE,UAAA,OAAO,EAAE,KAAKN,KAAL,CAAWO,OAhBtB;AAiBE,UAAA,UAAU,EAAE,KAAKP,KAAL,CAAWQ,UAjBzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UADF;AAqBD,OA/BA,CADH,CADF;AAoCD,KArCA,CAPH,CAvBF,CADF;AAwED;;AAlf2C;;AAqf9C,SAASrB,aAAT,CAAuBkB,KAAvB,EAA8BC,MAA9B,EAAsC;AACpC,MAAIE,UAAJ;;AACA,MAAIH,KAAK,GAAG,IAAZ,EAAkB;AAChBG,IAAAA,UAAU,GAAG8C,IAAI,CAAC0C,KAAL,CAAW3F,KAAK,GAAG,EAAnB,CAAb;AACD,GAFD,MAEO,IAAIA,KAAK,GAAG,IAAZ,EAAkB;AACvBG,IAAAA,UAAU,GAAG8C,IAAI,CAAC0C,KAAL,CAAW3F,KAAK,GAAG,IAAnB,CAAb;AACD,GAFM,MAEA,IAAIA,KAAK,GAAG,IAAZ,EAAkB;AACvBG,IAAAA,UAAU,GAAG8C,IAAI,CAAC0C,KAAL,CAAW3F,KAAK,GAAG,EAAnB,CAAb;AACD,GAFM,MAEA,IAAIA,KAAK,GAAG,GAAZ,EAAiB;AACtBG,IAAAA,UAAU,GAAG8C,IAAI,CAAC0C,KAAL,CAAW3F,KAAK,GAAG,IAAnB,CAAb;AACD,GAFM,MAEA,IAAIA,KAAK,GAAG,GAAZ,EAAiB;AACtBG,IAAAA,UAAU,GAAG8C,IAAI,CAAC0C,KAAL,CAAW3F,KAAK,GAAG,EAAnB,CAAb;AACD,GAFM,MAEA,IAAIA,KAAK,GAAG,GAAZ,EAAiB;AACtBG,IAAAA,UAAU,GAAG8C,IAAI,CAAC0C,KAAL,CAAW3F,KAAK,GAAG,IAAnB,CAAb;AACD,GAFM,MAEA,IAAIA,KAAK,GAAG,CAAZ,EAAe;AACpBG,IAAAA,UAAU,GAAG8C,IAAI,CAAC0C,KAAL,CAAW3F,KAAK,GAAG,EAAnB,CAAb;AACD;;AACD,MAAI4F,SAAS,GAAG3C,IAAI,CAAC0C,KAAL,CAAW3F,KAAK,GAAGG,UAAnB,CAAhB;AACA,MAAID,OAAO,GAAG+C,IAAI,CAAC0C,KAAL,CAAW1F,MAAM,GAAG2F,SAApB,CAAd;AACA,SAAO,CAAC1F,OAAD,EAAUC,UAAV,CAAP;AACD;;AAED,SAAS0F,aAAT,CAAuBC,GAAvB,EAA4B;AAC1B,MAAIC,WAAW,GAAG,EAAlB;AACA,MAAIC,IAAI,GAAG,CAAX;;AACA,OAAK,IAAIjF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+E,GAAG,GAAG,CAA1B,EAA6B/E,CAAC,IAAI,CAAlC,EAAqC;AACnCgF,IAAAA,WAAW,CAACE,IAAZ,CAAiBD,IAAjB;AACAA,IAAAA,IAAI,IAAI,CAAR;AACD;;AACD,MAAIE,WAAW,GAAG,EAAlB;AACAF,EAAAA,IAAI,GAAG,CAAC,CAAR;;AACA,OAAK,IAAIjF,CAAC,GAAG+E,GAAG,GAAG,CAAnB,EAAsB/E,CAAC,GAAG+E,GAAG,GAAG,CAAhC,EAAmC/E,CAAC,IAAI,CAAxC,EAA2C;AACzCmF,IAAAA,WAAW,CAACD,IAAZ,CAAiBD,IAAjB;AACAA,IAAAA,IAAI,IAAI,CAAR;AACD;;AACD,SAAO,CAACD,WAAD,EAAcG,WAAd,CAAP;AACD;;AAED,SAAS7G,kBAAT,CAA4Ba,OAA5B,EAAqCC,UAArC,EAAiD;AAC/C,MAAIgG,UAAJ;AACA,MAAIC,CAAJ;AACA,MAAIC,CAAJ;AACA,MAAI/G,YAAJ;AACA,MAAIC,YAAJ;AACA,MAAIC,aAAJ;AACA,MAAIC,aAAJ;;AACA,MAAIS,OAAO,GAAGC,UAAd,EAA0B;AACxBgG,IAAAA,UAAU,GAAGN,aAAa,CAAC3F,OAAD,CAA1B;AACAkG,IAAAA,CAAC,GAAGnD,IAAI,CAAC0C,KAAL,CAAWzF,OAAO,GAAG,CAArB,CAAJ;AACAmG,IAAAA,CAAC,GAAGpD,IAAI,CAAC0C,KAAL,CAAWxF,UAAU,GAAG,CAAxB,CAAJ;AACA,QAAIiG,CAAC,GAAG,CAAJ,KAAU,CAAd,EAAiBA,CAAC,IAAI,CAAL;AACjB,QAAIC,CAAC,GAAG,CAAJ,KAAU,CAAd,EAAiBA,CAAC,IAAI,CAAL;AACjB/G,IAAAA,YAAY,GACV8G,CAAC,GAAGD,UAAU,CAAC,CAAD,CAAV,CAAclD,IAAI,CAAC0C,KAAL,CAAW1C,IAAI,CAACqD,MAAL,KAAgBH,UAAU,CAAC,CAAD,CAAV,CAAcrF,MAAzC,CAAd,CADN;AAEAvB,IAAAA,YAAY,GAAG8G,CAAC,GAAG,CAAC,CAAC,CAAF,EAAK,CAAC,CAAN,EAAS,CAAC,CAAV,EAAa,CAAb,EAAgBpD,IAAI,CAAC0C,KAAL,CAAW1C,IAAI,CAACqD,MAAL,KAAgB,CAA3B,CAAhB,CAAnB;AACA9G,IAAAA,aAAa,GACX4G,CAAC,GAAGD,UAAU,CAAC,CAAD,CAAV,CAAclD,IAAI,CAAC0C,KAAL,CAAW1C,IAAI,CAACqD,MAAL,KAAgBH,UAAU,CAAC,CAAD,CAAV,CAAcrF,MAAzC,CAAd,CADN;AAEArB,IAAAA,aAAa,GACXU,UAAU,GAAGkG,CAAb,GAAiB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAapD,IAAI,CAAC0C,KAAL,CAAW1C,IAAI,CAACqD,MAAL,KAAgB,CAA3B,CAAb,CADnB;AAED,GAbD,MAaO;AACLH,IAAAA,UAAU,GAAGN,aAAa,CAAC1F,UAAD,CAA1B;AACAiG,IAAAA,CAAC,GAAGnD,IAAI,CAAC0C,KAAL,CAAWzF,OAAO,GAAG,CAArB,CAAJ;AACAmG,IAAAA,CAAC,GAAGpD,IAAI,CAAC0C,KAAL,CAAWxF,UAAU,GAAG,CAAxB,CAAJ;AACA,QAAIiG,CAAC,GAAG,CAAJ,KAAU,CAAd,EAAiBA,CAAC,IAAI,CAAL;AACjB,QAAIC,CAAC,GAAG,CAAJ,KAAU,CAAd,EAAiBA,CAAC,IAAI,CAAL;AACjB/G,IAAAA,YAAY,GAAG8G,CAAC,GAAG,CAAC,CAAC,CAAF,EAAK,CAAC,CAAN,EAAS,CAAC,CAAV,EAAa,CAAb,EAAgBnD,IAAI,CAAC0C,KAAL,CAAW1C,IAAI,CAACqD,MAAL,KAAgB,CAA3B,CAAhB,CAAnB;AACA/G,IAAAA,YAAY,GACV8G,CAAC,GAAGF,UAAU,CAAC,CAAD,CAAV,CAAclD,IAAI,CAAC0C,KAAL,CAAW1C,IAAI,CAACqD,MAAL,KAAgBH,UAAU,CAAC,CAAD,CAAV,CAAcrF,MAAzC,CAAd,CADN;AAEAtB,IAAAA,aAAa,GAAGU,OAAO,GAAGkG,CAAV,GAAc,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAanD,IAAI,CAAC0C,KAAL,CAAW1C,IAAI,CAACqD,MAAL,KAAgB,CAA3B,CAAb,CAA9B;AACA7G,IAAAA,aAAa,GACX4G,CAAC,GAAGF,UAAU,CAAC,CAAD,CAAV,CAAclD,IAAI,CAAC0C,KAAL,CAAW1C,IAAI,CAACqD,MAAL,KAAgBH,UAAU,CAAC,CAAD,CAAV,CAAcrF,MAAzC,CAAd,CADN;AAED;;AACD,SAAO,CAACxB,YAAD,EAAeC,YAAf,EAA6BC,aAA7B,EAA4CC,aAA5C,CAAP;AACD;;AAED,MAAM4C,cAAc,GAAG,CAACnC,OAAD,EAAUC,UAAV,KAAyB;AAC9C,MAAIP,IAAI,GAAG,EAAX;;AACA,OAAK,IAAI0B,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGpB,OAAxB,EAAiCoB,GAAG,EAApC,EAAwC;AACtC,QAAIiF,UAAU,GAAG,EAAjB;;AACA,SAAK,IAAIhF,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGpB,UAAxB,EAAoCoB,GAAG,EAAvC,EAA2C;AACzCgF,MAAAA,UAAU,CAACN,IAAX,CAAgBO,UAAU,CAAClF,GAAD,EAAMC,GAAN,CAA1B;AACD;;AACD3B,IAAAA,IAAI,CAACqG,IAAL,CAAUM,UAAV;AACD;;AACD,SAAO3G,IAAP;AACD,CAVD;;AAYA,MAAM4G,UAAU,GAAG,CAAClF,GAAD,EAAMC,GAAN,KAAc;AAC/B,SAAO;AACLD,IAAAA,GADK;AAELC,IAAAA,GAFK;AAGLgE,IAAAA,OAAO,EAAEjE,GAAG,KAAKhC,YAAR,IAAwBiC,GAAG,KAAKhC,YAHpC;AAILiG,IAAAA,QAAQ,EAAElE,GAAG,KAAK9B,aAAR,IAAyB+B,GAAG,KAAK9B,aAJtC;AAKLgH,IAAAA,QAAQ,EAAEC,QALL;AAMLC,IAAAA,aAAa,EAAED,QANV;AAOL9E,IAAAA,SAAS,EAAE,KAPN;AAQL6D,IAAAA,UAAU,EAAE,KARP;AASLC,IAAAA,MAAM,EAAE,KATH;AAULkB,IAAAA,YAAY,EAAE;AAVT,GAAP;AAYD,CAbD;;AAeA,MAAMrE,mBAAmB,GAAG,CAAC3C,IAAD,EAAO0B,GAAP,EAAYC,GAAZ,KAAoB;AAC9C,MAAIN,OAAO,GAAGrB,IAAI,CAAC8B,KAAL,EAAd;AACA,MAAIP,IAAI,GAAGvB,IAAI,CAAC0B,GAAD,CAAJ,CAAUC,GAAV,CAAX;AACA,MAAII,OAAO,GAAG,EACZ,GAAGR,IADS;AAEZuE,IAAAA,MAAM,EAAE,CAACvE,IAAI,CAACuE;AAFF,GAAd;AAIAzE,EAAAA,OAAO,CAACK,GAAD,CAAP,CAAaC,GAAb,IAAoBI,OAApB;AACA,SAAOV,OAAP;AACD,CATD;;AAWA,MAAMgB,kBAAkB,GAAG,CAACrC,IAAD,EAAOmC,KAAP,KAAiB;AAC1C,MAAId,OAAO,GAAGrB,IAAI,CAAC8B,KAAL,EAAd;;AACA,OAAK,IAAIQ,IAAT,IAAiBH,KAAjB,EAAwB;AACtB,QAAIZ,IAAI,GAAGvB,IAAI,CAACsC,IAAI,CAAC,CAAD,CAAL,CAAJ,CAAcA,IAAI,CAAC,CAAD,CAAlB,CAAX;AACA,QAAIP,OAAO,GAAG,EACZ,GAAGR,IADS;AAEZuE,MAAAA,MAAM,EAAE;AAFI,KAAd;AAIAzE,IAAAA,OAAO,CAACiB,IAAI,CAAC,CAAD,CAAL,CAAP,CAAiBA,IAAI,CAAC,CAAD,CAArB,IAA4BP,OAA5B;AACD;;AACD,SAAOV,OAAP;AACD,CAXD;;AAaA,MAAM0B,kBAAkB,GAAI/C,IAAD,IAAU;AACnC,MAAIqB,OAAO,GAAGrB,IAAI,CAAC8B,KAAL,EAAd;;AACA,OAAK,IAAIJ,GAAT,IAAgB1B,IAAhB,EAAsB;AACpB,SAAK,IAAIuB,IAAT,IAAiBG,GAAjB,EAAsB;AACpB,UAAIK,OAAO,GAAG,EACZ,GAAGR,IADS;AAEZsF,QAAAA,QAAQ,EAAEC,QAFE;AAGZC,QAAAA,aAAa,EAAED,QAHH;AAIZ9E,QAAAA,SAAS,EAAE,KAJC;AAKZ6D,QAAAA,UAAU,EAAE,KALA;AAMZmB,QAAAA,YAAY,EAAE;AANF,OAAd;AAQA3F,MAAAA,OAAO,CAACE,IAAI,CAACG,GAAN,CAAP,CAAkBH,IAAI,CAACI,GAAvB,IAA8BI,OAA9B;AACD;AACF;;AACD,SAAOV,OAAP;AACD,CAhBD;;AAkBA,MAAMC,oBAAoB,GAAG,CAC3BtB,IAD2B,EAE3BgB,wBAF2B,EAG3BC,mBAH2B,KAIxB;AACH,MAAII,OAAO,GAAGrB,IAAI,CAAC8B,KAAL,EAAd;;AACA,OAAK,IAAIP,IAAT,IAAiBN,mBAAjB,EAAsC;AACpC,QACGM,IAAI,CAACG,GAAL,KAAahC,YAAb,IAA6B6B,IAAI,CAACI,GAAL,KAAahC,YAA3C,IACC4B,IAAI,CAACG,GAAL,KAAa9B,aAAb,IAA8B2B,IAAI,CAACI,GAAL,KAAa9B,aAF9C,EAIE;AACF,QAAIkC,OAAO,GAAG,EACZ,GAAGR,IADS;AAEZS,MAAAA,SAAS,EAAE;AAFC,KAAd;AAIAX,IAAAA,OAAO,CAACE,IAAI,CAACG,GAAN,CAAP,CAAkBH,IAAI,CAACI,GAAvB,IAA8BI,OAA9B;AACD;;AACD,OAAK,IAAIR,IAAT,IAAiBP,wBAAjB,EAA2C;AACzC,QAAIO,IAAI,CAACG,GAAL,KAAa9B,aAAb,IAA8B2B,IAAI,CAACI,GAAL,KAAa9B,aAA/C,EAA8D;AAC5D,aAAOwB,OAAP;AACD;;AACD,QAAIU,OAAO,GAAG,EACZ,GAAGR,IADS;AAEZS,MAAAA,SAAS,EAAE,KAFC;AAGZ6D,MAAAA,UAAU,EAAE;AAHA,KAAd;AAKAxE,IAAAA,OAAO,CAACE,IAAI,CAACG,GAAN,CAAP,CAAkBH,IAAI,CAACI,GAAvB,IAA8BI,OAA9B;AACD;AACF,CA7BD;;AA+BA,MAAM0B,sBAAsB,GAAG,CAC7BR,wBAD6B,EAE7BC,yBAF6B,KAG1B;AACH,MAAIjC,mBAAmB,GAAG,EAA1B;AACA,MAAIgG,CAAC,GAAG5D,IAAI,CAACC,GAAL,CACNL,wBAAwB,CAAC/B,MADnB,EAENgC,yBAAyB,CAAChC,MAFpB,CAAR;;AAIA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG8F,CAApB,EAAuB9F,CAAC,EAAxB,EAA4B;AAC1B,QAAI8B,wBAAwB,CAAC9B,CAAD,CAAxB,KAAgCuC,SAApC,EAA+C;AAC7CzC,MAAAA,mBAAmB,CAACoF,IAApB,CAAyBpD,wBAAwB,CAAC9B,CAAD,CAAjD;AACD;;AACD,QAAI+B,yBAAyB,CAAC/B,CAAD,CAAzB,KAAiCuC,SAArC,EAAgD;AAC9CzC,MAAAA,mBAAmB,CAACoF,IAApB,CAAyBnD,yBAAyB,CAAC/B,CAAD,CAAlD;AACD;AACF;;AACD,SAAOF,mBAAP;AACD,CAlBD;;AAoBA,eAAenB,qBAAf;AAEA","sourcesContent":["import React, { Component } from \"react\";\nimport \"./pathfindingVisualizer.css\";\nimport Node from \"./Node/node\";\nimport NavBar from \"./navbar\";\n\n//Pathfinding Algorithms\nimport {\n  dijkstra,\n  getNodesInShortestPathOrderDijkstra,\n} from \"../pathfindingAlgorithms/dijkstra\";\n\n\n//Maze Algorithms\nimport { recursiveDivisionMaze } from \"../mazeAlgorithms/recursiveDivision\";\n\n\nconst initialNum = getInitialNum(window.innerWidth, window.innerHeight);\nconst initialNumRows = initialNum[0];\nconst initialNumColumns = initialNum[1];\n\nconst startFinishNode = getStartFinishNode(initialNumRows, initialNumColumns);\nconst startNodeRow = startFinishNode[0];\nconst startNodeCol = startFinishNode[1];\nconst finishNodeRow = startFinishNode[2];\nconst finishNodeCol = startFinishNode[3];\n\nclass PathfindingVisualizer extends Component {\n  state = {\n    grid: [],\n    mouseIsPressed: false,\n    visualizingAlgorithm: false,\n    generatingMaze: false,\n    width: window.innerWidth,\n    height: window.innerHeight,\n    numRows: initialNumRows,\n    numColumns: initialNumColumns,\n    speed: 10,\n    mazeSpeed: 10,\n  };\n\n  updateDimensions = () => {\n    this.setState({\n      width: window.innerWidth,\n      height: window.innerHeight,\n    });\n  };\n\n  updateSpeed = (path, maze) => {\n    this.setState({ speed: path, mazeSpeed: maze });\n  };\n\n  componentDidMount() {\n    window.addEventListener(\"resize\", this.updateDimensions);\n    const grid = getInitialGrid(this.state.numRows, this.state.numColumns);\n    this.setState({ grid });\n  }\n\n  handleMouseDown(row, col) {\n    const newGrid = getNewGridWithWalls(this.state.grid, row, col);\n    this.setState({ grid: newGrid, mouseIsPressed: true });\n  }\n\n  handleMouseEnter(row, col) {\n    if (this.state.mouseIsPressed) {\n      const newGrid = getNewGridWithWalls(this.state.grid, row, col);\n      this.setState({ grid: newGrid, mouseIsPressed: true });\n    }\n  }\n\n  handleMouseUp() {\n    this.setState({ mouseIsPressed: false });\n  }\n\n  clearGrid() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n    for (let row = 0; row < this.state.grid.length; row++) {\n      for (let col = 0; col < this.state.grid[0].length; col++) {\n        if (\n          !(\n            (row === startNodeRow && col === startNodeCol) ||\n            (row === finishNodeRow && col === finishNodeCol)\n          )\n        ) {\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\n        }\n      }\n    }\n    const newGrid = getInitialGrid(this.state.numRows, this.state.numColumns);\n    this.setState({\n      grid: newGrid,\n      visualizingAlgorithm: false,\n      generatingMaze: false,\n    });\n  }\n\n  clearPath() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n    for (let row = 0; row < this.state.grid.length; row++) {\n      for (let col = 0; col < this.state.grid[0].length; col++) {\n        if (\n          document.getElementById(`node-${row}-${col}`).className ===\n          \"node node-shortest-path\"\n        ) {\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\n        }\n      }\n    }\n    const newGrid = getGridWithoutPath(this.state.grid);\n    this.setState({\n      grid: newGrid,\n      visualizingAlgorithm: false,\n      generatingMaze: false,\n    });\n  }\n\n  animateShortestPath = (nodesInShortestPathOrder, visitedNodesInOrder) => {\n    if (nodesInShortestPathOrder.length === 1)\n      this.setState({ visualizingAlgorithm: false });\n    for (let i = 1; i < nodesInShortestPathOrder.length; i++) {\n      if (i === nodesInShortestPathOrder.length - 1) {\n        setTimeout(() => {\n          let newGrid = updateNodesForRender(\n            this.state.grid,\n            nodesInShortestPathOrder,\n            visitedNodesInOrder\n          );\n          this.setState({ grid: newGrid, visualizingAlgorithm: false });\n        }, i * (3 * this.state.speed));\n        return;\n      }\n      let node = nodesInShortestPathOrder[i];\n      setTimeout(() => {\n        //shortest path node\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-shortest-path\";\n      }, i * (3 * this.state.speed));\n    }\n  };\n\n  animateAlgorithm = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n    let newGrid = this.state.grid.slice();\n    for (let row of newGrid) {\n      for (let node of row) {\n        let newNode = {\n          ...node,\n          isVisited: false,\n        };\n        newGrid[node.row][node.col] = newNode;\n      }\n    }\n    this.setState({ grid: newGrid });\n    for (let i = 1; i <= visitedNodesInOrder.length; i++) {\n      let node = visitedNodesInOrder[i];\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(\n            nodesInShortestPathOrder,\n            visitedNodesInOrder\n          );\n        }, i * this.state.speed);\n        return;\n      }\n      setTimeout(() => {\n        //visited node\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-visited\";\n      }, i * this.state.speed);\n    }\n  };\n\n  animateRandomWalk = (visitedNodesInOrder) => {\n    for (let i = 1; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.setState({ visualizingAlgorithm: false });\n        }, i * this.state.speed);\n        return;\n      }\n      let node = visitedNodesInOrder[i];\n      if (i === visitedNodesInOrder.length - 1) {\n        setTimeout(() => {\n          //finish node\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-finish-reached\";\n        }, i * this.state.speed);\n        continue;\n      }\n      setTimeout(() => {\n        //visited node\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-visited\";\n      }, i * this.state.speed);\n    }\n  };\n\n  animateBidirectionalAlgorithm(\n    visitedNodesInOrderStart,\n    visitedNodesInOrderFinish,\n    nodesInShortestPathOrder,\n    isShortedPath\n  ) {\n    let len = Math.max(\n      visitedNodesInOrderStart.length,\n      visitedNodesInOrderFinish.length\n    );\n    for (let i = 1; i <= len; i++) {\n      let nodeA = visitedNodesInOrderStart[i];\n      let nodeB = visitedNodesInOrderFinish[i];\n      if (i === visitedNodesInOrderStart.length) {\n        setTimeout(() => {\n          let visitedNodesInOrder = getVisitedNodesInOrder(\n            visitedNodesInOrderStart,\n            visitedNodesInOrderFinish\n          );\n          if (isShortedPath) {\n            this.animateShortestPath(\n              nodesInShortestPathOrder,\n              visitedNodesInOrder\n            );\n          } else {\n            this.setState({ visualizingAlgorithm: false });\n          }\n        }, i * this.state.speed);\n        return;\n      }\n      setTimeout(() => {\n        //visited nodes\n        if (nodeA !== undefined)\n          document.getElementById(`node-${nodeA.row}-${nodeA.col}`).className =\n            \"node node-visited\";\n        if (nodeB !== undefined)\n          document.getElementById(`node-${nodeB.row}-${nodeB.col}`).className =\n            \"node node-visited\";\n      }, i * this.state.speed);\n    }\n  }\n\n  visualizeDijkstra() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n    this.setState({ visualizingAlgorithm: true });\n    setTimeout(() => {\n      const { grid } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n      const nodesInShortestPathOrder = getNodesInShortestPathOrderDijkstra(\n        finishNode\n      );\n      this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, this.state.speed);\n  }\n\n  visualizeAStar() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n    this.setState({ visualizingAlgorithm: true });\n    setTimeout(() => {\n      const { grid } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const visitedNodesInOrder = astar(grid, startNode, finishNode);\n      const nodesInShortestPathOrder = getNodesInShortestPathOrderAstar(\n        finishNode\n      );\n      this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, this.state.speed);\n  }\n\n  visualizeBFS() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n    this.setState({ visualizingAlgorithm: true });\n    setTimeout(() => {\n      const { grid } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const visitedNodesInOrder = breadthFirstSearch(\n        grid,\n        startNode,\n        finishNode\n      );\n      const nodesInShortestPathOrder = getNodesInShortestPathOrderBFS(\n        finishNode\n      );\n      this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, this.state.speed);\n  }\n\n  visualizeDFS() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n    this.setState({ visualizingAlgorithm: true });\n    setTimeout(() => {\n      const { grid } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const visitedNodesInOrder = depthFirstSearch(grid, startNode, finishNode);\n      const nodesInShortestPathOrder = getNodesInShortestPathOrderDFS(\n        finishNode\n      );\n      this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, this.state.speed);\n  }\n\n  visualizeRandomWalk() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n    this.setState({ visualizingAlgorithm: true });\n    setTimeout(() => {\n      const { grid } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const visitedNodesInOrder = randomWalk(grid, startNode, finishNode);\n      this.animateRandomWalk(visitedNodesInOrder);\n    }, this.state.speed);\n  }\n\n  visualizeGreedyBFS() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n    this.setState({ visualizingAlgorithm: true });\n    setTimeout(() => {\n      const { grid } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const visitedNodesInOrder = greedyBFS(grid, startNode, finishNode);\n      const nodesInShortestPathOrder = getNodesInShortestPathOrderGreedyBFS(\n        finishNode\n      );\n      this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, this.state.speed);\n  }\n\n  visualizeBidirectionalGreedySearch() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n    this.setState({ visualizingAlgorithm: true });\n    setTimeout(() => {\n      const { grid } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const visitedNodesInOrder = bidirectionalGreedySearch(\n        grid,\n        startNode,\n        finishNode\n      );\n      const visitedNodesInOrderStart = visitedNodesInOrder[0];\n      const visitedNodesInOrderFinish = visitedNodesInOrder[1];\n      const isShortedPath = visitedNodesInOrder[2];\n      const nodesInShortestPathOrder = getNodesInShortestPathOrderBidirectionalGreedySearch(\n        visitedNodesInOrderStart[visitedNodesInOrderStart.length - 1],\n        visitedNodesInOrderFinish[visitedNodesInOrderFinish.length - 1]\n      );\n      this.animateBidirectionalAlgorithm(\n        visitedNodesInOrderStart,\n        visitedNodesInOrderFinish,\n        nodesInShortestPathOrder,\n        isShortedPath\n      );\n    }, this.state.speed);\n  }\n\n  animateMaze = (walls) => {\n    for (let i = 0; i <= walls.length; i++) {\n      if (i === walls.length) {\n        setTimeout(() => {\n          this.clearGrid();\n          let newGrid = getNewGridWithMaze(this.state.grid, walls);\n          this.setState({ grid: newGrid, generatingMaze: false });\n        }, i * this.state.mazeSpeed);\n        return;\n      }\n      let wall = walls[i];\n      let node = this.state.grid[wall[0]][wall[1]];\n      setTimeout(() => {\n        //Walls\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-wall-animated\";\n      }, i * this.state.mazeSpeed);\n    }\n  };\n\n  generateRandomMaze() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n    this.setState({ generatingMaze: true });\n    setTimeout(() => {\n      const { grid } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const walls = randomMaze(grid, startNode, finishNode);\n      this.animateMaze(walls);\n    }, this.state.mazeSpeed);\n  }\n\n  generateRecursiveDivisionMaze() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n    this.setState({ generatingMaze: true });\n    setTimeout(() => {\n      const { grid } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const walls = recursiveDivisionMaze(grid, startNode, finishNode);\n      this.animateMaze(walls);\n    }, this.state.mazeSpeed);\n  }\n\n  generateVerticalMaze() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n    this.setState({ generatingMaze: true });\n    setTimeout(() => {\n      const { grid } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const walls = verticalMaze(grid, startNode, finishNode);\n      this.animateMaze(walls);\n    }, this.state.mazeSpeed);\n  }\n\n  generateHorizontalMaze() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n      return;\n    }\n    this.setState({ generatingMaze: true });\n    setTimeout(() => {\n      const { grid } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const walls = horizontalMaze(grid, startNode, finishNode);\n      this.animateMaze(walls);\n    }, this.state.mazeSpeed);\n  }\n\n  render() {\n    let { grid } = this.state;\n    return (\n      <React.Fragment>\n        <NavBar\n          visualizingAlgorithm={this.state.visualizingAlgorithm}\n          generatingMaze={this.state.generatingMaze}\n          visualizeDijkstra={this.visualizeDijkstra.bind(this)}\n          visualizeAStar={this.visualizeAStar.bind(this)}\n          visualizeGreedyBFS={this.visualizeGreedyBFS.bind(this)}\n          visualizeBidirectionalGreedySearch={this.visualizeBidirectionalGreedySearch.bind(\n            this\n          )}\n          visualizeBFS={this.visualizeBFS.bind(this)}\n          visualizeDFS={this.visualizeDFS.bind(this)}\n          visualizeRandomWalk={this.visualizeRandomWalk.bind(this)}\n          generateRandomMaze={this.generateRandomMaze.bind(this)}\n          generateRecursiveDivisionMaze={this.generateRecursiveDivisionMaze.bind(\n            this\n          )}\n          generateVerticalMaze={this.generateVerticalMaze.bind(this)}\n          generateHorizontalMaze={this.generateHorizontalMaze.bind(this)}\n          clearGrid={this.clearGrid.bind(this)}\n          clearPath={this.clearPath.bind(this)}\n          updateSpeed={this.updateSpeed.bind(this)}\n        />\n        <div\n          className={\n            this.state.visualizingAlgorithm || this.state.generatingMaze\n              ? \"grid-visualizing\"\n              : \"grid\"\n          }\n        >\n          {grid.map((row, rowId) => {\n            return (\n              <div key={rowId}>\n                {row.map((node, nodeId) => {\n                  const {\n                    row,\n                    col,\n                    isStart,\n                    isFinish,\n                    isVisited,\n                    isShortest,\n                    isWall,\n                  } = node;\n                  return (\n                    <Node\n                      key={nodeId}\n                      row={row}\n                      col={col}\n                      isStart={isStart}\n                      isFinish={isFinish}\n                      isVisited={isVisited}\n                      isShortest={isShortest}\n                      isWall={isWall}\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                      onMouseEnter={(row, col) =>\n                        this.handleMouseEnter(row, col)\n                      }\n                      onMouseUp={() => this.handleMouseUp()}\n                      width={this.state.width}\n                      height={this.state.height}\n                      numRows={this.state.numRows}\n                      numColumns={this.state.numColumns}\n                    ></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </React.Fragment>\n    );\n  }\n}\n\nfunction getInitialNum(width, height) {\n  let numColumns;\n  if (width > 1500) {\n    numColumns = Math.floor(width / 25);\n  } else if (width > 1250) {\n    numColumns = Math.floor(width / 22.5);\n  } else if (width > 1000) {\n    numColumns = Math.floor(width / 20);\n  } else if (width > 750) {\n    numColumns = Math.floor(width / 17.5);\n  } else if (width > 500) {\n    numColumns = Math.floor(width / 15);\n  } else if (width > 250) {\n    numColumns = Math.floor(width / 12.5);\n  } else if (width > 0) {\n    numColumns = Math.floor(width / 10);\n  }\n  let cellWidth = Math.floor(width / numColumns);\n  let numRows = Math.floor(height / cellWidth);\n  return [numRows, numColumns];\n}\n\nfunction getRandomNums(num) {\n  let randomNums1 = [];\n  let temp = 2;\n  for (let i = 5; i < num / 2; i += 2) {\n    randomNums1.push(temp);\n    temp += 2;\n  }\n  let randomNums2 = [];\n  temp = -2;\n  for (let i = num / 2; i < num - 5; i += 2) {\n    randomNums2.push(temp);\n    temp -= 2;\n  }\n  return [randomNums1, randomNums2];\n}\n\nfunction getStartFinishNode(numRows, numColumns) {\n  let randomNums;\n  let x;\n  let y;\n  let startNodeRow;\n  let startNodeCol;\n  let finishNodeRow;\n  let finishNodeCol;\n  if (numRows < numColumns) {\n    randomNums = getRandomNums(numRows);\n    x = Math.floor(numRows / 2);\n    y = Math.floor(numColumns / 4);\n    if (x % 2 !== 0) x -= 1;\n    if (y % 2 !== 0) y += 1;\n    startNodeRow =\n      x + randomNums[1][Math.floor(Math.random() * randomNums[1].length)];\n    startNodeCol = y + [-6, -4, -2, 0][Math.floor(Math.random() * 4)];\n    finishNodeRow =\n      x + randomNums[0][Math.floor(Math.random() * randomNums[0].length)];\n    finishNodeCol =\n      numColumns - y + [0, 2, 4, 6][Math.floor(Math.random() * 4)];\n  } else {\n    randomNums = getRandomNums(numColumns);\n    x = Math.floor(numRows / 4);\n    y = Math.floor(numColumns / 2);\n    if (x % 2 !== 0) x -= 1;\n    if (y % 2 !== 0) y += 1;\n    startNodeRow = x + [-6, -4, -2, 0][Math.floor(Math.random() * 4)];\n    startNodeCol =\n      y + randomNums[1][Math.floor(Math.random() * randomNums[1].length)];\n    finishNodeRow = numRows - x + [0, 2, 4, 6][Math.floor(Math.random() * 4)];\n    finishNodeCol =\n      y + randomNums[0][Math.floor(Math.random() * randomNums[0].length)];\n  }\n  return [startNodeRow, startNodeCol, finishNodeRow, finishNodeCol];\n}\n\nconst getInitialGrid = (numRows, numColumns) => {\n  let grid = [];\n  for (let row = 0; row < numRows; row++) {\n    let currentRow = [];\n    for (let col = 0; col < numColumns; col++) {\n      currentRow.push(createNode(row, col));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (row, col) => {\n  return {\n    row,\n    col,\n    isStart: row === startNodeRow && col === startNodeCol,\n    isFinish: row === finishNodeRow && col === finishNodeCol,\n    distance: Infinity,\n    totalDistance: Infinity,\n    isVisited: false,\n    isShortest: false,\n    isWall: false,\n    previousNode: null,\n  };\n};\n\nconst getNewGridWithWalls = (grid, row, col) => {\n  let newGrid = grid.slice();\n  let node = grid[row][col];\n  let newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst getNewGridWithMaze = (grid, walls) => {\n  let newGrid = grid.slice();\n  for (let wall of walls) {\n    let node = grid[wall[0]][wall[1]];\n    let newNode = {\n      ...node,\n      isWall: true,\n    };\n    newGrid[wall[0]][wall[1]] = newNode;\n  }\n  return newGrid;\n};\n\nconst getGridWithoutPath = (grid) => {\n  let newGrid = grid.slice();\n  for (let row of grid) {\n    for (let node of row) {\n      let newNode = {\n        ...node,\n        distance: Infinity,\n        totalDistance: Infinity,\n        isVisited: false,\n        isShortest: false,\n        previousNode: null,\n      };\n      newGrid[node.row][node.col] = newNode;\n    }\n  }\n  return newGrid;\n};\n\nconst updateNodesForRender = (\n  grid,\n  nodesInShortestPathOrder,\n  visitedNodesInOrder\n) => {\n  let newGrid = grid.slice();\n  for (let node of visitedNodesInOrder) {\n    if (\n      (node.row === startNodeRow && node.col === startNodeCol) ||\n      (node.row === finishNodeRow && node.col === finishNodeCol)\n    )\n      continue;\n    let newNode = {\n      ...node,\n      isVisited: true,\n    };\n    newGrid[node.row][node.col] = newNode;\n  }\n  for (let node of nodesInShortestPathOrder) {\n    if (node.row === finishNodeRow && node.col === finishNodeCol) {\n      return newGrid;\n    }\n    let newNode = {\n      ...node,\n      isVisited: false,\n      isShortest: true,\n    };\n    newGrid[node.row][node.col] = newNode;\n  }\n};\n\nconst getVisitedNodesInOrder = (\n  visitedNodesInOrderStart,\n  visitedNodesInOrderFinish\n) => {\n  let visitedNodesInOrder = [];\n  let n = Math.max(\n    visitedNodesInOrderStart.length,\n    visitedNodesInOrderFinish.length\n  );\n  for (let i = 0; i < n; i++) {\n    if (visitedNodesInOrderStart[i] !== undefined) {\n      visitedNodesInOrder.push(visitedNodesInOrderStart[i]);\n    }\n    if (visitedNodesInOrderFinish[i] !== undefined) {\n      visitedNodesInOrder.push(visitedNodesInOrderFinish[i]);\n    }\n  }\n  return visitedNodesInOrder;\n};\n\nexport default PathfindingVisualizer;\n\n/* <button className=\"button\" onClick={() => this.visualizeDijkstra()}>\nDijkstra's\n</button>\n&nbsp;\n<button className=\"button\" onClick={() => this.visualizeAStar()}>\nA Star\n</button>\n&nbsp;\n<button className=\"button\" onClick={() => this.visualizeBFS()}>\nBreadth First Search\n</button>\n&nbsp;\n<button className=\"button\" onClick={() => this.visualizeDFS()}>\nDepth First Search\n</button>\n&nbsp;\n<button className=\"button\" onClick={() => this.visualizeRandomWalk()}>\nRandom Walk\n</button>\n&nbsp;\n<button className=\"button\" onClick={() => this.clearGrid()}>\nClear Grid\n</button>\n<br />\n<button className=\"button\" onClick={() => this.visualizeGreedyBFS()}>\nGreedy Best First Search\n</button>\n&nbsp;\n<button\nclassName=\"button\"\nonClick={() => this.visualizeBidirectionalGreedySearch()}\n>\nBidirectional Best First Search\n</button>\n&nbsp;\n<button className=\"button\" onClick={() => this.generateRandomMaze()}>\nRandom Maze\n</button>\n&nbsp;\n<button\nclassName=\"button\"\nonClick={() => this.generateRecursiveDivisionMaze()}\n>\nRecursive Division\n</button>\n&nbsp;\n<button\nclassName=\"button\"\nonClick={() => this.generateVerticalMaze()}\n>\nVertical Maze\n</button>\n&nbsp;\n<button\nclassName=\"button\"\nonClick={() => this.generateHorizontalMaze()}\n>\nHorizontal Maze\n</button>\n */\n"]},"metadata":{},"sourceType":"module"}