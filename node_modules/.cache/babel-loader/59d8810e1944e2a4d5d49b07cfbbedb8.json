{"ast":null,"code":"export function astar(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n\n  let unvisitedNodes = []; //open list\n\n  let visitedNodesInOrder = []; //closed list\n\n  startNode.distance = 0;\n  unvisitedNodes.push(startNode);\n\n  while (unvisitedNodes.length !== 0) {\n    unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\n    let closestNode = unvisitedNodes.shift();\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    let neighbours = getNeighbours(closestNode, grid);\n\n    for (let neighbour of neighbours) {\n      let distance = closestNode.distance + 1; //f(n) = g(n) + h(n)\n\n      if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\n        unvisitedNodes.unshift(neighbour);\n        neighbour.distance = distance;\n        neighbour.totalDistance = distance + manhattenDistance(neighbour, finishNode);\n        neighbour.previousNode = closestNode;\n      } else if (distance < neighbour.distance) {\n        neighbour.distance = distance;\n        neighbour.totalDistance = distance + manhattenDistance(neighbour, finishNode);\n        neighbour.previousNode = closestNode;\n      }\n    }\n  }\n\n  return visitedNodesInOrder;\n}\n\nfunction getNeighbours(node, grid) {\n  let neighbours = [];\n  let {\n    row,\n    col\n  } = node;\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  return neighbours.filter(neighbour => !neighbour.isWall && !neighbour.isVisited);\n}\n\nfunction neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n  for (let node of unvisitedNodes) {\n    if (node.row === neighbour.row && node.col === neighbour.col) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction manhattenDistance(node, finishNode) {\n  let x = Math.abs(node.row - finishNode.row);\n  let y = Math.abs(node.col - finishNode.col);\n  return x + y;\n}\n\nexport function getNodesInShortestPathOrderAstar(finishNode) {\n  let nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return nodesInShortestPathOrder;\n}","map":{"version":3,"sources":["F:/Deerwalk/semester-5/Micro Project/pathfinding-visualizer-master/src/pathfindingAlgorithms/astar.js"],"names":["astar","grid","startNode","finishNode","unvisitedNodes","visitedNodesInOrder","distance","push","length","sort","a","b","totalDistance","closestNode","shift","isVisited","neighbours","getNeighbours","neighbour","neighbourNotInUnvisitedNodes","unshift","manhattenDistance","previousNode","node","row","col","filter","isWall","x","Math","abs","y","getNodesInShortestPathOrderAstar","nodesInShortestPathOrder","currentNode"],"mappings":"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","sourcesContent":["export function astar(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let unvisitedNodes = []; //open list\n  let visitedNodesInOrder = []; //closed list\n  startNode.distance = 0;\n  unvisitedNodes.push(startNode);\n\n  while (unvisitedNodes.length !== 0) {\n    unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\n    let closestNode = unvisitedNodes.shift();\n    if (closestNode === finishNode) return visitedNodesInOrder;\n\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n\n    let neighbours = getNeighbours(closestNode, grid);\n    for (let neighbour of neighbours) {\n      let distance = closestNode.distance + 1;\n      //f(n) = g(n) + h(n)\n      if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\n        unvisitedNodes.unshift(neighbour);\n        neighbour.distance = distance;\n        neighbour.totalDistance =\n          distance + manhattenDistance(neighbour, finishNode);\n        neighbour.previousNode = closestNode;\n      } else if (distance < neighbour.distance) {\n        neighbour.distance = distance;\n        neighbour.totalDistance =\n          distance + manhattenDistance(neighbour, finishNode);\n        neighbour.previousNode = closestNode;\n      }\n    }\n  }\n  return visitedNodesInOrder;\n}\n\nfunction getNeighbours(node, grid) {\n  let neighbours = [];\n  let { row, col } = node;\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  return neighbours.filter(\n    (neighbour) => !neighbour.isWall && !neighbour.isVisited\n  );\n}\n\nfunction neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n  for (let node of unvisitedNodes) {\n    if (node.row === neighbour.row && node.col === neighbour.col) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction manhattenDistance(node, finishNode) {\n  let x = Math.abs(node.row - finishNode.row);\n  let y = Math.abs(node.col - finishNode.col);\n  return x + y;\n}\n\nexport function getNodesInShortestPathOrderAstar(finishNode) {\n  let nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n"]},"metadata":{},"sourceType":"module"}