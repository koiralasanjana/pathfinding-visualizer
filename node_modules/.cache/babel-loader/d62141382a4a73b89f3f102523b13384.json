{"ast":null,"code":"import _createForOfIteratorHelper from\"F:\\\\Deerwalk\\\\semester-5\\\\Micro Project\\\\pathfinding-visualizer\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";export function dijkstra(grid,startNode,finishNode){if(!startNode||!finishNode||startNode===finishNode){return false;}startNode.distance=0;var unvisitedNodes=getNodes(grid);var visitedNodesInOrder=[];while(unvisitedNodes.length!==0){unvisitedNodes.sort(function(a,b){return a.distance-b.distance;});var closestNode=unvisitedNodes.shift();if(closestNode.isWall)continue;if(closestNode.distance===Infinity)return visitedNodesInOrder;if(closestNode===finishNode)return visitedNodesInOrder;closestNode.isVisited=true;visitedNodesInOrder.push(closestNode);updateUnvisitedNeighbours(closestNode,grid);}}function getNodes(grid){var nodes=[];var _iterator=_createForOfIteratorHelper(grid),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var row=_step.value;var _iterator2=_createForOfIteratorHelper(row),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var node=_step2.value;nodes.push(node);}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}}}catch(err){_iterator.e(err);}finally{_iterator.f();}return nodes;}function updateUnvisitedNeighbours(node,grid){var unvisitedNeighbours=getUnvisitedNeighbours(node,grid);var _iterator3=_createForOfIteratorHelper(unvisitedNeighbours),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var unvisitedNeighbour=_step3.value;unvisitedNeighbour.distance=node.distance+1;unvisitedNeighbour.previousNode=node;}}catch(err){_iterator3.e(err);}finally{_iterator3.f();}}function getUnvisitedNeighbours(node,grid){var neighbours=[];var row=node.row,col=node.col;if(row!==0)neighbours.push(grid[row-1][col]);if(col!==grid[0].length-1)neighbours.push(grid[row][col+1]);if(row!==grid.length-1)neighbours.push(grid[row+1][col]);if(col!==0)neighbours.push(grid[row][col-1]);return neighbours.filter(function(neighbour){return!neighbour.isWall;}).filter(function(neighbour){return!neighbour.isVisited;});}export function getNodesInShortestPathOrderDijkstra(finishNode){var nodesInShortestPathOrder=[];var currentNode=finishNode;while(currentNode!==null){nodesInShortestPathOrder.unshift(currentNode);currentNode=currentNode.previousNode;}return nodesInShortestPathOrder;}","map":{"version":3,"sources":["F:/Deerwalk/semester-5/Micro Project/pathfinding-visualizer/src/pathfindingAlgorithms/dijkstra.js"],"names":["dijkstra","grid","startNode","finishNode","distance","unvisitedNodes","getNodes","visitedNodesInOrder","length","sort","a","b","closestNode","shift","isWall","Infinity","isVisited","push","updateUnvisitedNeighbours","nodes","row","node","unvisitedNeighbours","getUnvisitedNeighbours","unvisitedNeighbour","previousNode","neighbours","col","filter","neighbour","getNodesInShortestPathOrderDijkstra","nodesInShortestPathOrder","currentNode","unshift"],"mappings":"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","sourcesContent":["export function dijkstra(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  startNode.distance = 0;\n  let unvisitedNodes = getNodes(grid);\n  let visitedNodesInOrder = [];\n  while (unvisitedNodes.length !== 0) {\n    unvisitedNodes.sort((a, b) => a.distance - b.distance);\n    let closestNode = unvisitedNodes.shift();\n    if (closestNode.isWall) continue;\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    updateUnvisitedNeighbours(closestNode, grid);\n  }\n}\n\nfunction getNodes(grid) {\n  let nodes = [];\n  for (let row of grid) {\n    for (let node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\nfunction updateUnvisitedNeighbours(node, grid) {\n  let unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\n  for (let unvisitedNeighbour of unvisitedNeighbours) {\n    unvisitedNeighbour.distance = node.distance + 1;\n    unvisitedNeighbour.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n  let neighbours = [];\n  let { row, col } = node;\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  return neighbours\n    .filter((neighbour) => !neighbour.isWall)\n    .filter((neighbour) => !neighbour.isVisited);\n}\n\nexport function getNodesInShortestPathOrderDijkstra(finishNode) {\n  let nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n"]},"metadata":{},"sourceType":"module"}