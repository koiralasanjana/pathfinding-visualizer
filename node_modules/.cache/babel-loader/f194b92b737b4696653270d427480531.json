{"ast":null,"code":"export function astar(grid, startNode, finishNode) {\n  setAllDistanceToInfinity(grid);\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  fillXandYCordinates(grid, startNode, finishNode);\n  addHeuristicDistanceToNodes(grid, startNode, finishNode);\n  console.log(startNode, finishNode);\n  const unvisitedNodes = getAllNodes(grid);\n\n  while (unvisitedNodes.length) {\n    sortNodesByTotalDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    if (closestNode.isWall) continue;\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n\n  for (let neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1; // neighbor.distance = node.distance + (node.distance - neighbor.distance);\n    // neighbor.totalDistance = node.distance + neighbor.heuristicDistance;\n\n    neighbor.totalDistance = neighbor.distance + neighbor.heuristicDistance;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction setAllDistanceToInfinity(grid) {\n  for (const row of grid) {\n    for (const node of row) {\n      node.distance = Infinity;\n      node.isVisited = false;\n      node.previousNode = null;\n    }\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const {\n    row,\n    col\n  } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nfunction addHeuristicDistanceToNodes(grid, startNode, finishNode) {\n  for (const row of grid) {\n    for (const node of row) {\n      const diffX = Math.abs(node.x - finishNode.x);\n      const diffY = Math.abs(node.y - finishNode.y);\n      const manhattanDistance = diffX + diffY;\n      node.heuristicDistance = manhattanDistance * 1.0000000001;\n      node.totalDistance = node.distance + node.heuristicDistance;\n    }\n  }\n}\n\nfunction fillXandYCordinates(grid, startNode, finishNode) {\n  let xValue = 0,\n      yValue = 0;\n\n  for (let i = grid.length; i > 0; i--) {\n    xValue = 0;\n\n    for (let j = 0; j < grid[0].length; j++) {\n      grid[i - 1][j].x = xValue;\n      grid[i - 1][j].y = yValue;\n      xValue += 1;\n    }\n\n    yValue += 1;\n  }\n}\n\nfunction sortNodesByTotalDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.totalDistance - nodeB.totalDistance);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n\n  return nodes;\n}\n\nexport function getNodesInShortestPathOrderAstar(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n\n  while (currentNode !== null) {\n    //unshift adds element to the begining of array\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return nodesInShortestPathOrder;\n}","map":{"version":3,"sources":["F:/Deerwalk/semester-5/Micro Project/my-project/pathfinding-visualizer-master/src/algorithms/astar1.js"],"names":["astar","grid","startNode","finishNode","setAllDistanceToInfinity","visitedNodesInOrder","distance","fillXandYCordinates","addHeuristicDistanceToNodes","console","log","unvisitedNodes","getAllNodes","length","sortNodesByTotalDistance","closestNode","shift","isWall","Infinity","isVisited","push","updateUnvisitedNeighbors","node","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","totalDistance","heuristicDistance","previousNode","row","neighbors","col","filter","diffX","Math","abs","x","diffY","y","manhattanDistance","xValue","yValue","i","j","sort","nodeA","nodeB","nodes","getNodesInShortestPathOrderAstar","nodesInShortestPathOrder","currentNode","unshift"],"mappings":"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","sourcesContent":["export function astar(grid, startNode, finishNode) {\n  setAllDistanceToInfinity(grid);\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  fillXandYCordinates(grid, startNode, finishNode);\n  addHeuristicDistanceToNodes(grid, startNode, finishNode);\n  console.log(startNode, finishNode);\n  const unvisitedNodes = getAllNodes(grid);\n  while (unvisitedNodes.length) {\n    sortNodesByTotalDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    if (closestNode.isWall) continue;\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (let neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    // neighbor.distance = node.distance + (node.distance - neighbor.distance);\n    // neighbor.totalDistance = node.distance + neighbor.heuristicDistance;\n    neighbor.totalDistance = neighbor.distance + neighbor.heuristicDistance;\n\n    neighbor.previousNode = node;\n  }\n}\nfunction setAllDistanceToInfinity(grid) {\n  for (const row of grid) {\n    for (const node of row) {\n      node.distance = Infinity;\n      node.isVisited = false;\n      node.previousNode = null;\n    }\n  }\n}\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { row, col } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\nfunction addHeuristicDistanceToNodes(grid, startNode, finishNode) {\n  for (const row of grid) {\n    for (const node of row) {\n      const diffX = Math.abs(node.x - finishNode.x);\n      const diffY = Math.abs(node.y - finishNode.y);\n      const manhattanDistance = diffX + diffY;\n      node.heuristicDistance = manhattanDistance * 1.0000000001;\n      node.totalDistance = node.distance + node.heuristicDistance;\n    }\n  }\n}\nfunction fillXandYCordinates(grid, startNode, finishNode) {\n  let xValue = 0,\n    yValue = 0;\n  for (let i = grid.length; i > 0; i--) {\n    xValue = 0;\n    for (let j = 0; j < grid[0].length; j++) {\n      grid[i - 1][j].x = xValue;\n      grid[i - 1][j].y = yValue;\n      xValue += 1;\n    }\n    yValue += 1;\n  }\n}\nfunction sortNodesByTotalDistance(unvisitedNodes) {\n  unvisitedNodes.sort(\n    (nodeA, nodeB) => nodeA.totalDistance - nodeB.totalDistance\n  );\n}\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\nexport function getNodesInShortestPathOrderAstar(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    //unshift adds element to the begining of array\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n"]},"metadata":{},"sourceType":"module"}