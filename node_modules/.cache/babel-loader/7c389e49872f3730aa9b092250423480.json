{"ast":null,"code":"export function breadthFirstSearch(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n\n  let unvisitedNodes = [];\n  let visitedNodesInOrder = [];\n  unvisitedNodes.push(startNode);\n\n  while (unvisitedNodes.length !== 0) {\n    let closestNode = unvisitedNodes.shift();\n    if (closestNode.isWall) continue;\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    visitedNodesInOrder.push(closestNode);\n    closestNode.isVisited = true;\n    let unvisitedNeighbours = getUnvisitedNeighbours(closestNode, grid);\n\n    for (let unvisitedNeighbour of unvisitedNeighbours) {\n      unvisitedNeighbour.previousNode = closestNode;\n\n      if (neighbourNotInUnvisitedNodes(unvisitedNeighbour, unvisitedNodes)) {\n        unvisitedNodes.push(unvisitedNeighbour);\n      }\n    }\n  }\n\n  return visitedNodesInOrder;\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n  let neighbours = [];\n  let {\n    row,\n    col\n  } = node;\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  return neighbours.filter(neighbour => !neighbour.isVisited);\n}\n\nfunction neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n  for (let node of unvisitedNodes) {\n    if (node.row === neighbour.row && node.col === neighbour.col) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function getNodesInShortestPathOrderBFS(finishNode) {\n  let nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return nodesInShortestPathOrder;\n}","map":{"version":3,"sources":["F:/Deerwalk/semester-5/Micro Project/pathfinding-visualizer-master/src/pathfindingAlgorithms/breadthFirstSearch.js"],"names":["breadthFirstSearch","grid","startNode","finishNode","unvisitedNodes","visitedNodesInOrder","push","length","closestNode","shift","isWall","isVisited","unvisitedNeighbours","getUnvisitedNeighbours","unvisitedNeighbour","previousNode","neighbourNotInUnvisitedNodes","node","neighbours","row","col","filter","neighbour","getNodesInShortestPathOrderBFS","nodesInShortestPathOrder","currentNode","unshift"],"mappings":"AAAA,OAAO,SAASA,kBAAT,CAA4BC,IAA5B,EAAkCC,SAAlC,EAA6CC,UAA7C,EAAyD;AAC9D,MAAI,CAACD,SAAD,IAAc,CAACC,UAAf,IAA6BD,SAAS,KAAKC,UAA/C,EAA2D;AACzD,WAAO,KAAP;AACD;;AACD,MAAIC,cAAc,GAAG,EAArB;AACA,MAAIC,mBAAmB,GAAG,EAA1B;AACAD,EAAAA,cAAc,CAACE,IAAf,CAAoBJ,SAApB;;AACA,SAAOE,cAAc,CAACG,MAAf,KAA0B,CAAjC,EAAoC;AAClC,QAAIC,WAAW,GAAGJ,cAAc,CAACK,KAAf,EAAlB;AACA,QAAID,WAAW,CAACE,MAAhB,EAAwB;AACxB,QAAIF,WAAW,KAAKL,UAApB,EAAgC,OAAOE,mBAAP;AAChCA,IAAAA,mBAAmB,CAACC,IAApB,CAAyBE,WAAzB;AACAA,IAAAA,WAAW,CAACG,SAAZ,GAAwB,IAAxB;AACA,QAAIC,mBAAmB,GAAGC,sBAAsB,CAACL,WAAD,EAAcP,IAAd,CAAhD;;AACA,SAAK,IAAIa,kBAAT,IAA+BF,mBAA/B,EAAoD;AAClDE,MAAAA,kBAAkB,CAACC,YAAnB,GAAkCP,WAAlC;;AACA,UAAIQ,4BAA4B,CAACF,kBAAD,EAAqBV,cAArB,CAAhC,EAAsE;AACpEA,QAAAA,cAAc,CAACE,IAAf,CAAoBQ,kBAApB;AACD;AACF;AACF;;AACD,SAAOT,mBAAP;AACD;;AAED,SAASQ,sBAAT,CAAgCI,IAAhC,EAAsChB,IAAtC,EAA4C;AAC1C,MAAIiB,UAAU,GAAG,EAAjB;AACA,MAAI;AAAEC,IAAAA,GAAF;AAAOC,IAAAA;AAAP,MAAeH,IAAnB;AACA,MAAIE,GAAG,KAAK,CAAZ,EAAeD,UAAU,CAACZ,IAAX,CAAgBL,IAAI,CAACkB,GAAG,GAAG,CAAP,CAAJ,CAAcC,GAAd,CAAhB;AACf,MAAIA,GAAG,KAAKnB,IAAI,CAAC,CAAD,CAAJ,CAAQM,MAAR,GAAiB,CAA7B,EAAgCW,UAAU,CAACZ,IAAX,CAAgBL,IAAI,CAACkB,GAAD,CAAJ,CAAUC,GAAG,GAAG,CAAhB,CAAhB;AAChC,MAAID,GAAG,KAAKlB,IAAI,CAACM,MAAL,GAAc,CAA1B,EAA6BW,UAAU,CAACZ,IAAX,CAAgBL,IAAI,CAACkB,GAAG,GAAG,CAAP,CAAJ,CAAcC,GAAd,CAAhB;AAC7B,MAAIA,GAAG,KAAK,CAAZ,EAAeF,UAAU,CAACZ,IAAX,CAAgBL,IAAI,CAACkB,GAAD,CAAJ,CAAUC,GAAG,GAAG,CAAhB,CAAhB;AACf,SAAOF,UAAU,CAACG,MAAX,CAAmBC,SAAD,IAAe,CAACA,SAAS,CAACX,SAA5C,CAAP;AACD;;AAED,SAASK,4BAAT,CAAsCM,SAAtC,EAAiDlB,cAAjD,EAAiE;AAC/D,OAAK,IAAIa,IAAT,IAAiBb,cAAjB,EAAiC;AAC/B,QAAIa,IAAI,CAACE,GAAL,KAAaG,SAAS,CAACH,GAAvB,IAA8BF,IAAI,CAACG,GAAL,KAAaE,SAAS,CAACF,GAAzD,EAA8D;AAC5D,aAAO,KAAP;AACD;AACF;;AACD,SAAO,IAAP;AACD;;AAED,OAAO,SAASG,8BAAT,CAAwCpB,UAAxC,EAAoD;AACzD,MAAIqB,wBAAwB,GAAG,EAA/B;AACA,MAAIC,WAAW,GAAGtB,UAAlB;;AACA,SAAOsB,WAAW,KAAK,IAAvB,EAA6B;AAC3BD,IAAAA,wBAAwB,CAACE,OAAzB,CAAiCD,WAAjC;AACAA,IAAAA,WAAW,GAAGA,WAAW,CAACV,YAA1B;AACD;;AACD,SAAOS,wBAAP;AACD","sourcesContent":["export function breadthFirstSearch(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let unvisitedNodes = [];\n  let visitedNodesInOrder = [];\n  unvisitedNodes.push(startNode);\n  while (unvisitedNodes.length !== 0) {\n    let closestNode = unvisitedNodes.shift();\n    if (closestNode.isWall) continue;\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    visitedNodesInOrder.push(closestNode);\n    closestNode.isVisited = true;\n    let unvisitedNeighbours = getUnvisitedNeighbours(closestNode, grid);\n    for (let unvisitedNeighbour of unvisitedNeighbours) {\n      unvisitedNeighbour.previousNode = closestNode;\n      if (neighbourNotInUnvisitedNodes(unvisitedNeighbour, unvisitedNodes)) {\n        unvisitedNodes.push(unvisitedNeighbour);\n      }\n    }\n  }\n  return visitedNodesInOrder;\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n  let neighbours = [];\n  let { row, col } = node;\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  return neighbours.filter((neighbour) => !neighbour.isVisited);\n}\n\nfunction neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n  for (let node of unvisitedNodes) {\n    if (node.row === neighbour.row && node.col === neighbour.col) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function getNodesInShortestPathOrderBFS(finishNode) {\n  let nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n"]},"metadata":{},"sourceType":"module"}