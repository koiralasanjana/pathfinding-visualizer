{"ast":null,"code":"export function bidirectionalGreedySearch(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n\n  let unvisitedNodesStart = [];\n  let visitedNodesInOrderStart = [];\n  let unvisitedNodesFinish = [];\n  let visitedNodesInOrderFinish = [];\n  startNode.distance = 0;\n  finishNode.distance = 0;\n  unvisitedNodesStart.push(startNode);\n  unvisitedNodesFinish.push(finishNode);\n\n  while (unvisitedNodesStart.length !== 0 && unvisitedNodesFinish.length !== 0) {\n    unvisitedNodesStart.sort((a, b) => a.totalDistance - b.totalDistance);\n    unvisitedNodesFinish.sort((a, b) => a.totalDistance - b.totalDistance);\n    let closestNodeStart = unvisitedNodesStart.shift();\n    let closestNodeFinish = unvisitedNodesFinish.shift();\n    closestNodeStart.isVisited = true;\n    closestNodeFinish.isVisited = true;\n    visitedNodesInOrderStart.push(closestNodeStart);\n    visitedNodesInOrderFinish.push(closestNodeFinish);\n\n    if (isNeighbour(closestNodeStart, closestNodeFinish)) {\n      return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n    } //Start side search\n\n\n    let neighbours = getNeighbours(closestNodeStart, grid);\n\n    for (let neighbour of neighbours) {\n      if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n        visitedNodesInOrderStart.push(closestNodeStart);\n        visitedNodesInOrderFinish.push(neighbour);\n        return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n      }\n\n      let distance = closestNodeStart.distance + 1; //f(n) = h(n)\n\n      if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n        unvisitedNodesStart.unshift(neighbour);\n        neighbour.distance = distance;\n        neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n        neighbour.previousNode = closestNodeStart;\n      } else if (distance < neighbour.distance) {\n        neighbour.distance = distance;\n        neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n        neighbour.previousNode = closestNodeStart;\n      }\n    } //Finish side search\n\n\n    neighbours = getNeighbours(closestNodeFinish, grid);\n\n    for (let neighbour of neighbours) {\n      if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n        visitedNodesInOrderStart.push(closestNodeFinish);\n        visitedNodesInOrderStart.push(neighbour);\n        return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n      }\n\n      let distance = closestNodeFinish.distance + 1; //f(n) = h(n)\n\n      if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n        unvisitedNodesFinish.unshift(neighbour);\n        neighbour.distance = distance;\n        neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n        neighbour.previousNode = closestNodeFinish;\n      } else if (distance < neighbour.distance) {\n        neighbour.distance = distance;\n        neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n        neighbour.previousNode = closestNodeFinish;\n      }\n    }\n  }\n\n  return [visitedNodesInOrderStart, visitedNodesInOrderFinish, false];\n}\n\nfunction isNeighbour(closestNodeStart, closestNodeFinish) {\n  let rowStart = closestNodeStart.row;\n  let colStart = closestNodeStart.col;\n  let rowFinish = closestNodeFinish.row;\n  let colFinish = closestNodeFinish.col;\n  if (rowFinish === rowStart - 1 && colFinish === colStart) return true;\n  if (rowFinish === rowStart && colFinish === colStart + 1) return true;\n  if (rowFinish === rowStart + 1 && colFinish === colStart) return true;\n  if (rowFinish === rowStart && colFinish === colStart - 1) return true;\n  return false;\n}\n\nfunction getNeighbours(node, grid) {\n  let neighbours = [];\n  let {\n    row,\n    col\n  } = node;\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  return neighbours.filter(neighbour => !neighbour.isWall && !neighbour.isVisited);\n}\n\nfunction manhattenDistance(nodeA, nodeB) {\n  let x = Math.abs(nodeA.row - nodeB.row);\n  let y = Math.abs(nodeA.col - nodeB.col);\n  return x + y;\n}\n\nfunction neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n  for (let node of unvisitedNodes) {\n    if (node.row === neighbour.row && node.col === neighbour.col) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function getNodesInShortestPathOrderBidirectionalGreedySearch(nodeA, nodeB) {\n  let nodesInShortestPathOrder = [];\n  let currentNode = nodeB;\n\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.push(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  currentNode = nodeA;\n\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return nodesInShortestPathOrder;\n}","map":{"version":3,"sources":["F:/Deerwalk/semester-5/Micro Project/pathfinding-visualizer-master/src/pathfindingAlgorithms/bidirectionalGreedySearch.js"],"names":["bidirectionalGreedySearch","grid","startNode","finishNode","unvisitedNodesStart","visitedNodesInOrderStart","unvisitedNodesFinish","visitedNodesInOrderFinish","distance","push","length","sort","a","b","totalDistance","closestNodeStart","shift","closestNodeFinish","isVisited","isNeighbour","neighbours","getNeighbours","neighbour","neighbourNotInUnvisitedNodes","unshift","manhattenDistance","previousNode","rowStart","row","colStart","col","rowFinish","colFinish","node","filter","isWall","nodeA","nodeB","x","Math","abs","y","unvisitedNodes","getNodesInShortestPathOrderBidirectionalGreedySearch","nodesInShortestPathOrder","currentNode"],"mappings":"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","sourcesContent":["export function bidirectionalGreedySearch(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let unvisitedNodesStart = [];\n  let visitedNodesInOrderStart = [];\n  let unvisitedNodesFinish = [];\n  let visitedNodesInOrderFinish = [];\n  startNode.distance = 0;\n  finishNode.distance = 0;\n  unvisitedNodesStart.push(startNode);\n  unvisitedNodesFinish.push(finishNode);\n\n  while (\n    unvisitedNodesStart.length !== 0 &&\n    unvisitedNodesFinish.length !== 0\n  ) {\n    unvisitedNodesStart.sort((a, b) => a.totalDistance - b.totalDistance);\n    unvisitedNodesFinish.sort((a, b) => a.totalDistance - b.totalDistance);\n    let closestNodeStart = unvisitedNodesStart.shift();\n    let closestNodeFinish = unvisitedNodesFinish.shift();\n\n    closestNodeStart.isVisited = true;\n    closestNodeFinish.isVisited = true;\n    visitedNodesInOrderStart.push(closestNodeStart);\n    visitedNodesInOrderFinish.push(closestNodeFinish);\n    if (isNeighbour(closestNodeStart, closestNodeFinish)) {\n      return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n    }\n\n    //Start side search\n    let neighbours = getNeighbours(closestNodeStart, grid);\n    for (let neighbour of neighbours) {\n      if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n        visitedNodesInOrderStart.push(closestNodeStart);\n        visitedNodesInOrderFinish.push(neighbour);\n        return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n      }\n      let distance = closestNodeStart.distance + 1;\n      //f(n) = h(n)\n      if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n        unvisitedNodesStart.unshift(neighbour);\n        neighbour.distance = distance;\n        neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n        neighbour.previousNode = closestNodeStart;\n      } else if (distance < neighbour.distance) {\n        neighbour.distance = distance;\n        neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n        neighbour.previousNode = closestNodeStart;\n      }\n    }\n\n    //Finish side search\n    neighbours = getNeighbours(closestNodeFinish, grid);\n    for (let neighbour of neighbours) {\n      if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n        visitedNodesInOrderStart.push(closestNodeFinish);\n        visitedNodesInOrderStart.push(neighbour);\n        return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n      }\n      let distance = closestNodeFinish.distance + 1;\n      //f(n) = h(n)\n      if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n        unvisitedNodesFinish.unshift(neighbour);\n        neighbour.distance = distance;\n        neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n        neighbour.previousNode = closestNodeFinish;\n      } else if (distance < neighbour.distance) {\n        neighbour.distance = distance;\n        neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n        neighbour.previousNode = closestNodeFinish;\n      }\n    }\n  }\n  return [visitedNodesInOrderStart, visitedNodesInOrderFinish, false];\n}\n\nfunction isNeighbour(closestNodeStart, closestNodeFinish) {\n  let rowStart = closestNodeStart.row;\n  let colStart = closestNodeStart.col;\n  let rowFinish = closestNodeFinish.row;\n  let colFinish = closestNodeFinish.col;\n  if (rowFinish === rowStart - 1 && colFinish === colStart) return true;\n  if (rowFinish === rowStart && colFinish === colStart + 1) return true;\n  if (rowFinish === rowStart + 1 && colFinish === colStart) return true;\n  if (rowFinish === rowStart && colFinish === colStart - 1) return true;\n  return false;\n}\n\nfunction getNeighbours(node, grid) {\n  let neighbours = [];\n  let { row, col } = node;\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  return neighbours.filter(\n    (neighbour) => !neighbour.isWall && !neighbour.isVisited\n  );\n}\n\nfunction manhattenDistance(nodeA, nodeB) {\n  let x = Math.abs(nodeA.row - nodeB.row);\n  let y = Math.abs(nodeA.col - nodeB.col);\n  return x + y;\n}\n\nfunction neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n  for (let node of unvisitedNodes) {\n    if (node.row === neighbour.row && node.col === neighbour.col) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function getNodesInShortestPathOrderBidirectionalGreedySearch(\n  nodeA,\n  nodeB\n) {\n  let nodesInShortestPathOrder = [];\n  let currentNode = nodeB;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.push(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  currentNode = nodeA;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n"]},"metadata":{},"sourceType":"module"}